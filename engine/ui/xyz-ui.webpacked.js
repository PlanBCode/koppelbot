var xyz =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./source/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../engine/core/displays/item.js":
/*!*****************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/displays/item.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\noptions:\n\n- showHeader\n- showLabels\n- showDeleteButton\n\n */\n\nconst list = __webpack_require__(/*! ./list.js */ \"../../engine/core/displays/list.js\");\nconst response = __webpack_require__(/*! ../../../factory/js/source/entity/response */ \"./source/entity/response.js\"); //TODO better solution\n\nexports.display = {\n    waitingForInput: display => {\n        display.getWRAPPER().innerHTML = 'Waiting for input...';\n    },\n    waitingForData: display => {\n        display.getWRAPPER().innerHTML = 'Waiting for data...';\n    },\n    empty: display => {\n        display.getWRAPPER().innerHTML = 'No items to display.';\n    },\n    first: display => {\n        display.getWRAPPER().innerHTML = '';\n    },\n    entity: display => {\n        const WRAPPER = display.getWRAPPER();\n        const entityId = display.getEntityId();\n        const entityClassName = display.getEntityClassName();\n\n        let content = display.getContent();\n        const path = display.getRequestUri().substr(1).split('/').slice(2);\n        content = response.filter(content, path); //TODO move to before calling entity\n\n        const columns = list.flatten(content, display.getRequestUri());\n\n        const TABLE_entity = document.createElement('TABLE');\n        TABLE_entity.className = 'xyz-item';\n        TABLE_entity.entityId = entityId;\n        const uri = '/' + entityClassName + '/' + entityId;\n        if (display.getOption('showHeader') !== false) {\n            const TR_header = document.createElement('TR');\n            TR_header.className = 'xyz-item-header';\n            const TD_header = document.createElement('TD');\n            TD_header.innerHTML = uri;\n            TD_header.setAttribute('colspan', display.getOption('showLabels') !== false ? '2' : '1');\n            TR_header.appendChild(TD_header);\n            TABLE_entity.appendChild(TR_header);\n        }\n        if (columns.constructor !== Object) {\n            const node = columns;\n            const TR_entity = document.createElement('TR');\n            //todo name\n            const TD_entityContent = document.createElement('TD');\n            const TAG = node.render(display.getAction(), display.getOptions());\n            TD_entityContent.appendChild(TAG);\n            TR_entity.appendChild(TD_entityContent);\n            TABLE_entity.appendChild(TR_entity);\n        } else {\n\n            for (let flatPropertyName in columns) {\n                const TR_flatProperty = document.createElement('TR');\n\n                if (display.getOption('showLabels') !== false) {\n                    const TD_flatPropertyName = document.createElement('TD');\n                    TD_flatPropertyName.innerHTML = flatPropertyName;\n                    TR_flatProperty.appendChild(TD_flatPropertyName);\n                }\n                const TD_flatPropertyContent = document.createElement('TD');\n                const node = columns[flatPropertyName];\n                const TAG = node.render(display.getAction(), display.getOptions());\n                TD_flatPropertyContent.appendChild(TAG);\n                TR_flatProperty.appendChild(TD_flatPropertyContent);\n                TABLE_entity.appendChild(TR_flatProperty);\n            }\n        }\n        if (display.getOption('showDeleteButton') === true) {\n            const TR_deleteButton = document.createElement('TR');\n            const TD_deleteButton = document.createElement('TD');\n            TD_deleteButton.setAttribute('colspan', 2);\n            const INPUT_deleteButton = document.createElement('INPUT');\n            INPUT_deleteButton.type = 'submit';\n            INPUT_deleteButton.value = 'Delete';\n            INPUT_deleteButton.onclick = () => {\n                display.xyz.delete(uri); //TODO encapsulate xyz\n            };\n            TD_deleteButton.appendChild(INPUT_deleteButton);\n            TR_deleteButton.appendChild(TD_deleteButton);\n            TABLE_entity.appendChild(TR_deleteButton);\n        }\n        WRAPPER.appendChild(TABLE_entity);\n    },\n    remove: display => {\n        const WRAPPER = display.getWRAPPER();\n        const entityId = display.getEntityId();\n        for (let TABLE_entity of WRAPPER.childNodes) {\n            if (typeof TABLE_entity.entityId === 'string' && (TABLE_entity.entityId === entityId || entityId === '*')) {\n                WRAPPER.removeChild(TABLE_entity);\n            }\n        }\n    }\n};\n\n\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/displays/item.js?");

/***/ }),

/***/ "../../engine/core/displays/list.js":
/*!*****************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/displays/list.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\noptions\n- select\n- multiSelect\n- showHeader\n- addCreateButton\n- createButtonText\n\n- TODO default\n- TODO addDeleteButtons\n- TODO addEditButtons\n- TODO add multiselect tools\n */\n\nfunction select(xyz, variableNameOrCallback, entityClassName, entityId) {\n    if (typeof variableNameOrCallback === 'string') {\n        if (typeof entityId === 'undefined' && typeof entityClassName === 'undefined') {\n            xyz.clearVariable(variableNameOrCallback);\n        } else {\n            xyz.setVariable(variableNameOrCallback, '/' + entityClassName + '/' + entityId);\n        }\n    } else if (typeof variableNameOrCallback === 'function') {\n        variableNameOrCallback(entityClassName, entityId);\n    }\n}\n\nfunction getUrisFromVariable(xyz, variableName, entityClassName) {\n    if (!xyz.hasVariable(variableName)) {\n        return [];\n    }\n    return xyz.getVariable(variableName).split(',')  // \"/fruit/apple,pear\" => [\"/fruit/apple\",\"/fruit/pear\"]\n        .map(uri => uri.split('/'))\n        .map(path => ('/' + entityClassName + '/' + path[path.length - 1]));\n}\n\nfunction flatten2(source, target, prefix) {\n    if (source.constructor !== Object) return;\n    for (let key in source) {\n        const value = source[key];\n        if (value.constructor === Object) {\n            flatten2(value, target, prefix + key + '.');\n        } else {\n            target[prefix + key] = value;\n        }\n    }\n}\n\nfunction flatten(source) {\n    if (source.constructor !== Object) return source;\n    const target = {};\n    flatten2(source, target, '');\n    return target;\n}\n\nfunction addCreateButton(display) {\n    //TODO only if has the permissions to add\n    if (display.getOption('addCreateButton') !== false) {\n        const INPUT = document.createElement('INPUT');\n        INPUT.type = \"submit\";\n        //TODO add class\n        INPUT.value = display.getOption('createButtonText') || \"+\";\n        INPUT.onclick = () => {\n            if (DIV.style.display === 'none') {\n                DIV.style.display = 'block';\n                INPUT.value = \"-\";\n            } else {\n                INPUT.value = display.getOption('createButtonText') || \"+\";\n                DIV.style.display = 'none';\n            }\n        };\n        const WRAPPER = display.getWRAPPER();\n        WRAPPER.appendChild(INPUT);\n        const DIV = document.createElement('DIV');\n        DIV.style.display = 'none';\n        const entityClassName = display.getEntityClassName();\n        display.xyz.ui({uri: '/' + entityClassName, display: 'create'}, DIV); // TODO encapsulate xyz\n        WRAPPER.appendChild(DIV);\n    }\n}\n\nexports.display = {\n    waitingForInput: display => {\n        const WRAPPER = display.getWRAPPER();\n        WRAPPER.innerHTML = 'Waiting for input...';\n    },\n    waitingForData: display => {\n        const WRAPPER = display.getWRAPPER();\n        WRAPPER.innerHTML = 'Waiting for data...';\n    },\n    empty: display => {\n        const WRAPPER = display.getWRAPPER();\n        WRAPPER.innerHTML = '';\n        const TABLE = document.createElement('TABLE');\n        TABLE.className = 'xyz-list';\n        WRAPPER.appendChild(TABLE);\n        addCreateButton(display);\n    },\n    first: display => {\n        if (display.getOption('showHeader') !== false) {\n            const WRAPPER = display.getWRAPPER();\n            const content = display.getContent();\n            const columns = flatten(content);\n            const TABLE = WRAPPER.firstChild;\n            const TR_header = document.createElement('TR');\n            TR_header.className = 'xyz-list-header';\n            if (display.getOption('multiSelect')) {\n                const TD_checkbox = document.createElement('TD');\n                TR_header.appendChild(TD_checkbox);\n            }\n            if (columns.constructor !== Object) {\n                const TD_header = document.createElement('TD');\n                TD_header.innerHTML = display.getEntityClassName();\n                TR_header.appendChild(TD_header);\n            } else {\n                for (let flatPropertyName in columns) {\n                    const TD_header = document.createElement('TD');\n                    TD_header.innerHTML = flatPropertyName;\n                    TR_header.appendChild(TD_header);\n                }\n            }\n            TABLE.appendChild(TR_header);\n        }\n    },\n\n    entity: display => {\n        const WRAPPER = display.getWRAPPER();\n        const content = display.getContent();\n\n        const columns = flatten(content);\n        const TR_entity = document.createElement('TR');\n        TR_entity.className = 'xyz-list-item';\n        TR_entity.entityId = display.getEntityId();\n        const entityId = display.getEntityId();\n        const entityClassName = display.getEntityClassName();\n        const uri = '/' + entityClassName+ '/' + entityId;\n\n        if (display.getOption('multiSelect')) {\n            const variableName = display.getOption('multiSelect');\n            const TD_checkbox = document.createElement('TD');\n            const INPUT_checkbox = document.createElement('INPUT');\n            INPUT_checkbox.type = \"checkbox\";\n            const selectedUris = getUrisFromVariable(display.xyz, variableName, entityClassName); // TODO encapsulate xyz\n\n            if (selectedUris.includes(uri)) {\n                INPUT_checkbox.checked = true;\n            }\n\n            INPUT_checkbox.onclick = event => {\n                const selectedUris = getUrisFromVariable(display.xyz, variableName, entityClassName); // TODO encapsulate xyz\n                if (INPUT_checkbox.checked) {\n                    if (!selectedUris.includes(uri)) {\n                        selectedUris.push(uri);\n                    }\n                } else {\n                    const index = selectedUris.indexOf(uri);\n                    if (index !== -1) {\n                        selectedUris.splice(index, 1);\n                    }\n                }\n                const entityIds = selectedUris\n                    .map(uri => uri.substr(1).split('/'))\n                    .filter(path => path[0] === entityClassName)\n                    .map(path => path[1]);\n                if (entityIds.length === 0) {\n                    select(display.xyz, variableName, undefined, undefined)// TODO encapsulate xyz\n                } else {\n                    select(display.xyz, variableName, entityClassName, entityIds.join(','))// TODO encapsulate xyz\n                }\n                event.stopPropagation();\n            };\n            TD_checkbox.appendChild(INPUT_checkbox);\n            TR_entity.appendChild(TD_checkbox);\n        }\n        if (columns.constructor !== Object) {\n            const node = columns;\n            const TD_entityContent = document.createElement('TD');\n            const TAG = node.render(display.getAction(), display.getOptions());\n            TD_entityContent.appendChild(TAG);\n            TR_entity.appendChild(TD_entityContent);\n        } else {\n            for (let flatPropertyName in columns) {\n                const TD_flatProperty = document.createElement('TD');\n                const node = columns[flatPropertyName];\n                const TAG = node.render(display.getAction(), display.getOptions());\n                TD_flatProperty.appendChild(TAG);\n                TR_entity.appendChild(TD_flatProperty);\n            }\n        }\n\n        const TABLE = WRAPPER.firstChild;\n        if (display.getOption('select')) {\n\n            if (display.xyz.getVariable(display.getOption('select')) === uri || display.getOption('default') === entityId) { // TODO encapsulate xyz\n                TR_entity.classList.add('xyz-list-selected');\n            }\n            TR_entity.onclick = () => {\n                select(display.xyz, display.getOption('select'), entityClassName, entityId); // TODO encapsulate xyz\n                for (let row of TABLE.childNodes) {\n                    if (row === TR_entity) {\n                        row.classList.add('xyz-list-selected');\n                    } else {\n                        row.classList.remove('xyz-list-selected');\n                    }\n                }\n            };\n        }\n        TABLE.appendChild(TR_entity);\n    },\n    remove: display => {\n        const WRAPPER = display.getWRAPPER();\n        const entityId = display.getEntityId();\n        const TABLE = WRAPPER.firstChild;\n        for (let TR_entity of TABLE.childNodes) {\n            if (typeof TR_entity.entityId === 'string' && (TR_entity.entityId === entityId || entityId === '*')) {\n                TABLE.removeChild(TR_entity);\n            }\n        }\n    }\n};\n\nexports.addCreateButton = addCreateButton;\nexports.flatten = flatten;\nexports.select = select;\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/displays/list.js?");

/***/ }),

/***/ "../../engine/core/displays/select.js":
/*!*******************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/displays/select.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const list = __webpack_require__(/*! ./list.js */ \"../../engine/core/displays/list.js\");\n\n/*\nTODO add radio flavor to provide radio box\n\noptions\n- select\n- flavor  dropdown|TODO radio\n- addCreateButton\n */\n\nexports.display = {\n    waitingForInput: display => {\n        display.getWRAPPER().innerHTML = 'Waiting for input...';\n    },\n    waitingForData: display => {\n        display.getWRAPPER().innerHTML = 'Waiting for data...';\n    },\n    empty: display => {\n        const WRAPPER = display.getWRAPPER();\n        WRAPPER.innerHTML = '';\n        const SELECT = document.createElement('SELECT');\n        SELECT.className = 'xyz-select';\n        SELECT.onchange = () => {\n            const selectedUri = SELECT.options[SELECT.selectedIndex].value;\n            const path = selectedUri.substr(1).split('/');\n            const [entityClassName, entityId] = path;\n            list.select(display.xyz, display.getOption('select'), entityClassName, entityId); // TODO encapsulate xyz\n        };\n        if (!display.getOption('initialValue')) {\n            const OPTION = document.createElement('OPTION');\n            OPTION.innerText = 'Select...';\n            OPTION.setAttribute('disabled', 'true');\n            SELECT.appendChild(OPTION)\n        }\n        WRAPPER.appendChild(SELECT);\n        const entityClassNameList = display.getRequestUri().substr(1).split('/')[0] || '*';\n        const fullUri = '/' + entityClassNameList;\n        list.addCreateButton(display);\n    },\n    first: display => {\n        //TODO something with wrapper?\n    },\n    entity: display => {\n        const WRAPPER = display.getWRAPPER();\n        const columns = list.flatten(display.getContent());\n        const SELECT = WRAPPER.firstChild;\n        const entityId = display.getEntityId();\n        const entityClassName = display.getEntityClassName();\n        if (SELECT.childElementCount === 0 && !display.getOption('initialValue')) { // select the first option as default\n            list.select(display.xyz, display.getOption('select'), entityClassName, entityId); //TODO encapsulate xyz\n        }\n\n        const OPTION = document.createElement('OPTION');\n        OPTION.value = '/' + entityClassName + '/' + entityId;\n        if (typeof display.getOption('select') === 'string' && display.xyz.getVariable() === display.getOption('select')) { //TODO encapsulate xyz\n            OPTION.selected = true;\n        }\n        if (display.getOption('initialValue') ===  OPTION.value) {\n            list.select(display.xyz, display.getOption('select'), entityClassName, entityId);  //TODO encapsulate xyz\n            OPTION.selected = true;\n        }\n        if (columns.constructor !== Object) {\n            const node = columns;\n            const TAG = node.render(display.getAction(), display.getOptions());\n            OPTION.appendChild(TAG);\n        } else {\n            for (let flatPropertyName in columns) {\n                const node = columns[flatPropertyName];\n                const TAG = node.render(display.getAction(), display.getOptions());\n                OPTION.appendChild(TAG);\n            }\n        }\n        SELECT.appendChild(OPTION);\n    },\n    remove: display => {\n        const WRAPPER = display.getWRAPPER();\n        const entityId = display.getEntityId();\n        const entityClassName = display.getEntityClassName();\n        const SELECT = WRAPPER.firstChild;\n        for (let OPTION of SELECT.childNodes) {\n            if ((OPTION.value === '/' + entityClassName + '/' + entityId || entityId === '*')) {\n                SELECT.removeChild(OPTION);\n            }\n        }\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/displays/select.js?");

/***/ }),

/***/ "../../engine/core/displays/timeline.js":
/*!*********************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/displays/timeline.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\noptions:\n- key property\n- label property\n- midLine (0-100) where the midline is located\n- horizontal : true|false\nTODO\n- view  left|right|bottom|top\n- year/month/day labels\n */\n\nconst list = __webpack_require__(/*! ./list.js */ \"../../engine/core/displays/list.js\");\nconst response = __webpack_require__(/*! ../../../factory/js/source/entity/response */ \"./source/entity/response.js\"); //TODO better solution\n\nfunction parseDateString(string) {\n    const parts = string.split(\"-\"); //TODO use formats.json function or a type.toNumber\n    return new Date(parseInt(parts[2], 10),\n        parseInt(parts[1], 10) - 1,\n        parseInt(parts[0], 10)).getTime();\n}\n\nfunction sortLabels(A, B) {\n    const timeA = parseDateString(A.date);\n    const timeB = parseDateString(B.date);\n    if (timeA === timeB) {\n        return 0;\n    } else {\n        return timeA < timeB ? -1 : 1;\n    }\n}\n\nfunction drawNodes(DIV, display) {\n    const horizontal = display.getOption('horizontal');\n    const left = horizontal ? 'left' : 'top';\n    const right = horizontal ? 'right' : 'bottom';\n\n    const top = horizontal ? 'top' : 'left';\n    const bottom = horizontal ? 'bottom' : 'right';\n\n    const width = horizontal ? 'width' : 'height';\n\n    const Q = Number(display.getOption('midLine') || 0);\n\n    let minTime = Infinity;\n    let maxTime = -Infinity;\n    const LABELS = [];\n    for (let NODE of DIV.childNodes) {\n        if (NODE.classList.contains('xyz-timeline-node')) {\n            const time = parseDateString(NODE.date);\n            minTime = Math.min(minTime, time);\n            maxTime = Math.max(maxTime, time);\n        } else if (NODE.classList.contains('xyz-timeline-label')) {\n            LABELS.push(NODE);\n        }\n    }\n    LABELS.sort(sortLabels);\n    for (let NODE of DIV.childNodes) {\n        if (NODE.classList.contains('xyz-timeline-node')) {\n            const time = parseDateString(NODE.date);\n            const ratio = (time - minTime) / (maxTime - minTime);\n            NODE.style[top] = Q + '%';\n            NODE.style[left] = (ratio * 100) + '%';\n        }\n    }\n\n    for (let i = 0; i < LABELS.length; ++i) {\n        const LABEL = LABELS[i];\n        const time = parseDateString(LABEL.date);\n        const ratio = (time - minTime) / (maxTime - minTime);\n\n        const sizeDIV = DIV.getBoundingClientRect()[width];\n        let rectLABEL = LABEL.getBoundingClientRect();\n        const sizeLABEL = rectLABEL[width];\n        let position = ratio * sizeDIV;\n        if (position + sizeLABEL > sizeDIV) position = sizeDIV - sizeLABEL; //ensure labels do not go out of bounds\n\n        LABEL.style[left] = position + 'px';\n        rectLABEL = LABEL.getBoundingClientRect();\n\n        let defaultTop = 40;\n        if (i > 0) { // ensure labels do not overlap with previous\n            const prevRectLABEL = LABELS[i - 1].getBoundingClientRect();\n            if (prevRectLABEL[right] > rectLABEL[left]) {\n                defaultTop = prevRectLABEL[bottom] + 20;\n            }\n        }\n\n        if (Q === 100) {\n            LABEL.style[bottom] = `${defaultTop}px`;\n            LABEL.style[top] = null;\n        } else if (i % 2 && Q === 50) {\n            LABEL.style[bottom] = `calc(${Q}% + ${defaultTop}px)`;\n            LABEL.style[top] = null;\n        } else {\n            LABEL.style[top] = `calc(${Q}% + ${defaultTop}px)`;\n            LABEL.style[bottom] = null;\n        }\n    }\n\n    //DIV.offsetHeight;\n    const rDIV = DIV.getBoundingClientRect();\n    let i = 0;\n    for (let CONNECTOR of DIV.childNodes) {\n        if (CONNECTOR.classList.contains('xyz-timeline-connector')) {\n            const r1 = CONNECTOR.NODE.getBoundingClientRect();\n            const r2 = CONNECTOR.LABEL.getBoundingClientRect();\n            const x1 = CONNECTOR.LABEL.style.left ? r1.left : r1.right;\n            const y1 = r1.top;\n\n            const x2 = CONNECTOR.LABEL.style.left ? r2.left : r2.right;\n            const y2 = r2.top;\n\n            const d = Math.hypot(x1 - x2, y1 - y2);\n            const angle = Math.atan2(y1 - y2, x1 - x2) / Math.PI * 180;\n\n            CONNECTOR.style.transformOrigin = 'center left';\n            CONNECTOR.style.transform = `rotate(${(180 + angle)}deg)`;\n            CONNECTOR.style.width = d + 'px';\n\n            CONNECTOR.style.left = (r1.left - rDIV.left + 5) + 'px';\n            CONNECTOR.style.top = (r1.top - rDIV.top + 3) + 'px';\n\n            ++i;\n        }\n    }\n}\n\nexports.display = {\n    waitingForInput: display => {\n        display.getWRAPPER().innerHTML = 'Waiting for input...';\n    },\n    waitingForData: display => {\n        display.getWRAPPER().innerHTML = 'Waiting for data...';\n    },\n    empty: display => {\n        display.getWRAPPER().innerHTML = 'No items to display.';\n    },\n    first: display => {\n        const horizontal = display.getOption('horizontal');\n        const Q = (display.getOption('midLine') || '0') + '%';\n        const WRAPPER = display.getWRAPPER();\n        WRAPPER.innerHTML = '';\n        const DIV = document.createElement('DIV');\n        DIV.className = 'xyz-timeline-wrapper';\n        const DIV_line = document.createElement('DIV');\n        DIV_line.className = 'xyz-timeline-line';\n        if (horizontal) {\n            DIV_line.style.top = Q;\n            DIV_line.style.width = '100%';\n            DIV_line.style.height = '2px';\n        } else {\n            DIV_line.style.left = Q;\n            DIV_line.style.width = '2px';\n            DIV_line.style.height = '100%';\n        }\n\n        DIV.appendChild(DIV_line);\n        WRAPPER.appendChild(DIV);\n    },\n    entity: display => {\n        const content = display.getContent();\n        const key = display.getOption('key') || 'date'; // TODO\n        const date = content.getContent()[key];\n\n        const labelProperty = display.getOption('label') || 'title'; //TOOD\n        const label = content.getContent()[labelProperty];\n        const entityId = display.getEntityId();\n        const entityClassName = display.getEntityClassName();\n        const uri = '/' + entityClassName + '/' + entityId;\n\n        const WRAPPER = display.getWRAPPER();\n        const DIV = WRAPPER.firstChild;\n        const NODE = document.createElement('DIV');\n        NODE.className = 'xyz-timeline-node';\n        NODE.entityId = entityId;\n        NODE.date = date;\n        //NODE.innerHTML  = '  hello';\n        DIV.appendChild(NODE);\n\n        const LABEL = document.createElement('DIV');\n        LABEL.classList.add('xyz-timeline-label');\n        if (display.xyz.getVariable(display.getOption('select')) === uri || display.getOption('default') === entityId) { // TODO encapsulate xyz\n            LABEL.classList.add('xyz-list-selected');\n        }\n\n        LABEL.entityId = entityId;\n        LABEL.innerHTML = `<SPAN style=\"font-size:0.5em;\">${date}</SPAN><br/>${label}`;\n        LABEL.date = date;\n\n        LABEL.onclick = () => {\n            list.select(display.xyz, display.getOption('select'), entityClassName, entityId);\n            for (let NODE of DIV.childNodes) {\n                if (NODE.classList.contains('xyz-timeline-label') ){\n                    NODE.classList[NODE===LABEL?'add':'remove']('xyz-list-selected')\n                }\n            }\n        };\n        DIV.appendChild(LABEL);\n\n        const CONNECTOR = document.createElement('DIV');\n        CONNECTOR.className = 'xyz-timeline-connector';\n        CONNECTOR.entityId = display.getEntityId();\n        CONNECTOR.LABEL = LABEL;\n        CONNECTOR.NODE = NODE;\n        DIV.appendChild(CONNECTOR);\n        //TODO add a listener for changes on this node\n\n        drawNodes(DIV, display);\n    },\n    remove: display => {\n        const WRAPPER = display.getWRAPPER();\n        const entityId = display.getEntityId();\n        const DIV = WRAPPER.firstChild;\n        for (let NODE of DIV.childNodes) {\n            if (typeof NODE.entityId === 'string' && (NODE.entityId === entityId || entityId === '*')) {\n                DIV.removeChild(NODE);\n            }\n        }\n        drawNodes(DIV, display);\n    }\n};\n\n\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/displays/timeline.js?");

/***/ }),

/***/ "../../engine/core/types/array/array.js":
/*!*********************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/array/array.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const object = __webpack_require__(/*! ../object/object */ \"../../engine/core/types/object/object.js\");\n\nfunction makeArray(content) {\n    if (content === null) {\n        return [];\n    } else if (content instanceof Array) {\n        return content;\n    } else if (typeof content === 'object') { // if data is an object, reshape to array\n        const tmp = [];\n        for (let key in content) {\n            tmp[key] = content[key];\n        }\n        return tmp;\n    } else {\n        //TODO problem\n        return [];\n    }\n}\n\nexports.actions = {\n    edit: function (item) {\n        // TODO create ui for adding/removing elements\n        // TODO create drop ui to drag elements to\n        const SPAN = document.createElement('SPAN');\n        const content = makeArray(item.getContent());\n\n        const subSettings = item.getSetting('subType');\n        const subOptions = {showLabels: false, display: item.getOption('display')};\n        const DIV_CREATE = document.createElement('DIV');\n        const INPUT_create = document.createElement('INPUT');\n        INPUT_create.type = \"submit\";\n        //TODO add class\n        INPUT_create.validUris = {};\n        INPUT_create.value = \"Add\";\n        const data = {};\n\n        const TRs = item.renderCreator(subOptions, item.getUri(), subSettings, [0], data, INPUT_create);\n        const TABLE_create = document.createElement('TABLE');\n        TRs.forEach(TR => TABLE_create.appendChild(TR));\n\n        DIV_CREATE.appendChild(TABLE_create);\n        DIV_CREATE.appendChild(INPUT_create);\n        SPAN.appendChild(DIV_CREATE);\n        let length = content.length;\n        const rows = [];\n        const addRow = (key, subContent) => {\n            ++length;\n            const TAG = item.renderSubElement('edit', [key], item.getStatus(), subContent, subSettings, subOptions);\n            TAG.style.display = 'inline-block';\n            const DIV_sub = document.createElement('DIV');\n            const INPUT_remove = document.createElement('INPUT');\n            INPUT_remove.type = 'submit';\n            INPUT_remove.onclick = () => {\n                item.delete([key]);\n            };\n            INPUT_remove.value = 'x';\n            DIV_sub.appendChild(INPUT_remove);\n            DIV_sub.appendChild(TAG);\n            rows[key] = DIV_sub;\n            SPAN.insertBefore(DIV_sub, DIV_CREATE);\n        };\n        const deleteRow = key => {\n            const TAG_row = rows[key];\n            rows.splice(key, 1);\n            SPAN.removeChild(TAG_row);\n        };\n        INPUT_create.onclick = () => {\n            item.patch(data[0], [length]);\n        };\n\n        for (let key in content) {\n            const subContent = content[key];\n            addRow(key, subContent);\n        }\n\n        object.setupOnChange(item, rows, addRow, deleteRow);\n        return SPAN;\n    },\n    view: function (item) {\n        const SPAN = document.createElement('SPAN');\n        const subSettings = item.getSetting('subType');\n        const subOptions = item.getOptions(); //TODO\n        const content = makeArray(item.getContent());\n        const rows = [];\n        const addRow = (key, subContent) => {\n            const TAG = item.renderSubElement('view', [key], item.getStatus(), subContent, subSettings, subOptions);\n            rows[key] = TAG;\n            SPAN.appendChild(TAG);\n        };\n        const deleteRow = key => {\n            const TAG_row = rows[key];\n            rows.splice(key, 1);\n            SPAN.removeChild(TAG_row);\n        };\n        for (let key in content) {\n            const subContent = content[key];\n            addRow(key, subContent);\n        }\n        object.setupOnChange(item, rows, addRow, deleteRow);\n        return SPAN;\n    },\n    validateContent: function (item) {\n        const content = item.getContent();\n        if (content === null || typeof content !== 'object') return false;\n\n        const subSettings = item.getSetting('subType');\n        for (let key in content) {\n            const subContent = content[key];\n            if (!item.validateContent(subContent, subSettings)) return false;\n        }\n        return true;\n    },\n    validateSubPropertyPath: function (subPropertyPath, settings, validateSubPropertyPath) {\n        const subType = settings.subType.type || 'string';\n        return subPropertyPath instanceof Array &&\n            !isNaN(subPropertyPath[0]) &&\n            Number(subPropertyPath) === Math.floor(subPropertyPath) &&\n            validateSubPropertyPath(subType, subPropertyPath.slice(1));\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/array/array.js?");

/***/ }),

/***/ "../../engine/core/types/array/array.json":
/*!***********************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/array/array.json ***!
  \***********************************************************************************************/
/*! exports provided: default, subType */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"default\\\":{\\\"type\\\":\\\"array\\\",\\\"default\\\":[]},\\\"subType\\\":{\\\"type\\\":\\\"type\\\"}}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/array/array.json?");

/***/ }),

/***/ "../../engine/core/types/bool/bool.js":
/*!*******************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/bool/bool.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        //TODO radio flavor to distinguish two options\n        const INPUT = document.createElement('INPUT');\n        INPUT.type='checkbox';\n        INPUT.checked=!!item.getContent();\n        INPUT.onchange = () => {\n            item.patch(INPUT.checked);\n        };\n        item.onChange(node => {\n            //TODO use status\n            INPUT.checked =  !!node.getContent();\n        });\n        return INPUT;\n    },\n    view: function (item) {\n        const SPAN = document.createElement('SPAN');\n        //TODO 404 etc status outputs (refactor from string)\n        //TODO use settings to get yes|no label\n        SPAN.innerText = item.getContent() ? 'yes':'no';\n        item.onChange(node => {\n            //TODO use status\n            SPAN.innerText = node.getContent() ? 'yes':'no';\n        });\n        return SPAN;\n    },\n    validateContent: function (item) {\n        return typeof item.getContent() === 'boolean';\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/bool/bool.js?");

/***/ }),

/***/ "../../engine/core/types/bool/bool.json":
/*!*********************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/bool/bool.json ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"default\\\":{\\\"type\\\":\\\"bool\\\",\\\"default\\\":false}}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/bool/bool.json?");

/***/ }),

/***/ "../../engine/core/types/date/date.js":
/*!*******************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/date/date.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//https://www.php.net/manual/en/function.date.php\nconst formats = __webpack_require__(/*! ./formats.json */ \"../../engine/core/types/date/formats.json\");\n\nexports.actions = {\n    edit: function (item) {\n        const format = item.getSetting('format');\n\n\n        //TODO const DIV = document.createElement('DIV');\n        let placeholder = '';\n        for (let index = 0; index < format.length; ++index) {\n            const c = format.charAt(index);\n            if (formats.hasOwnProperty(c)) {\n                const format = formats[c];\n                placeholder += format.settings.default;\n                /* const subStatus = 200;//TODO\n                 const subContent = null;//TODO\n                 const data = {date: {[index]:null}};\n                 const TAG = item.renderSubElement(\n                     'create',\n                     [index]\n                     , subStatus,\n                     subContent,\n                     format.settings,\n                     {label: format.label, data}\n                 );\n                 DIV.appendChild(TAG);*/\n            } else {\n                placeholder += c;\n            }\n        }\n\n        const INPUT = document.createElement('INPUT');\n        INPUT.placeholder = placeholder;\n        if (item.patch) {\n            INPUT.oninput = () => {\n                item.patch(INPUT.value)\n            };\n        }\n        const onChangeHandler = node => {\n            //TODO use status\n            const content = node.getContent();\n            if (INPUT !== document.activeElement) { // we don't want to interrupt typing\n                INPUT.value = content;\n            }\n        };\n        item.onChange(onChangeHandler);\n        onChangeHandler(item);\n\n        return INPUT;\n    },\n    view: function (item) {\n        //TODO use displayFormat to render it\n        const SPAN = document.createElement('SPAN');\n        SPAN.innerText = item.getContent();\n        item.onChange(item => {\n            SPAN.innerText = item.getContent();\n        });\n        return SPAN;\n    },\n    validateContent: function (item) {\n        const format = item.getSetting('format');\n        const content = item.getContent();\n        if (typeof content !== 'string') return false; //TODO maybe numbers for single date things?\n\n        let contentIndex = 0;\n        for (let formatIndex = 0; formatIndex < format.length; ++formatIndex) {\n            const format = item.getSetting('format');\n            const c = format.charAt(formatIndex);\n            if (formats.hasOwnProperty(c)) {\n                const subSettings = formats[c].settings;\n                const subTypeName = subSettings.type || 'string';\n                let length;\n                if (subTypeName === 'number') {\n                    const leadingZeroes = !!subSettings.leadingZeroes;\n                    if (leadingZeroes) {\n                        const max = subSettings.max || 0;\n                        length = Math.ceil(Math.log10(max));\n                    } else {\n                        length = content.substring(contentIndex).search(/[^0-9]/);\n                        if (length === -1) length = content.length - contentIndex\n                    }\n                }\n                const subContent = content.substr(contentIndex, length);\n                const subValid = item.validateContent(subContent, subSettings);\n                if (!subValid) return false;\n                contentIndex += length;\n            } else if (c !== content.charAt(contentIndex)) {\n                return false;\n            } else {\n                ++contentIndex;\n            }\n        }\n        return true;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/date/date.js?");

/***/ }),

/***/ "../../engine/core/types/date/date.json":
/*!*********************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/date/date.json ***!
  \*********************************************************************************************/
/*! exports provided: default, format */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"default\\\":{\\\"type\\\":\\\"data\\\"},\\\"format\\\":{\\\"type\\\":\\\"string\\\"}}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/date/date.json?");

/***/ }),

/***/ "../../engine/core/types/date/formats.json":
/*!************************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/date/formats.json ***!
  \************************************************************************************************/
/*! exports provided: d, m, Y, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"d\\\":{\\\"label\\\":\\\"Day\\\",\\\"info\\\":\\\"Day of the month, 2 digits with leading zeros\\\",\\\"settings\\\":{\\\"type\\\":\\\"number\\\",\\\"min\\\":1,\\\"max\\\":31,\\\"default\\\":\\\"01\\\"}},\\\"m\\\":{\\\"label\\\":\\\"Month\\\",\\\"info\\\":\\\"Numeric representation of a month, with leading zeros\\\",\\\"settings\\\":{\\\"type\\\":\\\"number\\\",\\\"min\\\":1,\\\"max\\\":12,\\\"default\\\":\\\"01\\\",\\\"leadingZeroes\\\":true}},\\\"Y\\\":{\\\"label\\\":\\\"Year\\\",\\\"info\\\":\\\"A full numeric representation of a year, 4 digits\\\",\\\"settings\\\":{\\\"type\\\":\\\"number\\\",\\\"min\\\":0,\\\"max\\\":9999,\\\"default\\\":2020,\\\"leadingZeroes\\\":true}}}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/date/formats.json?");

/***/ }),

/***/ "../../engine/core/types/enum/enum.js":
/*!*******************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/enum/enum.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        const SELECT = document.createElement('SELECT');\n\n        SELECT.onchange = () => {\n            const content = SELECT.options[SELECT.selectedIndex].value;\n            item.patch(content);\n        };\n\n        const choices = item.getSetting('choices') instanceof Array ? item.getSetting('choices') : [];\n\n        if (!item.getSetting('default') && item.getContent() === null) {\n            const OPTION = document.createElement('OPTION');\n            OPTION.innerText = 'Select...';\n            OPTION.setAttribute('disabled' ,'true');\n            OPTION.selected = true;\n            SELECT.appendChild(OPTION);\n        }\n\n        const subSettings = item.getSetting('subType') || {};\n        const content = item.getContent();\n        for (let choice of choices) {\n            const OPTION = document.createElement('OPTION');\n            if (choice === content) {\n                OPTION.selected = true;\n            }\n            OPTION.innerText = choice; //TODO render choice content\n            //OPTION.value = choice;\n            // item.renderSubElement('view', ??, item.getStatus(), choice, subSettings, options);\n            SELECT.appendChild(OPTION);\n        }\n        item.onChange(node => {\n            //TODO use status\n            const content = node.getContent();\n            for (let id in SELECT.options) {\n                const OPTION = SELECT.options[id];\n                if (OPTION.innerText === content) {\n                    OPTION.selected = true;\n                }\n            }\n        });\n        return SELECT;\n    },\n    view: function (item) {\n        const subSettings = item.getSetting('subType') || {};\n        // not item.onChange required this is handled by this:\n        const TAG = item.renderSubElement('view', [], item.getStatus(), item.getContent(), subSettings, item.getOptions());\n        return TAG;\n    },\n    validateContent: function (item) {\n        const choices = item.getSetting('choices');\n        if (!choices instanceof Array) {\n            return false;\n        }\n        return choices.indexOf(item.getContent()) !== -1;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/enum/enum.js?");

/***/ }),

/***/ "../../engine/core/types/enum/enum.json":
/*!*********************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/enum/enum.json ***!
  \*********************************************************************************************/
/*! exports provided: default, choice, subType */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"default\\\":{\\\"type\\\":\\\"enum\\\"},\\\"choice\\\":{\\\"type\\\":\\\"array\\\",\\\"TODO\\\":\\\"TODO\\\"},\\\"subType\\\":{}}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/enum/enum.json?");

/***/ }),

/***/ "../../engine/core/types/file/file.js":
/*!*******************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/file/file.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const viewers = {\n    txt: __webpack_require__(/*! ./viewers/text */ \"../../engine/core/types/file/viewers/text.js\"),\n    jpg: __webpack_require__(/*! ./viewers/image */ \"../../engine/core/types/file/viewers/image.js\"),\n    jpeg: __webpack_require__(/*! ./viewers/image */ \"../../engine/core/types/file/viewers/image.js\"),\n    png: __webpack_require__(/*! ./viewers/image */ \"../../engine/core/types/file/viewers/image.js\"),\n    bmp: __webpack_require__(/*! ./viewers/image */ \"../../engine/core/types/file/viewers/image.js\"),\n    gif: __webpack_require__(/*! ./viewers/image */ \"../../engine/core/types/file/viewers/image.js\"),\n    pdf: __webpack_require__(/*! ./viewers/pdf */ \"../../engine/core/types/file/viewers/pdf.js\"),\n\n};\n\nconst encodeContent = (data, item, file) => evt => {\n    const mimeTypeAndBase64String = evt.target.result;\n    const [mimeType, base64String] = mimeTypeAndBase64String\n        .substr(5) // 'data:${mimeType};base64,${base64String}' -> '${mimeType};base64,${base64String}'\n        .split(';base64,'); // '${mimeType};base64,${base64String}' -> ['${mimeType}','${base64String}']\n\n    if (item.getSetting('signature').content.binary) {\n        data['content'] = {\n            encoding: 'base64',\n            content: base64String\n        };\n    } else {\n        data['content'] = atob(base64String);\n    }\n\n    data['mime'] = mimeType;\n    const extension = item.getSetting('signature').id.connector.extension;\n    let key;\n    //TODO or extension is mixed extensions for example \"json|xml\"\n    if (extension && extension !== '*') {\n        key = file.name.split('.').slice(0, -1).join('.');\n    } else {\n        key = file.name;\n    }\n    data['id'] = key;\n    item.patch(data);\n};\n\nexports.actions = {\n    edit: function (item) {\n        const prepareContent = (files) => {\n            //TODO add filetype validation (using accept to catch client side injections)\n            const data = {};\n            if (item.getSetting('multiple')) {\n                //TODO content = '[' + files.map(file => file.text()).join(',') + ']';\n            } else if (files.length === 0) {\n                //TODO\n            } else {\n                const reader = new FileReader();\n                reader.onload = encodeContent(data, item, files[0]);\n                reader.onerror = evt => {\n                    //TODO\n                };\n                reader.readAsDataURL(files[0]);\n                const url = window.URL.createObjectURL(files[0]);\n            }\n        };\n\n        // TODO add id from options (for label for)\n        const INPUT = document.createElement('INPUT');\n        INPUT.type = 'file';\n        const content = item.getContent();\n        if (content) {\n            INPUT.value = content;\n        }\n        if (item.patch) {\n            INPUT.addEventListener('change', event => {\n                prepareContent(event.target.files, item.patch);\n            });\n        }\n        INPUT.multiple = item.getSetting('multiple');\n        INPUT.accept = item.getSetting('accept');\n\n        return INPUT;\n    },\n    view: function (item) {\n        //TODO use a file viewer:   https://viewerjs.org/\n        const DIV_container = document.createElement('DIV');\n        DIV_container.classList.add('xyz-file-container');\n\n        const onChangeHandler = node => {\n            DIV_container.innerHTML = '';\n            const content = item.getContent();\n            //TODO use mime\n            const extension = content.extension;\n            const fallbackExtension = viewers.hasOwnProperty(extension) && typeof viewers[extension].view === 'function'\n                ? extension : 'txt';\n            const DIV_fileContent = viewers[fallbackExtension].view(item);\n            DIV_container.appendChild(DIV_fileContent);\n        };\n        item.onChange(onChangeHandler);\n        onChangeHandler(item);\n        //TODO onChange\n        return DIV_container;\n    },\n    validateContent: function (item) {\n        //TODO implement client side validation\n        //todo mime/accept\n        //todo max size\n        return true;\n    }\n};\n\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/file/file.js?");

/***/ }),

/***/ "../../engine/core/types/file/file.json":
/*!*********************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/file/file.json ***!
  \*********************************************************************************************/
/*! exports provided: accepts, TODO, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"accepts\\\":{\\\"type\\\":\\\"array\\\",\\\"TODO\\\":\\\"TODO\\\"},\\\"TODO\\\":{}}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/file/file.json?");

/***/ }),

/***/ "../../engine/core/types/file/viewers/image.js":
/*!****************************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/file/viewers/image.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function str2ab(str) {\n    var buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n    var bufView = new Uint16Array(buf);\n    for (var i = 0, strLen = str.length; i < strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return buf;\n}\n\nexports.view = function (item) {\n    const content = item.getContent();\n    const fileContent = content.content;\n    const IMG = document.createElement('IMG');\n    IMG.classList.add('xyz-file-image');\n    //TODO check encoding\n    const base64String = fileContent.content;\n    //TODO get mime\n    IMG.src = 'data:image/jpeg;base64,' + base64String;\n    return IMG;\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/file/viewers/image.js?");

/***/ }),

/***/ "../../engine/core/types/file/viewers/pdf.js":
/*!**************************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/file/viewers/pdf.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// For reference:  https://github.com/mozilla/pdf.js\n\nlet externalScriptIsLoaded = false;\n\nfunction loadExternalScript(callback) {\n    if (externalScriptIsLoaded) {\n        callback();\n    }\n    const SCRIPT = document.createElement('script');\n    SCRIPT.setAttribute(\"type\", \"text/javascript\");\n    SCRIPT.setAttribute(\"src\", '//mozilla.github.io/pdf.js/build/pdf.js');\n\n    SCRIPT.onreadystatechange = () => {\n        /* TODO\n\n            if (!done) {\n                state = scr.readyState;\n                if (state === \"complete\") {\n                    handleLoad();\n                }\n            }\n         */\n    };\n    SCRIPT.onerror = () => {\n        //TODO\n    };\n\n    SCRIPT.onload = () => {\n        externalScriptIsLoaded = true;\n        // The workerSrc property shall be specified.\n        pdfjsLib.GlobalWorkerOptions.workerSrc = '//mozilla.github.io/pdf.js/build/pdf.worker.js';\n        callback();\n    };\n    document.head.appendChild(SCRIPT);\n}\n\nexports.view = function (item) {\n    const content = item.getContent();\n    const fileContent = content.content;\n\n    const CANVAS = document.createElement('CANVAS');\n    //TODO check if fileContent.encoding === 'base64', else transform\n    const pdfData = atob(fileContent.content);\n\n    loadExternalScript(() => {\n        // Using DocumentInitParameters object to load binary data.\n        const loadingTask = pdfjsLib.getDocument({data: pdfData});\n        loadingTask.promise.then(pdf => {\n            // Fetch the first page\n            const pageNumber = 1;\n            pdf.getPage(pageNumber).then(page => {\n                const scale = 1.5;\n                const viewport = page.getViewport({scale: scale});\n\n                // Prepare canvas using PDF page dimensions\n                const context = CANVAS.getContext('2d');\n                CANVAS.height = viewport.height;\n                CANVAS.width = viewport.width;\n\n                // Render PDF page into canvas context\n                const renderContext = {\n                    canvasContext: context,\n                    viewport: viewport\n                };\n                const renderTask = page.render(renderContext);\n                renderTask.promise.then(() => {\n                    // TODO console.log('Page rendered');\n                });\n            });\n        }, function (reason) {\n            // PDF loading error TODO handle with css class\n            console.error(reason);\n        });\n    });\n    return CANVAS;\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/file/viewers/pdf.js?");

/***/ }),

/***/ "../../engine/core/types/file/viewers/text.js":
/*!***************************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/file/viewers/text.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const recodeString = __webpack_require__(/*! ../../string/string */ \"../../engine/core/types/string/string.js\").recodeString;\n\nexports.view = function (item) {\n    const content = item.getContent();\n    const fileContent = content.content;\n    const stringContent = recodeString(fileContent, 'utf8');\n    const DIV_flat = document.createElement('DIV');\n    DIV_flat.classList.add('xyz-file-flat');\n    DIV_flat.innerHTML = stringContent;\n    return DIV_flat;\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/file/viewers/text.js?");

/***/ }),

/***/ "../../engine/core/types/id/id.js":
/*!***************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/id/id.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        //TODO make visible with options.something\n        const content = item.getContent();\n        if (item.getSetting('autoIncrement') !== true) {\n            const INPUT = document.createElement('INPUT');\n            if (content) {\n                INPUT.value = content;\n            }\n            if (item.patch) {\n                INPUT.oninput = () => {\n                    item.patch(INPUT.value)\n                };\n            }\n            item.onChange(node => {\n                //TODO use status\n                if (INPUT !== document.activeElement) { // we don't want to interupt typing\n                    INPUT.value = node.getContent();\n                }\n            });\n            return INPUT;\n        }else {\n            const SPAN = document.createElement('SPAN');\n            SPAN.innerText = content;\n            item.onChange(node => {\n                SPAN.innerText = node.getContent();\n            });\n            return SPAN;\n        }\n    },\n    view: function (item) {\n        //TODO make visible with options.something\n        const SPAN = document.createElement('SPAN');\n        SPAN.innerText = item.getContent();\n        item.onChange(item => {\n            SPAN.innerText = item.getContent();\n        });\n        return SPAN;\n    },\n    validateContent: function (item) {\n        //TODO should be 0 or null always?\n        return true;//TODO\n    },\n    getIdFromContent: function(content){\n        return content;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/id/id.js?");

/***/ }),

/***/ "../../engine/core/types/id/id.json":
/*!*****************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/id/id.json ***!
  \*****************************************************************************************/
/*! exports provided: default, autoIncrement */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"default\\\":{\\\"type\\\":\\\"id\\\"},\\\"autoIncrement\\\":{\\\"type\\\":\\\"bool\\\"}}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/id/id.json?");

/***/ }),

/***/ "../../engine/core/types/json/json.js":
/*!*******************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/json/json.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        const TEXTAREA = document.createElement('TEXTAREA');\n        TEXTAREA.value = item.getContent();\n        TEXTAREA.oninput = () => {\n            let content;\n            try {\n                content = JSON.parse(TEXTAREA.value);\n            } catch (e) {\n                //TODO\n                return;\n            }\n            item.patch(content);\n        };\n        item.onChange(item => {\n            if (TEXTAREA !== document.activeElement) {\n                TEXTAREA.value = item.getContent();\n            }\n        });\n        return TEXTAREA;\n    },\n    view: function (item) {\n        const DIV = document.createElement('DIV');\n        DIV.innerText = JSON.stringify(item.getContent());\n        item.onChange(item => {\n            DIV.innerText = JSON.stringify(item.getContent());\n        });\n        return DIV;\n    },\n    validateContent: function (item) {\n        try {\n            JSON.parse(item.getContent());\n            return true;\n        } catch (e) {\n            return false;\n        }\n    },\n    validateSubPropertyPath: function (subPropertyPath, settings) {\n        return subPropertyPath instanceof Array;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/json/json.js?");

/***/ }),

/***/ "../../engine/core/types/json/json.json":
/*!*********************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/json/json.json ***!
  \*********************************************************************************************/
/*! exports provided: default, schema */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"default\\\":{\\\"type\\\":\\\"json\\\"},\\\"schema\\\":\\\"TODO\\\"}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/json/json.json?");

/***/ }),

/***/ "../../engine/core/types/login/login.js":
/*!*********************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/login/login.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        if (item.getOption('display') !== 'create') {\n            const SPAN = document.createElement('SPAN');\n            SPAN.innerText = 'Cannot edit login';\n            return SPAN;\n        }\n\n        //TODO notify if caps lock is on\n        const TABLE = document.createElement('TABLE');\n\n        const TR_username = document.createElement('TR');\n        const TD_usernameLabel = document.createElement('TD');\n        const TD_usernameInput = document.createElement('TD');\n        const INPUT_username = document.createElement('INPUT');\n        TD_usernameLabel.innerText = 'Username';\n        TD_usernameInput.appendChild(INPUT_username);\n        TR_username.appendChild(TD_usernameLabel);\n        TR_username.appendChild(TD_usernameInput);\n        TABLE.appendChild(TR_username);\n\n        const TR_password = document.createElement('TR');\n        const TD_passwordLabel = document.createElement('TD');\n        const TD_passwordInput = document.createElement('TD');\n        const INPUT_password = document.createElement('INPUT');\n        INPUT_password.type = 'password';\n        TD_passwordLabel.innerText = 'Password';\n        TD_passwordInput.appendChild(INPUT_password);\n        TR_password.appendChild(TD_passwordLabel);\n        TR_password.appendChild(TD_passwordInput);\n        TABLE.appendChild(TR_password);\n\n        const onChangeHandler = () => {\n            item.patch({\n                username: INPUT_username.value,\n                password: INPUT_password.value\n            });\n        };\n        INPUT_username.oninput = onChangeHandler;\n        INPUT_password.oninput = onChangeHandler;\n        return TABLE;\n    },\n    view: function (item) {\n        const SPAN = document.createElement('SPAN');\n        const content = item.getContent();\n        if(typeof content === 'object' && content !== null ) {\n            SPAN.innerText = content.username;\n        }else{\n            SPAN.innerText = 'ERROR';//TODO\n        }\n        return SPAN;\n    },\n    validateContent: function (item) {\n        const content = item.getContent();\n        if (typeof content !== 'object' || content === null) return false;\n        if (typeof content.password !== 'string') return false;\n        if (typeof content.username !== 'string') return false;\n        if (content.username === typeof content.password) return false;\n        return true; // TODO min/max length, allow chars, regex\n    },\n    getIdFromContent: function (content) {\n        return content.username;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/login/login.js?");

/***/ }),

/***/ "../../engine/core/types/login/login.json":
/*!***********************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/login/login.json ***!
  \***********************************************************************************************/
/*! exports provided: minLength, maxLength, allowedChars, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"minLength\\\":{\\\"type\\\":\\\"number\\\",\\\"min\\\":0},\\\"maxLength\\\":{\\\"type\\\":\\\"number\\\",\\\"min\\\":0},\\\"allowedChars\\\":{\\\"type\\\":\\\"string\\\"}}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/login/login.json?");

/***/ }),

/***/ "../../engine/core/types/number/number.js":
/*!***********************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/number/number.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        const INPUT = document.createElement('INPUT');\n        INPUT.type = 'number';\n        // TODO add id from options (for label for)\n        INPUT.value = item.getContent();\n        INPUT.step = item.getSetting('step');\n        INPUT.min = item.getSetting('min');\n        INPUT.max = item.getSetting('max');\n\n        if (item.patch) {\n            INPUT.oninput = () => {\n                item.patch(INPUT.value)\n            };\n        }\n        const onChangeHandler = node => {\n            const content = node.getContent();\n            //TODO use status\n            if (INPUT !== document.activeElement) { // we don't want to interupt typing\n                INPUT.value = content;\n            }\n        };\n        item.onChange(onChangeHandler);\n        onChangeHandler(item);\n        return INPUT;\n    },\n    view: function (item) {\n        const SPAN = document.createElement('SPAN');\n        switch (item.getStatus()) {\n            case 500 :\n                SPAN.innerText = 'Server error';\n                break;\n            case 400 :\n                SPAN.innerText = 'Bad request';\n                break;\n            case 403 :\n                SPAN.innerText = 'Forbidden';\n                break;\n            case 404 :\n                SPAN.innerText = 'Not found';\n                break;\n            default:\n                SPAN.innerText = item.getContent();\n                break;\n        }\n        item.onChange(node => {\n            //TODO use status stuff from above\n            SPAN.innerText = node.getContent();\n        });\n        return SPAN;\n    },\n    validateContent: function (item) {\n        //TODO nr of decimals\n        const content = Number(item.getContent());\n        if (isNaN(content)) return false;\n        if (item.hasSetting('max') && content > item.getSetting('max')) return false;\n        if (item.hasSetting('min') && content < item.getSetting('min')) return false;\n        if (item.hasSetting('step') && content / item.getSetting('step') !== Math.floor(content / item.getSetting('step'))) return false;\n        return true;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/number/number.js?");

/***/ }),

/***/ "../../engine/core/types/number/number.json":
/*!*************************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/number/number.json ***!
  \*************************************************************************************************/
/*! exports provided: default, min, max, step, leadingZeroes */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"default\\\":{\\\"type\\\":\\\"number\\\",\\\"default\\\":0},\\\"min\\\":{\\\"type\\\":\\\"number\\\"},\\\"max\\\":{\\\"type\\\":\\\"number\\\"},\\\"step\\\":{\\\"type\\\":\\\"number\\\"},\\\"leadingZeroes\\\":{\\\"type\\\":\\\"bool\\\",\\\"default\\\":false}}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/number/number.json?");

/***/ }),

/***/ "../../engine/core/types/object/object.js":
/*!***********************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/object/object.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const setupOnChange = (item, TAGs_row, addRow, deleteRow) => item.onChange(item => {\n    const content = item.getContent();\n    //TODO use   const status = item.getStatus();\n    if (item.getMethod() === 'DELETE') {\n        for (let key in content) {\n            if (TAGs_row instanceof Array && key >= 0 && key < TAGs_row.length) {\n            } else if (!(TAGs_row instanceof Array) && TAGs_row.hasOwnProperty(key)) {\n\n            }\n            deleteRow(key);\n        }\n    } else if (item.getMethod() === 'PUT' || item.getMethod() === 'POST' || item.getMethod() === 'PATCH') {\n        for (let key in content) {\n            if ((TAGs_row instanceof Array && key >= TAGs_row.length) || (!(TAGs_row instanceof Array) && !TAGs_row.hasOwnProperty(key))) {\n                const subContent = content[key];\n                addRow(key, subContent);\n            }\n        }\n    }\n});\n\nexports.setupOnChange = setupOnChange;\n\nexports.actions = {\n    edit: function (item) {\n        // TODO create ui for adding/removing elements\n        // TODO create drop ui to drag elements to\n        //TODO check if content is array\n        const content = item.getContent();\n        const subSettings = item.getSetting('subType');\n        const subOptions = {showLabels: false, display: item.getOption('display')};\n        const TABLE = document.createElement('TABLE');\n        const TR_add = document.createElement('TR');\n        const TD_key = document.createElement('TD');\n        const TD_value = document.createElement('TD');\n        const INPUT_key = document.createElement('INPUT');\n\n        const INPUT_create = document.createElement('INPUT');\n        INPUT_create.type = \"submit\";\n        //TODO add class\n        INPUT_create.validUris = {};\n        INPUT_create.value = \"Add\";\n        const data = {};\n        const TRs = item.renderCreator(subOptions, item.getUri(), subSettings, ['new'], data, INPUT_create);\n        const TABLE_create = document.createElement('TABLE');\n        TRs.forEach(TR => TABLE_create.appendChild(TR));\n        INPUT_create.onclick = () => {\n            const key = INPUT_key.value;\n//            addTR(key, data['new']);\n            item.patch(data['new'], [key]);\n        };\n\n        TD_key.appendChild(INPUT_key);\n        TD_value.appendChild(TABLE_create);\n        TD_value.appendChild(INPUT_create);\n\n        TR_add.appendChild(TD_key);\n        TR_add.appendChild(TD_value);\n        TABLE.appendChild(TR_add);\n\n        const rows = {};\n        const addTR = (key, subContent) => {\n\n            const TR = document.createElement('TR');\n            const TD_key = document.createElement('TD');\n            const TD_value = document.createElement('TD');\n\n            const INPUT_remove = document.createElement('INPUT');\n            INPUT_remove.type = 'submit';\n            //TODO add class\n            INPUT_remove.value = 'x';\n            INPUT_remove.onclick = () => {\n                item.delete([key]);\n            };\n            TD_key.appendChild(INPUT_remove);\n            const TEXT_key = document.createTextNode(key);\n            TD_key.appendChild(TEXT_key);\n\n            const TAG = item.renderSubElement('edit', [key], item.getStatus(), subContent, subSettings, subOptions);\n            TD_value.appendChild(TAG);\n\n            TR.appendChild(TD_key);\n            TR.appendChild(TD_value);\n            rows[key] = TR;\n            TABLE.insertBefore(TR, TR_add);\n        };\n        const deleteRow = key => {\n            const TAG_row = rows[key];\n            delete rows[key];\n            rows.parentNode.removeChild(TAG_row);\n        };\n\n        if (typeof content === 'object' && content !== null) {\n            for (let key in content) {\n                const subContent = content[key];\n                addTR(key, subContent,);\n            }\n        }\n        setupOnChange(item, rows, addTR, deleteRow);\n        return TABLE;\n    },\n    view: function (item) {\n        //TODO check if content is array\n        const content = item.getContent();\n        const subSettings = item.getSetting('subType');\n        const subOptions = item.getOptions(); //TODO\n        const TABLE = document.createElement('TABLE');\n        const rows = {};\n        const addTR = (key, subContent) => {\n            const TR = document.createElement('TR');\n            const TD_key = document.createElement('TD');\n            const TD_value = document.createElement('TD');\n            TD_key.innerText = key;\n            TR.appendChild(TD_key);\n\n            const TAG = item.renderSubElement('view', [key], item.getStatus(), subContent, subSettings, subOptions);\n            TD_value.appendChild(TAG);\n            TR.appendChild(TD_value);\n            rows[key] = TR;\n            TABLE.appendChild(TR);\n        };\n        for (let key in content) {\n            const subContent = content[key];\n            addTR(key, subContent);\n        }\n        setupOnChange(item, rows, addTR);\n        return TABLE;\n    },\n    validateContent: function (item) {\n        const content = item.getContent();\n        if (content === null || typeof content !== 'object') {\n            return false;\n        }\n        const subSettings = item.getSetting('subType');\n        for (let key in content) {\n            const subContent = content[key];\n            if (!item.validateContent(content, subSettings)) {\n                return false;\n            }\n        }\n        return true;\n    },\n    validateSubPropertyPath: function (subPropertyPath, settings, validateSubPropertyPath) {\n        const subType = settings.subType.type || 'string';\n        return subPropertyPath instanceof Array &&\n            typeof subPropertyPath[0] === 'string' &&\n            validateSubPropertyPath(subType, subPropertyPath.slice(1));\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/object/object.js?");

/***/ }),

/***/ "../../engine/core/types/object/object.json":
/*!*************************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/object/object.json ***!
  \*************************************************************************************************/
/*! exports provided: default, TODO */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"default\\\":{\\\"type\\\":\\\"object\\\",\\\"default\\\":{}},\\\"TODO\\\":{}}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/object/object.json?");

/***/ }),

/***/ "../../engine/core/types/password/password.js":
/*!***************************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/password/password.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        //TODO notify if caps lock is on\n        const TABLE = document.createElement('TABLE');\n        // if edit, not create then request also current password\n        let INPUT_old;\n        if (item.getOption('display') !== 'create') { // edit password -> confirm old + double to confirm\n            const TR_old = document.createElement('TR');\n            const TD_oldLabel = document.createElement('TD');\n            const TD_oldInput = document.createElement('TD');\n            INPUT_old = document.createElement('INPUT');\n            INPUT_old.type = 'password';\n            TD_oldLabel.innerText = 'Current';\n            TD_oldInput.appendChild(INPUT_old);\n            TR_old.appendChild(TD_oldLabel);\n            TR_old.appendChild(TD_oldInput);\n            TABLE.appendChild(TR_old);\n        }\n\n        // double to confirm\n        const TR_new = document.createElement('TR');\n        const TD_newLabel = document.createElement('TD');\n        const TD_newInput = document.createElement('TD');\n        const INPUT_new = document.createElement('INPUT');\n        INPUT_new.type = 'password';\n        TD_newLabel.innerText = 'Password';\n        TD_newInput.appendChild(INPUT_new);\n        TR_new.appendChild(TD_newLabel);\n        TR_new.appendChild(TD_newInput);\n        TABLE.appendChild(TR_new);\n\n\n        const TR_confirm = document.createElement('TR');\n        const TD_confirmLabel = document.createElement('TD');\n        const TD_confirmInput = document.createElement('TD');\n        const INPUT_confirm = document.createElement('INPUT');\n        INPUT_confirm.type = 'password';\n        TD_confirmLabel.innerText = 'Confirm';\n        TD_confirmInput.appendChild(INPUT_confirm);\n        TR_confirm.appendChild(TD_confirmLabel);\n        TR_confirm.appendChild(TD_confirmInput);\n        TABLE.appendChild(TR_confirm);\n\n        if (item.getOption('display') !== 'create') { // edit password -> confirm old + double to confirm\n            const TR_submit = document.createElement('TR');\n            const TD_submit = document.createElement('TD');\n            const INPUT_submit = document.createElement('INPUT');\n            INPUT_submit.setAttribute('colspan', '2');\n            INPUT_submit.type = 'Submit';\n            INPUT_submit.value = 'Update';\n            TD_submit.appendChild(INPUT_submit);\n            TR_submit.appendChild(TD_submit);\n            TABLE.appendChild(TR_submit);\n            //TODO check if they match, if not: indicate!\n            INPUT_submit.onclick = () => {\n                item.patch({old: INPUT_old.value, new: INPUT_new.value, confirm: INPUT_confirm.value})\n            };\n        } else { // create password : update data continuously\n            const onChangeHandler = () => {\n                item.patch({new: INPUT_new.value, confirm: INPUT_confirm.value})\n            };\n            INPUT_new.oninput = onChangeHandler;\n            INPUT_confirm.oninput = onChangeHandler;\n        }\n        return TABLE;\n    },\n    view: function (item) {\n        const SPAN = document.createElement('SPAN');\n        SPAN.innerText = '***';\n        return SPAN;\n    },\n    validateContent: function (item) {\n        const content = item.getContent();\n        if (typeof content !== 'object' || content === null) return false;\n        if (typeof content.new !== 'string') return false;\n        if (typeof content.confirm !== 'string') return false;\n        return content.confirm === content.new; // TODO min/max length, allow chars, regex\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/password/password.js?");

/***/ }),

/***/ "../../engine/core/types/password/password.json":
/*!*****************************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/password/password.json ***!
  \*****************************************************************************************************/
/*! exports provided: minLength, maxLength, allowedChars, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"minLength\\\":{\\\"type\\\":\\\"number\\\",\\\"min\\\":0},\\\"maxLength\\\":{\\\"type\\\":\\\"number\\\",\\\"min\\\":0},\\\"allowedChars\\\":{\\\"type\\\":\\\"string\\\"}}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/password/password.json?");

/***/ }),

/***/ "../../engine/core/types/reference/reference.js":
/*!*****************************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/reference/reference.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        const TAG = item.ui({\n            uri: item.getSetting('uri'),\n            display: 'select',\n            select: (entityClass, entityId) => item.patch('/' + entityClass + '/' + entityId),\n            initialValue: item.getContent(),\n            addCreateButton: item.getOption('addCreateButton') || false\n        });\n        //TODO onchange : how to?\n        return TAG;\n    },\n    view: function (item) {\n        const DIV = document.createElement('DIV');\n        if (typeof item.getContent() !== 'undefined') {\n            item.ui({uri: item.getContent(), display: 'item'}, DIV);\n        }\n        //TODO onchange : how to? redo the ui definition\n        return DIV;\n    },\n    validateContent: function (item) {\n        // content should be \"/$entityClassName/$entityId\"\n        const referenceUri = item.getContent();\n        if (typeof referenceUri !== 'string') return false;\n        const uri = item.getSetting('uri');\n        const entityClassName = uri.substr(1).split('/')[0];\n        const referencePath = referenceUri.substr(1).split('/');\n        return referencePath[0] === entityClassName && referencePath.length === 2;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/reference/reference.js?");

/***/ }),

/***/ "../../engine/core/types/reference/reference.json":
/*!*******************************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/reference/reference.json ***!
  \*******************************************************************************************************/
/*! exports provided: default, uri */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"default\\\":{\\\"type\\\":\\\"reference\\\"},\\\"uri\\\":{\\\"type\\\":\\\"string\\\",\\\"regex\\\":\\\"TODOuriregex\\\"}}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/reference/reference.json?");

/***/ }),

/***/ "../../engine/core/types/string/string.js":
/*!***********************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/string/string.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const encodings = ['utf8', 'base64'];  //TODO single source of truth (php+js)\n\nfunction recodeString(content, targetEncoding) {\n    if (typeof content === 'string') {\n        return content;\n    } else if (typeof content === 'object' && content !== null && content.hasOwnProperty('content')) {\n        const encoding = content.hasOwnProperty('encoding') ? content.encoding : 'utf8';\n        switch (encoding) {\n            case 'utf8' :\n                return content.content;\n            case 'base64' :\n                return atob(content.content).toString();\n            default:\n                console.error('unknown encoding', encoding);\n                return 'Error: unknown encoding';\n        }\n    }\n}\n\nfunction edit(item) {\n    const INPUT = document.createElement('INPUT');\n    INPUT.value = item.getContent();\n    if (item.getSetting('password') === true) {\n        INPUT.type = 'password';\n    }\n    if (item.patch) {\n        INPUT.oninput = () => {\n            item.patch(INPUT.value)\n        };\n    }\n    const onChangeHandler = node => {\n        //TODO use status\n        const content = node.getContent();\n        if (INPUT !== document.activeElement) { // we don't want to interrupt typing\n            INPUT.value = content;\n        }\n    };\n    item.onChange(onChangeHandler);\n    onChangeHandler(item);\n    return INPUT;\n}\n\nfunction view(item) {\n    const SPAN = document.createElement('SPAN');\n    const onChangeHandler = node => {\n        switch (node.getStatus()) {\n            case 500 :\n                SPAN.innerText = 'Server error';\n                break;\n            case 400 :\n                SPAN.innerText = 'Bad request';\n                break;\n            case 403 :\n                SPAN.innerText = 'Forbidden';\n                break;\n            case 404 :\n                SPAN.innerText = 'Not found';\n                break;\n            default:\n                if (item.getSetting('password') === true) {\n                    SPAN.innerText = '***';\n                } else {\n                    const stringContent = recodeString(node.getContent(), 'utf8');\n                    SPAN.innerText = stringContent;\n                }\n                break;\n        }\n    };\n    onChangeHandler(item);\n    item.onChange(onChangeHandler);\n    return SPAN;\n}\n\nfunction validateContent(item) {\n    const content = item.getContent();\n    if (typeof content === 'string') {\n        if (item.hasSetting('maxLength') && content.length > item.getSetting('maxLength')) return false;\n        if (item.hasSetting('minLength') && content.length < item.getSetting('minLength')) return false;\n        //TODO  regex, allowed chars\n        return true;\n    } else if (item.getSetting('binary') && typeof content === 'object') {\n        if (!content.hasOwnProperty('encoding')) return false;\n        if (!content.hasOwnProperty('content')) return false;\n        if (typeof content.content !== 'string') return false;\n        if (encodings.indexOf(content.encoding) === -1) return false;\n        //TODO validate encoding\n        return true;\n    }\n    return false;\n}\n\nexports.recodeString = recodeString;\nexports.actions = {\n    edit,\n    view,\n    validateContent\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/string/string.js?");

/***/ }),

/***/ "../../engine/core/types/string/string.json":
/*!*************************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/string/string.json ***!
  \*************************************************************************************************/
/*! exports provided: default, regex, minLength, maxLength, allowedChars, password, binary */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"default\\\":{\\\"type\\\":\\\"string\\\",\\\"default\\\":\\\"\\\"},\\\"regex\\\":{\\\"type\\\":\\\"string\\\"},\\\"minLength\\\":{\\\"type\\\":\\\"number\\\",\\\"min\\\":0},\\\"maxLength\\\":{\\\"type\\\":\\\"number\\\",\\\"min\\\":0},\\\"allowedChars\\\":{\\\"type\\\":\\\"string\\\"},\\\"password\\\":{\\\"type\\\":\\\"bool\\\",\\\"default\\\":false},\\\"binary\\\":{\\\"type\\\":\\\"bool\\\",\\\"default\\\":false}}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/string/string.json?");

/***/ }),

/***/ "../../engine/core/types/type/type.js":
/*!*******************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/type/type.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (originalItem) {\n        const TABLE = document.createElement('TABLE');\n\n        const changeHandler = types => item => {\n            TABLE.innerHTML = '';\n            const TR_type = document.createElement('TR');\n            const TD_typeLabel = document.createElement('TD');\n            TD_typeLabel.innerText = 'Type';\n            const TD_typeSelect = document.createElement('TD');\n            const SELECT = document.createElement('SELECT');\n            for (let type in types.type) {\n                const OPTION = document.createElement('OPTION');\n                OPTION.innerText = type;\n                SELECT.appendChild(OPTION);\n            }\n            TD_typeSelect.appendChild(SELECT);\n            TR_type.appendChild(TD_typeLabel);\n            TR_type.appendChild(TD_typeSelect);\n            TABLE.appendChild(TR_type);\n\n            const content = item.getContent() || {};\n            const type = content.type || 'string';\n            const settings = types.type[type].parameters.getContent();\n            for (let key in settings) {\n                const TR = document.createElement('TR');\n                const TD_label = document.createElement('TD');\n                const TD_value = document.createElement('TD');\n                TD_label.innerText = key;\n                const subSettings = settings[key];\n                const subContent = content[key];\n\n                const subOnChange = (newContent, subUri2) => {\n                    originalItem.patch(newContent, [key]);\n                };\n                const TAG = originalItem.renderSubElement('edit', [key], item.getStatus(), subContent, subSettings, {onChange:subOnChange});\n                TD_value.appendChild(TAG);\n                TR.appendChild(TD_label);\n                TR.appendChild(TD_value);\n                TABLE.appendChild(TR);\n            }\n        };\n        //TODO fix onchange\n\n        originalItem.get('/type', types => {\n            changeHandler(types)(originalItem);\n            originalItem.onChange(changeHandler(types));\n        });\n        return TABLE;\n    },\n    view: function (item) {\n        const SPAN = document.createElement('SPAN');\n        const onChange = item => {\n            const settings = item.getContent();\n            let text = '<b>';\n            let first = true;\n            text += (settings.type || 'string') + '</b>(';\n            for (let key in settings) {\n                if (key !== 'type') {\n                    if (first) {\n                        first = false;\n                    } else {\n                        text += ',';\n                    }\n                    text += key + ':' + JSON.stringify(settings[key]).replace(/\"/g, '');\n                }\n            }\n            text += ')';\n            SPAN.innerHTML = text;\n        };\n        onChange(item);\n        item.onChange(onChange);\n        return SPAN;\n    },\n    validateContent: function (item) {\n        //TODO should be 0 or null always?\n        return true;//TODO\n    },\n    validateSubPropertyPath: function (subPropertyPath, settings) {\n        return subPropertyPath instanceof Array;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/type/type.js?");

/***/ }),

/***/ "../../engine/core/types/type/type.json":
/*!*********************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/type/type.json ***!
  \*********************************************************************************************/
/*! exports provided: default, TODO */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"default\\\":{\\\"type\\\":\\\"type\\\",\\\"default\\\":\\\"string\\\"},\\\"TODO\\\":{}}\");\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/type/type.json?");

/***/ }),

/***/ "./build/displays.js":
/*!***************************!*\
  !*** ./build/displays.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// This file is created by gulpfile.js using the type definitions of engine/core/displays/*.js. \n\nexports.item = __webpack_require__(/*! ../../../engine/core/displays/item.js */ \"../../engine/core/displays/item.js\").display;\nexports.list = __webpack_require__(/*! ../../../engine/core/displays/list.js */ \"../../engine/core/displays/list.js\").display;\nexports.select = __webpack_require__(/*! ../../../engine/core/displays/select.js */ \"../../engine/core/displays/select.js\").display;\nexports.timeline = __webpack_require__(/*! ../../../engine/core/displays/timeline.js */ \"../../engine/core/displays/timeline.js\").display;\n\n\n//# sourceURL=webpack://xyz/./build/displays.js?");

/***/ }),

/***/ "./build/types.js":
/*!************************!*\
  !*** ./build/types.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// This file is created by gulpfile.js using the type definitions of engine/core/types/*/*.js. \n\nexports.array = __webpack_require__(/*! ../../../engine/core/types/array/array.js */ \"../../engine/core/types/array/array.js\").actions;\nexports.array.json = __webpack_require__(/*! ../../../engine/core/types/array/array.json */ \"../../engine/core/types/array/array.json\");\n\nexports.bool = __webpack_require__(/*! ../../../engine/core/types/bool/bool.js */ \"../../engine/core/types/bool/bool.js\").actions;\nexports.bool.json = __webpack_require__(/*! ../../../engine/core/types/bool/bool.json */ \"../../engine/core/types/bool/bool.json\");\n\nexports.date = __webpack_require__(/*! ../../../engine/core/types/date/date.js */ \"../../engine/core/types/date/date.js\").actions;\nexports.date.json = __webpack_require__(/*! ../../../engine/core/types/date/date.json */ \"../../engine/core/types/date/date.json\");\n\nexports.enum = __webpack_require__(/*! ../../../engine/core/types/enum/enum.js */ \"../../engine/core/types/enum/enum.js\").actions;\nexports.enum.json = __webpack_require__(/*! ../../../engine/core/types/enum/enum.json */ \"../../engine/core/types/enum/enum.json\");\n\nexports.file = __webpack_require__(/*! ../../../engine/core/types/file/file.js */ \"../../engine/core/types/file/file.js\").actions;\nexports.file.json = __webpack_require__(/*! ../../../engine/core/types/file/file.json */ \"../../engine/core/types/file/file.json\");\n\nexports.id = __webpack_require__(/*! ../../../engine/core/types/id/id.js */ \"../../engine/core/types/id/id.js\").actions;\nexports.id.json = __webpack_require__(/*! ../../../engine/core/types/id/id.json */ \"../../engine/core/types/id/id.json\");\n\nexports.json = __webpack_require__(/*! ../../../engine/core/types/json/json.js */ \"../../engine/core/types/json/json.js\").actions;\nexports.json.json = __webpack_require__(/*! ../../../engine/core/types/json/json.json */ \"../../engine/core/types/json/json.json\");\n\nexports.login = __webpack_require__(/*! ../../../engine/core/types/login/login.js */ \"../../engine/core/types/login/login.js\").actions;\nexports.login.json = __webpack_require__(/*! ../../../engine/core/types/login/login.json */ \"../../engine/core/types/login/login.json\");\n\nexports.number = __webpack_require__(/*! ../../../engine/core/types/number/number.js */ \"../../engine/core/types/number/number.js\").actions;\nexports.number.json = __webpack_require__(/*! ../../../engine/core/types/number/number.json */ \"../../engine/core/types/number/number.json\");\n\nexports.object = __webpack_require__(/*! ../../../engine/core/types/object/object.js */ \"../../engine/core/types/object/object.js\").actions;\nexports.object.json = __webpack_require__(/*! ../../../engine/core/types/object/object.json */ \"../../engine/core/types/object/object.json\");\n\nexports.password = __webpack_require__(/*! ../../../engine/core/types/password/password.js */ \"../../engine/core/types/password/password.js\").actions;\nexports.password.json = __webpack_require__(/*! ../../../engine/core/types/password/password.json */ \"../../engine/core/types/password/password.json\");\n\nexports.reference = __webpack_require__(/*! ../../../engine/core/types/reference/reference.js */ \"../../engine/core/types/reference/reference.js\").actions;\nexports.reference.json = __webpack_require__(/*! ../../../engine/core/types/reference/reference.json */ \"../../engine/core/types/reference/reference.json\");\n\nexports.string = __webpack_require__(/*! ../../../engine/core/types/string/string.js */ \"../../engine/core/types/string/string.js\").actions;\nexports.string.json = __webpack_require__(/*! ../../../engine/core/types/string/string.json */ \"../../engine/core/types/string/string.json\");\n\nexports.type = __webpack_require__(/*! ../../../engine/core/types/type/type.js */ \"../../engine/core/types/type/type.js\").actions;\nexports.type.json = __webpack_require__(/*! ../../../engine/core/types/type/type.json */ \"../../engine/core/types/type/type.json\");\n\n\n\n//# sourceURL=webpack://xyz/./build/types.js?");

/***/ }),

/***/ "./source/entity/entity.js":
/*!*********************************!*\
  !*** ./source/entity/entity.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Property = __webpack_require__(/*! ./property.js */ \"./source/entity/property.js\").constructor;\nconst listener = __webpack_require__(/*! ./listener.js */ \"./source/entity/listener.js\");\nconst uriTools = __webpack_require__(/*! ../uri/uri.js */ \"./source/uri/uri.js\");\nconst State = __webpack_require__(/*! ./state.js */ \"./source/entity/state.js\").State;\nconst response = __webpack_require__(/*! ./response.js */ \"./source/entity/response.js\");\nconst input = __webpack_require__(/*! ../request/input.js */ \"./source/request/input.js\");\n\nfunction compileSettings(rawSettings){\n    const settings = {};\n    const rootSettings = rawSettings.hasOwnProperty('_') ? rawSettings['_'] : {};\n    for (let propertyName in rawSettings) {\n        if (propertyName !== '_') {\n            settings[propertyName] = {...rootSettings};\n            for (let id in rawSettings[propertyName]) {\n                if ((id === 'access' || id === 'connector') && rootSettings.hasOwnProperty(id)) {\n                    settings[propertyName][id] = {...rootSettings[id], ...rawSettings[propertyName][id]};\n                } else {\n                    settings[propertyName][id] = rawSettings[propertyName][id];\n                }\n            }\n        }\n    }\n    return settings;\n}\n\nfunction EntityClass(xyz, entityClassName, rawSettings) {\n\n    const settings = compileSettings(rawSettings);\n\n    if (typeof entityClassName !== 'string') throw new TypeError('entityClassName not a string.');\n\n    const entities = {}; //TODO mark if entities are new or have been removed\n    const statusses = {};\n\n    listener.Handler.call(this);\n\n    const properties = {};\n\n    for (let propertyName in settings) {\n        properties[propertyName] = new Property(xyz, this, propertyName, settings[propertyName]);\n    }\n\n    this.getSettings = () => settings;\n\n    this.getEntityClassName = () => entityClassName;\n\n    this.getUri = entityId => {\n        if (typeof entityId !== 'string') throw new TypeError('entityId not a string.');\n\n        return '/' + entityClassName + '/' + entityId;\n    };\n\n    const addEntityListener = (entityId, path, eventName, callback) => {\n        const listeners = [];\n        if (path.length === 0) {\n            const listener = this.addAtomicListener(entityId, eventName, callback);\n            listeners.push(listener);\n        } else {\n            const propertNameList = path[0];\n            const propertyNames = propertNameList === '*'\n                ? Object.keys(properties)\n                : propertNameList.split(',');\n            const subPath = path.slice(1);\n            for (let propertyName of propertyNames) {\n                if (properties.hasOwnProperty(propertyName)) {\n                    const propertyListeners = properties[propertyName].addPropertyListener(entityId, subPath, eventName, callback);\n                    listeners.push(...propertyListeners);\n                } else {\n                    //TODO throw error?\n                    console.error(subPropertyName + 'not available')\n                }\n            }\n        }\n        return listeners;\n    };\n\n    this.addListener = (path, eventName, callback) => {\n        //TODO check path, callback and eventName\n        // TODO only if path.length <= 1 ? otherwise send to properties\n        const listeners = [];\n        const entityIds = (path.length === 0 || path[0] === '*')\n            ? ['*']\n            : path[0].split(',');\n        const subPath = path.splice(1);\n        for (let entityId of entityIds) {\n            const entityListeners = addEntityListener(entityId, subPath, eventName, callback);\n            listeners.push(...entityListeners);\n        }\n        return listeners;\n    };\n\n    this.getResponse = (path, entityId, method) => {\n        const propertyNames = (path.length === 0 || path[0] === '*')\n            ? Object.keys(properties)\n            : path[0].split(',');\n        const content = {};\n        const subPath = path.slice(1);\n        for (let propertyName of propertyNames) {\n            if (properties.hasOwnProperty(propertyName)) {\n                content[propertyName] = properties[propertyName].getResponse(subPath, entityId, method);\n            } else {\n                content[propertyName] = new response.Node(this, entityId, 400, null, [`${propertyName} does not exist.`], method); //TODO\n            }\n        }\n        return content;\n    };\n\n    //TODO MAYBE make private /remove\n    this.getEntityClassResponse = (path, method) => {\n        const entityIds = (path.length === 0 || path[0] === '*')\n            ? Object.keys(entities)\n            : path[0].split(',');\n        const content = {};\n        const subPath = path.slice(1);\n        for (let entityId of entityIds) {\n            if (entities.hasOwnProperty(entityId)) {\n                content[entityId] = this.getResponse(subPath, entityId, method);\n            } else {\n                content[entityId] = new response.Node(this, entityId, 404, null, [`/${entityClassName}/${entityId} not found.`], method); //TODO\n            }\n        }\n        return content;\n    };\n\n    this.createCreator = (options, data, INPUT_submit) => {\n        const TABLE = document.createElement('TABLE');\n        TABLE.classList.add('xyz-create');\n        const TR_header = document.createElement('TR');\n        TR_header.classList.add('xyz-create-header');\n        const TD_header = document.createElement('TD');\n        TD_header.setAttribute('colspan', '2');\n        TR_header.appendChild(TD_header);\n        TABLE.appendChild(TR_header);\n        TD_header.innerText = 'New ' + entityClassName;\n        for (let propertyName in properties) {\n            for (let TR of properties[propertyName].createCreator(options, data, INPUT_submit)) {\n                TABLE.appendChild(TR);\n            }\n        }\n        return TABLE;\n    };\n\n    this.isAutoIncremented = () => {\n        for (let propertyName in properties) {\n            if (properties[propertyName].isAutoIncremented()) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    this.getIdProperty = () => {\n        for (let propertyName in properties) {\n            const property = properties[propertyName];\n            if (property.isId()) {\n                return propertyName;\n            }\n        }\n        return null;\n    };\n\n    this.getIdFromContent = data => {\n        if (typeof data !== 'object' || data === null) {//TODO is_object\n            return null;\n        }\n        for (let propertyName in properties) {\n            if (data.hasOwnProperty(propertyName)) {\n                const id = properties[propertyName].getIdFromContent(data[propertyName]);\n                if (id) {\n                    return id;\n                }\n            }\n        }\n        return null;\n    };\n\n    this.callListeners = (state, entityId) => {\n        this.callAtomicListeners(state, entityId, this.getResponse([], entityId, state.getMethod()))\n    };\n\n    const handleEntityIdInput = input.handle(this, statusses, properties, entities);\n\n    this.handleInput = (path, method, entityClassStatus, entityClassContent, requestContent, entityIds) => {\n        const state = new State(method);\n        const idProperty = this.getIdProperty();\n        if (entityClassStatus === 207) {\n            for (let entityId of entityIds) {\n                const entity207Wrapper = entityClassContent[entityId];\n                if (entity207Wrapper === null || typeof entity207Wrapper !== 'object'\n                    || !entity207Wrapper.hasOwnProperty('status')\n                    || !entity207Wrapper.hasOwnProperty('content')\n                ) {\n                    //TODO reponse is in error\n                    console.error('error response in wrong format');\n                } else {\n                    const entityStatus = entity207Wrapper.status;\n                    const entityContent = entity207Wrapper.content;\n                    const requestEntityId = method === 'POST' ? 'new' : entityId; // for POST the request is done with new TODO fix for multiple\n                    const subRequestContent = typeof requestContent === 'object' && requestContent !== null ? requestContent[requestEntityId] : null;\n                    const subPath = path.slice(1);\n                    const entityState = handleEntityIdInput(subPath, method, entityId, entityStatus, entityContent, subRequestContent);\n                    state.addSubState(entityState);\n                }\n            }\n        } else {\n            //TODO if error set error\n            //            state.setError(404, 'Not found');\n            for (let entityId of entityIds) {\n                const entityContent = (entityClassContent === null || typeof entityClassContent !== 'object')\n                    ? null\n                    : entityClassContent[entityId];\n                const requestEntityId = method === 'POST' ? 'new' : entityId; // for POST the request is done with new TODO fix for multiple\n                const subRequestContent = typeof requestContent === 'object' && requestContent !== null ? requestContent[requestEntityId] : null;\n                const subPath = path.slice(1);\n                const entityState = handleEntityIdInput(subPath, method, entityId, entityClassStatus, entityContent, subRequestContent);\n                state.addSubState(entityState);\n            }\n        }\n        return state;\n    };\n\n    this.render = (action, options, entityId) => {\n        //TODO get xyz here\n        const DIV = document.createElement('DIV');\n        for (let propertyName in properties) {\n            const TAG = properties[propertyName].render(action, options, entityId);\n            DIV.appendChild(TAG);\n        }\n        return DIV;\n    };\n}\n\n\nconst handleInput = (method, uri, status, responseContent, requestContent, entityClasses) => {\n    const state = new State(method);\n    //TODO check status\n\n    const path = uriTools.pathFromUri(uri);\n    const entityClassNameList = path[0]; // TODO error if no entityClass\n    const entityIdList = path[1] || '*';\n    const entityClassNames = entityClassNameList.split(',');\n    if (status === 207) {\n        for (let entityClassName of entityClassNames) {\n            const entityClass207Wrapper = responseContent[entityClassName];\n            if (entityClass207Wrapper === null || typeof entityClass207Wrapper !== 'object'\n                || !entityClass207Wrapper.hasOwnProperty('status')\n                || !entityClass207Wrapper.hasOwnProperty('content')\n            ) {\n                console.error('error response in wrong format');//TODO\n            } else {\n                const entityClassStatus = entityClass207Wrapper.status;\n                const entityClassContent = entityClass207Wrapper.content;\n                const entityClass = entityClasses[entityClassName];\n                const entityIds = (entityIdList === '*')\n                    ? Object.keys(entityClassContent)\n                    : entityIdList.split(',');\n                const subRequestContent = typeof requestContent === 'object' && requestContent !== null ? requestContent[entityClassName] : null;\n                const subPath = path.slice(1);\n                const entityClassState = entityClass.handleInput(subPath, method, entityClassStatus, entityClassContent, subRequestContent, entityIds);\n                state.addSubState(entityClassState);\n            }\n        }\n    } else {\n        for (let entityClassName of entityClassNames) {\n            const entityClassContent = responseContent[entityClassName];\n            const subRequestContent = typeof requestContent === 'object' && requestContent !== null ? requestContent[entityClassName] : null;\n            const subPath = path.slice(1);\n            if (entityClassContent === null || typeof entityClassContent !== 'object') {\n                const entityIds = entityIdList === '*'\n                    ? []\n                    : entityIdList.split(',');\n                const entityClass = entityClasses[entityClassName];\n                const entityClassState = entityClass.handleInput(subPath, method, 404, {}, subRequestContent, entityIds);\n                state.addSubState(entityClassState);\n            } else {\n                const entityIds = entityIdList === '*'\n                    ? Object.keys(entityClassContent)\n                    : entityIdList.split(',');\n                const entityClass = entityClasses[entityClassName];\n                const entityClassState = entityClass.handleInput(subPath, method, status, entityClassContent, subRequestContent, entityIds);\n                state.addSubState(entityClassState);\n            }\n        }\n    }\n    return state;\n};\n\nfunction getResponse(uri, entityClasses, method) {\n    const path = uriTools.pathFromUri(uri);\n    const entityClassNames = (path.length === 0 || path[0] === '*')\n        ? Object.keys(entityClasses)\n        : path[0].split(',');\n    const content = {};\n    const subPath = path.slice(1);\n    for (let entityClassName of entityClassNames) {\n        if (entityClasses.hasOwnProperty(entityClassName)) {\n            content[entityClassName] = entityClasses[entityClassName].getEntityClassResponse(subPath, method);\n        } else {\n            //TODO replace null with something that has the endpoints required by Node\n            content[entityClassName] = new response.Node(null, '*', 404, null, [`/${entityClassName} not found.`], method); //TODO\n        }\n    }\n    return content;\n}\n\nconst isAutoIncremented = (entityClasses, entityClassName) => {\n    return entityClassName === '*' || !entityClasses.hasOwnProperty(entityClassName)\n        ? false\n        : entityClasses[entityClassName].isAutoIncremented();\n};\n\nexports.isAutoIncremented = isAutoIncremented;\nexports.getResponse = getResponse;\nexports.Class = EntityClass;\nexports.handleInput = handleInput;\n\n//# sourceURL=webpack://xyz/./source/entity/entity.js?");

/***/ }),

/***/ "./source/entity/listener.js":
/*!***********************************!*\
  !*** ./source/entity/listener.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const State = __webpack_require__(/*! ./state.js */ \"./source/entity/state.js\").State;\nconst eventNames = ['changed', 'created', 'removed']; //TODO , 'error'\nconst response = __webpack_require__(/*! ./response.js */ \"./source/entity/response.js\");\n\nfunction Listener(listenerHandler, eventName, entityId, subUri) {\n    this.stop = () => {\n        listenerHandler.removeListener(this);\n    };\n    this.getSubUri = () => subUri;\n    this.getEntityId = () => entityId;\n    this.getEventName = () => eventName;\n}\n\nfunction ListenerHandler() {\n    const listenersPerEntityIdPerEventNamePerSubUri = {};\n\n    const callListeners = (eventName, entityId, listenerEntityId, node, subUri) => {\n        if (listenersPerEntityIdPerEventNamePerSubUri.hasOwnProperty(listenerEntityId)) {\n            const listenersPerEventNamePerSubUri = listenersPerEntityIdPerEventNamePerSubUri[listenerEntityId];\n            if (listenersPerEventNamePerSubUri.hasOwnProperty(eventName)) {\n                const listenersPerSubUri = listenersPerEventNamePerSubUri[eventName];\n                const entityClassName = this.getEntityClassName();\n                if (typeof subUri === 'undefined') { // if no subUri is specified, call all subUri's\n                    for (let subUri in listenersPerSubUri) {\n                        const subPath = subUri === '' ? [] : subUri.split('/');\n                        const subNode = response.getSubNode(this, entityId, node, subPath);\n                        console.log('callListener', '/' + entityClassName + '/' + entityId + '/' + subUri + ':' + eventName);\n                        if (subNode) {\n                            const listeners = listenersPerSubUri[subUri];\n                            listeners.forEach(callback => callback(entityClassName, entityId, subNode, eventName));\n                        }\n                    }\n                } else if (listenersPerSubUri.hasOwnProperty(subUri)) {\n                    const subPath = subUri === '' ? [] : subUri.split('/');\n                    const subNode = response.getSubNode(this, entityId, node, subPath);\n                    console.log('callListener', '/' + entityClassName + '/' + entityId + '/' + subUri + ':' + eventName);\n                    if (subNode) {\n                        const listeners = listenersPerSubUri[subUri];\n                        listeners.forEach(callback => callback(entityClassName, entityId, subNode, eventName));\n                    }\n                }\n            }\n        }\n    };\n\n    const callAllListeners = (eventName, entityId, node, subUri) => {\n        if (eventNames.indexOf(eventName) === -1) throw new Error('Listener eventName \"' + eventName + '\"  is not in allowed event names: ' + eventNames.join(', ') + '.');\n        callListeners(eventName, entityId, '*', node, subUri);\n        callListeners(eventName, entityId, entityId, node, subUri)\n    };\n\n    this.callAtomicListeners = (state, entityId, node, subUri) => {\n        if (typeof entityId !== 'string') throw new TypeError(\"entityId is not a string.\");\n        if (!state instanceof State) throw new TypeError(\"state is not a State.\");\n\n        if (state.isRemoved()) {\n            callAllListeners('removed', entityId, node, subUri);\n        }else if (state.isCreated()) {\n            callAllListeners('created', entityId, node, subUri);\n            //TODO }else if(state.isError()){\n         //   callAllListeners('error', entityId, node, subUri);\n        } else if (state.isChanged()) {\n            callAllListeners('changed', entityId, node, subUri);\n        } else {\n            // nothing to do\n        }\n    };\n\n    this.addAtomicListener = (entityId, eventName, callback, subUri) => {\n        if (typeof subUri === 'undefined') subUri = '';\n        if (typeof subUri !== 'string') throw new TypeError(\"Listener subUri is not a string.\");\n        if (typeof callback !== 'function') throw new TypeError(\"Listener callback is not a function.\");\n        if (typeof entityId !== 'string') throw new TypeError(\"Listener entityId is not a string.\");\n        if (typeof eventName !== 'string') throw new TypeError(\"Listener eventName is not a string.\");\n        if (eventNames.indexOf(eventName) === -1) throw new Error('Listener eventName \"' + eventName + '\"  is not in allowed event names: ' + eventNames.join(', ') + '.');\n\n        if (!listenersPerEntityIdPerEventNamePerSubUri.hasOwnProperty(entityId)) {\n            listenersPerEntityIdPerEventNamePerSubUri[entityId] = {};\n        }\n        const listenersPerEventNamePerSubUri = listenersPerEntityIdPerEventNamePerSubUri[entityId];\n\n        if (!listenersPerEventNamePerSubUri.hasOwnProperty(eventName)) {\n            listenersPerEventNamePerSubUri[eventName] = {};\n        }\n        const listenersPerSubUri = listenersPerEventNamePerSubUri[eventName];\n        if (!listenersPerSubUri.hasOwnProperty(subUri)) {\n            listenersPerSubUri[subUri] = new Map();\n        }\n        const listeners = listenersPerSubUri[subUri];\n        const listener = new Listener(this, eventName, entityId, subUri);\n        listeners.set(listener, callback);\n\n        // for debug reasons output listener counts:\n        let count = 0;\n        for (let entityId in listenersPerEntityIdPerEventNamePerSubUri) {\n            const listenersPerEventNamePerSubUri = listenersPerEntityIdPerEventNamePerSubUri[entityId];\n            for (let eventName in listenersPerEventNamePerSubUri) {\n                const listenersPerSubUri = listenersPerEventNamePerSubUri[eventName];\n                for (let subUri in listenersPerSubUri) {\n                    const listeners = listenersPerSubUri[subUri];\n                    count += listeners.size;\n                }\n            }\n        }\n        console.log('addListener', this.getUri(entityId) + '/' + subUri + ':' + eventName, count);\n        return listener;\n    };\n\n    this.removeListener = listener => {\n        if (!listener instanceof Listener) throw new TypeError(\"listener is not a Listener.\");\n\n        const entityId = listener.getEntityId();\n        if (listenersPerEntityIdPerEventNamePerSubUri.hasOwnProperty(entityId)) {\n            const listenersPerEventNamePerSubUri = listenersPerEntityIdPerEventNamePerSubUri[entityId];\n            const eventName = listener.getEventName();\n            if (listenersPerEventNamePerSubUri.hasOwnProperty(eventName)) {\n                const listenersPerSubUri = listenersPerEventNamePerSubUri [eventName];\n                const subUri = listener.getSubUri();\n                if (listenersPerSubUri.hasOwnProperty(subUri)) {\n                    const listeners = listenersPerSubUri[subUri];\n                    if (listeners.has(listener)) {\n                        listeners.delete(listener);\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    };\n\n    /*this.hasListeners = (entityId, eventName) => { //TODO upgrade with subUri\n        if (typeof entityId === 'undefined') {\n            return Object.keys(listenersPerEntityIdPerEventNamePerSubUri).length > 0;\n        } else if (entityId === '*') {\n            if (typeof eventName === 'undefined') {\n                return Object.keys(listenersPerEntityIdPerEventNamePerSubUri).length > 0;\n            } else if (typeof eventName === 'string') {\n                for (let entityId in listenersPerEntityIdPerEventNamePerSubUri) {\n                    if (listenersPerEntityIdPerEventNamePerSubUri[entityId].hasOwnProperty(eventName)) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                throw new TypeError(\"eventName is not a string.\");\n            }\n        } else if (typeof entityId === 'string') {\n            if (listenersPerEntityIdPerEventNamePerSubUri.hasOwnProperty(entityId)) {\n                if (typeof eventName === 'undefined') {\n                    return true;\n                } else if (typeof eventName === 'string') {\n                    return listenersPerEntityIdPerEventNamePerSubUri[entityId].hasOwnProperty(eventName);\n                } else {\n                    throw new TypeError(\"eventName is not a string.\");\n                }\n            }\n        } else {\n            throw new TypeError(\"entityId is not a string.\");\n        }\n    };*/\n\n    /*this.removeListeners = (entityId, eventName) => { //TODO upgrade with subUri\n        if (typeof entityId === 'undefined') {\n            for (let entityId in listenersPerEntityIdPerEventNamePerSubUri) {\n                delete listenersPerEntityIdPerEventNamePerSubUri[entityId];\n            }\n        } else if (entityId === '*') {\n            if (typeof eventName === 'undefined') {\n                for (let entityId in listenersPerEntityIdPerEventNamePerSubUri) {\n                    delete listenersPerEntityIdPerEventNamePerSubUri[entityId];\n                }\n            } else if (typeof eventName === 'string') {\n                for (let entityId in listenersPerEntityIdPerEventNamePerSubUri) {\n                    if (listenersPerEntityIdPerEventNamePerSubUri[entityId].hasOwnProperty(eventName)) {\n                        delete listenersPerEntityIdPerEventNamePerSubUri[entityId][eventName];\n                    }\n                }\n                if (Object.keys(listenersPerEntityIdPerEventNamePerSubUri[entityId]).length === 0) {\n                    delete listenersPerEntityIdPerEventNamePerSubUri[entityId];\n                }\n                return false;\n            } else {\n                throw new TypeError(\"eventName is not a string.\");\n            }\n        } else if (typeof entityId === 'string') {\n            if (listenersPerEntityIdPerEventNamePerSubUri.hasOwnProperty(entityId)) {\n                if (typeof eventName === 'undefined') {\n                    delete listenersPerEntityIdPerEventNamePerSubUri[entityId];\n                } else if (typeof eventName === 'string') {\n                    delete listenersPerEntityIdPerEventNamePerSubUri[entityId][eventName];\n                    if (Object.keys(listenersPerEntityIdPerEventNamePerSubUri[entityId]).length === 0) {\n                        delete listenersPerEntityIdPerEventNamePerSubUri[entityId];\n                    }\n                } else {\n                    throw new TypeError(\"eventName is not a string.\");\n                }\n            }\n        } else {\n            throw new TypeError(\"entityId is not a string.\");\n        }\n    }*/\n}\n\nexports.Handler = ListenerHandler;\n\n\n//# sourceURL=webpack://xyz/./source/entity/listener.js?");

/***/ }),

/***/ "./source/entity/property.js":
/*!***********************************!*\
  !*** ./source/entity/property.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const types = __webpack_require__(/*! ../../build/types.js */ \"./build/types.js\");\nconst listener = __webpack_require__(/*! ./listener.js */ \"./source/entity/listener.js\");\nconst response = __webpack_require__(/*! ./response.js */ \"./source/entity/response.js\");\nconst render = __webpack_require__(/*! ../render/render.js */ \"./source/render/render.js\");\nconst input = __webpack_require__(/*! ../request/input.js */ \"./source/request/input.js\");\n\nconst validateSubPropertyPath = (types) => (type, subPropertyPath) => {\n    if (!types.hasOwnProperty(type)) return false;\n    if (typeof types[type].validateSubPropertyPath !== 'function') return false;\n    return types[type].validateSubPropertyPath(subPropertyPath);\n};\n\nexports.constructor = function Property(xyz, parent, propertyName, meta) {\n    listener.Handler.call(this);\n\n    const subProperties = {};\n    const contents = {};\n    const errors = {};//TODO\n    const statusses = {};//TODO\n\n    const type = meta.type;\n    //TODO handle type alliasses?\n    const settings = meta; //TODO check if object\n\n    let isPrimitive = true;\n    if (settings.hasOwnProperty('signature')) {\n        isPrimitive = false;\n        for (let subPropertyName in settings.signature) {\n            subProperties[subPropertyName] = new Property(xyz, this, subPropertyName, settings.signature[subPropertyName]);\n        }\n    }\n    this.getStatus = entityId => {\n        if (isPrimitive) return statusses[entityId];\n        let status;\n        for (let subPropertyName in subProperties) {\n            const subStatus = subProperties[subPropertyName].getStatus(entityId);\n            if (typeof status === 'undefined') {\n                status = subStatus;\n            } else if (status !== subStatus) {\n                return 207;\n            }\n        }\n        return status;\n    };\n\n    this.getContent = entityId => {\n        if (isPrimitive) return contents[entityId];\n        const content = {};\n        for (let subPropertyName in subProperties) {\n            content[subPropertyName] = subProperties[subPropertyName].getContent(entityId);\n        }\n        return content;\n    };\n\n    this.getSettings = () => settings;\n\n    this.getUri = entityId => parent.getUri(entityId) + '/' + propertyName;\n\n    this.getEntityClassName = () => parent.getEntityClassName();\n\n    this.getParent = () => parent;\n\n    this.getResponse = (path, entityId, method) => {\n        if (isPrimitive) {\n            return new response.Node(this, entityId, this.getStatus(entityId), this.getContent(entityId), errors[entityId], method);\n        } else {\n            const subPropertyNames = (path.length === 0 || path[0] === '*')\n                ? Object.keys(subProperties)\n                : path[0].split(',');\n            const content = {};\n            const subPath = path.slice(1);\n            for (let subPropertyName of subPropertyNames) {\n                if (subProperties.hasOwnProperty(subPropertyName)) {\n                    content[subPropertyName] = subProperties[subPropertyName].getResponse(subPath, entityId, method);\n                } else {\n                    content[subPropertyName] = new response.Node(this, entityId, 400, null, [`${subPropertyName} does not exist.`], method); //TODO\n                }\n            }\n            return content;\n        }\n    };\n\n    this.callListeners = (state, entityId) => {\n        this.callAtomicListeners(state, entityId, this.getResponse([], entityId, state.getMethod()));\n        parent.callListeners(state.getParentState(), entityId);\n    };\n\n    this.handleInput = isPrimitive\n        ? input.handlePrimitive(this, contents, statusses, subProperties)\n        : input.handle(this, statusses, subProperties);\n\n    this.addPropertyListener = (entityId, subPropertyPath, eventName, callback) => {\n        const listeners = [];\n        if (subPropertyPath.length === 0) {\n            const listener = this.addAtomicListener(entityId, eventName, callback);\n            listeners.push(listener);\n        } else if (isPrimitive) {\n            if (types.hasOwnProperty(type) && types[type].hasOwnProperty('validateSubPropertyPath')) {\n\n                if (types[type].validateSubPropertyPath(subPropertyPath, settings, validateSubPropertyPath)) {\n                    const subUri = subPropertyPath.join('/');\n                    const listener = this.addAtomicListener(entityId, eventName, callback, subUri);\n                    listeners.push(listener);\n                } else {\n                    console.error('Invalid sub property path: ' + this.getUri(entityId) + '/' + subPropertyPath.join('/') + ' for type ' + type + '.');\n                }\n            } else {\n                console.error('Invalid sub property path: ' + this.getUri(entityId) + subPropertyPath.join('/') + ' for type ' + type + '.');\n            }\n        } else {\n            const subPropertNameList = subPropertyPath[0];\n            const subPropertyNames = subPropertNameList === '*'\n                ? Object.keys(properties)\n                : subPropertNameList.split(',');\n            const subPath = subPropertyPath.slice(1);\n            for (let subPropertyName of subPropertyNames) {\n                if (subProperties.hasOwnProperty(subPropertyName)) {\n                    const subPropertyListeners = subProperties[subPropertyName].addPropertyListener(entityId, subPath, eventName, callback)\n                    listeners.push(...subPropertyListeners);\n                } else {\n                    //TODO throw error?\n                    console.error(subPropertyName + 'not available')\n                }\n            }\n        }\n        return listeners;\n    };\n\n    this.createCreator = (options, data, INPUT_submit) => {\n        const TRs = [];\n        if (types.hasOwnProperty(type) && types[type].hasOwnProperty('edit')) {\n            const uri = this.getUri('$new');\n            return render.creator(xyz, options, uri, settings, [propertyName], data, INPUT_submit);\n        } else if (!isPrimitive) {\n            for (let propertyName in subProperties) {\n                data[propertyName] = {};\n                TRs.push(...subProperties[propertyName].createCreator(options, data[propertyName], INPUT_submit));\n            }\n        } else {\n            console.error('No available rendering method for edit ' + type);\n        }\n        return TRs;\n    };\n\n    this.isAutoIncremented = () => {\n        if (isPrimitive) {\n            return type === 'id' && settings.autoIncrement === true;\n        } else {\n            for (let subPropertyName in subProperties) {\n                if (subProperties[subPropertyName].isAutoIncremented()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n\n    this.isId = () => {\n        if (types.hasOwnProperty(type) && typeof types[type].getIdFromContent === 'function') {\n            return true;\n        } else if (settings.hasOwnProperty('connector')) {\n            if (settings.connector.key === 'key' || settings.connector.key === 'basename') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    this.getIdFromContent = data => {\n        if (isPrimitive) {\n            if (types.hasOwnProperty(type) && typeof types[type].getIdFromContent === 'function') {\n                return types[type].getIdFromContent(data)\n            } else if (settings.hasOwnProperty('connector')) {\n                if (settings.connector.key === 'key' || settings.connector.key === 'basename') {\n                    return data;\n                }\n            }\n            return null;\n        } else {\n            if (typeof data !== 'object' || data === null) { //TODO is_object\n                return null;\n            }\n            for (let subPropertyName in subProperties) {\n                if (data.hasOwnProperty(subPropertyName)) {\n                    const id = subProperties[subPropertyName].getIdFromContent(data[subPropertyName]);\n                    if (id) {\n                        return id;\n                    }\n                }\n            }\n            return null;\n        }\n    };\n\n\n    this.render = (action, options, entityId) => {\n        const hasRenderMethod = types.hasOwnProperty(type) && types[type].hasOwnProperty(action);\n        if (isPrimitive || hasRenderMethod) {\n            const uri = this.getUri(entityId);\n            const content = this.getContent(entityId);\n            const status = this.getStatus(entityId);\n            const TAG = render.element(xyz, action, uri, [], status, content, settings, options);\n            return TAG;\n        } else {\n            const DIV = document.createElement('DIV');\n            for (let subPropertyName in subProperties) {\n                const TAG = subProperties[subPropertyName].render(action, options, entityId);\n                DIV.appendChild(TAG);\n            }\n            return DIV;\n        }\n    };\n};\n\n//# sourceURL=webpack://xyz/./source/entity/property.js?");

/***/ }),

/***/ "./source/entity/response.js":
/*!***********************************!*\
  !*** ./source/entity/response.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function extractContentFromNode(contentOrNode) {\n    if (contentOrNode instanceof Node) {\n        return [\n            contentOrNode.getObject(),\n            contentOrNode.getEntityId(),\n            contentOrNode.getStatus(),\n            contentOrNode.getContent(),\n            contentOrNode.getErrors(),\n            contentOrNode.getMethod()\n        ];\n    } else {\n\n\n        let entityId, method;\n        let errors = [];\n        let status = 200;\n        const content = {};\n        let subObject, subStatus, subContent, subErrors;\n        for (let propertyName in contentOrNode) {\n            [subObject, entityId, subStatus, subContent, subErrors, method] = extractContentFromNode(contentOrNode[propertyName]);\n\n            if (typeof status === 'undefined') {\n                status = subStatus;\n            } else if (status !== subStatus) {\n                status = 207;\n            }\n            errors.push.apply(errors, subErrors);\n            content[propertyName] = subContent;\n        }\n        const object = subObject.getParent();\n        return [object, entityId, status, content, errors, method]\n    }\n}\n\nfunction mergeIntoSingleNode(contentOrNode) {\n    if (contentOrNode instanceof Node) {\n        return contentOrNode;\n    } else {\n        const [object, entityId, status, content, subErrors, method] = extractContentFromNode(contentOrNode);\n        return new Node(object, entityId, status, content, subErrors, method);\n    }\n}\n\nfunction filter(content, path) {\n    if (path.length === 0) {\n        return mergeIntoSingleNode(content);\n    } else {\n        const subPath = path.slice(1);\n        const propertyNameList = path[0];\n        if (propertyNameList === '*') {\n            for (let propertyName in content) {\n                content[propertyName] = filter(content[propertyName], subPath);\n            }\n        } else {\n            const propertyNames = propertyNameList.split(',');\n            for (let propertyName in content) {\n                if (propertyNames.indexOf(propertyName) === -1) {\n                    delete content[propertyName];\n                } else {\n                    content[propertyName] = filter(content[propertyName], subPath);\n                }\n            }\n        }\n        return content;\n    }\n}\n\nfunction getSubNodeFromNode(subPath, object, entityId, status, content, errors, method) {\n    if (subPath.length === 0) { //TODO or has errors?\n        return new Node(object, entityId, status, content, errors, method)\n    } else if (content !== null && typeof content === 'object' && content.hasOwnProperty(subPath[0])) {\n        return getSubNodeFromNode(subPath.slice(1), object, entityId, status, content[subPath[0]], errors, method);\n    } else {\n        return null; // unmodified\n    }\n}\n\nfunction Node(object, entityId, status_, content_, errors_, method_) {\n\n    const status = status_;\n    const content = content_;\n    const errors = errors_;\n    const method = method_;\n    /*\n    TODO object can be empty  maybe need to fix that?\n    this.hasSetting = settingName => object.getSettings().hasOwnProperty(settingName);\n    this.getSetting = settingName => object.getSettings()[settingName];\n    this.getSettings = () => object.getSettings();*/\n    this.getObject = () => object; //TODO need private\n    this.getEntityId = () => entityId;\n    this.getMethod = () => method;\n    this.getStatus = () => status;\n    this.getContent = () => content;\n    this.getErrors = () => errors;\n    this.render = (action, options) => object.render(action, options, entityId);\n    this.getSubNode = subPath => getSubNodeFromNode(subPath, object, entityId, status, content, errors);\n}\n\nfunction getSubNode(object, entityId, node, subPath) {\n    if (subPath.length === 0) { //TODO or has errors?\n        return node;\n    } else if (node instanceof Node) {\n        return node.getSubNode(subPath);\n    } else if (node !== null && typeof node === 'object' && node.hasOwnProperty(subPath[0])) {\n        return getSubNode(object, entityId, node[subPath[0]], subPath.slice(1));\n    } else {\n        return null; // unmodified\n    }\n}\n\nexports.Node = Node;\nexports.filter = filter;\nexports.getSubNode = getSubNode;\n\n//# sourceURL=webpack://xyz/./source/entity/response.js?");

/***/ }),

/***/ "./source/entity/state.js":
/*!********************************!*\
  !*** ./source/entity/state.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function State(method_) {\n    // let status;\n    let method = method_;\n    let created = false;\n    let changed = false;\n    let removed = method === 'DELETE';\n    let error = false;\n    const errors = [];\n\n    let subStatus;\n    this.getMethod = () => method;\n\n    this.getParentState = () => {\n        const parentState = new State(method);\n        if (changed || created || removed) parentState.setChanged();\n        for (let error of errors) {\n            parentState.setError(error.status, error.message);\n        }\n        return parentState;\n    };\n\n    this.setCreated = () => {\n        created = true;\n    };\n    this.setChanged = () => {\n        changed = true;\n    };\n    this.setRemoved = () => {\n        removed = true;\n    };\n    this.setError = (status, message) => {\n        error = true;\n        errors.push({status, message})\n    };\n    this.isChanged = () => changed && !created;\n    this.isRemoved = () => removed;\n    this.isCreated = () => created;\n    this.isError = () => error;\n\n    this.getStatus = () => {\n        // TODO mixed?\n        if (this.isError()) return 404; //TODO support more errors etc\n        if (this.isCreated()) return 201;\n        if (this.isChanged()) return 201;\n        if (this.isRemoved()) return 410;\n        return 304;\n    };\n\n    this.addSubState = subState => {\n        const newSubStatus = subState.getStatus();\n\n        if (typeof subStatus === 'undefined') {\n            subStatus = newSubStatus;\n        } else if (newSubStatus !== subStatus) {\n            subStatus = 207;\n        }\n        const subMethod = subState.getMethod();\n        if (typeof method === 'undefined') {\n            method = subMethod;\n        } else if (method !== subMethod) {\n            throw new Error('A state cannot have multiple methods');\n        }\n        if (subState.isChanged() || subState.isRemoved() || subState.isCreated()) {\n            changed = true;\n        }\n    };\n}\n\nexports.State = State;\n\n//# sourceURL=webpack://xyz/./source/entity/state.js?");

/***/ }),

/***/ "./source/main.js":
/*!************************!*\
  !*** ./source/main.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const entity = __webpack_require__(/*! ./entity/entity.js */ \"./source/entity/entity.js\");\nconst request = __webpack_require__(/*! ./request/request.js */ \"./source/request/request.js\");\nconst web = __webpack_require__(/*! ./web/web.js */ \"./source/web/web.js\");\nconst on = __webpack_require__(/*! ./request/on */ \"./source/request/on.js\").on;\nconst ui = __webpack_require__(/*! ./render/ui */ \"./source/render/ui.js\").ui;\nconst variables = __webpack_require__(/*! ./variables/variables */ \"./source/variables/variables.js\");\n\nfunction XYZ() {\n    const entityClasses = {};\n\n    this.hasVariable = variableName => variables.hasVariable(variableName);\n    this.getVariable = (variableName, fallback) => variables.getVariable(variableName, fallback);\n    this.clearVariable = variableName => variables.clearVariable(variableName);\n    this.setVariable = (variableName, value) => variables.setVariable(variableName, value);\n    this.setVariables = variableObject => variables.setVariables(variableObject);\n    this.setVariables(web.getQueryParameters());\n\n    this.isAutoIncremented = entityClassName => entity.isAutoIncremented(entityClasses, entityClassName);\n\n    this.on = (uri, eventName, callback) => on(this, entityClasses, uri, eventName, callback);\n\n    this.ui = (options, WRAPPER) => ui(this, entityClasses, options, WRAPPER);\n\n    this.get = (uri, callback) => request.get(this, entityClasses, uri, callback);\n    this.head = (uri) => request.head(entityClasses, uri);\n    this.post = (uri, content) => request.post(entityClasses, uri, content);\n    this.patch = (uri, content) => request.patch(entityClasses, uri, content);\n    this.put = (uri, content) => request.put(entityClasses, uri, content);\n    this.delete = uri => request.delete(entityClasses, uri);\n}\n\nconst xyz = new XYZ();\nexports.ui = xyz.ui;\nexports.on = xyz.on;\n\n//TODO get(Variable)\n//TODO set(Variable(s))\n//TODO globals()\n\n\n\n//# sourceURL=webpack://xyz/./source/main.js?");

/***/ }),

/***/ "./source/render/create.js":
/*!*********************************!*\
  !*** ./source/render/create.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\nuri\nonSubmit\nTODO onFailure\n\n */\n\nconst request = __webpack_require__(/*! ../request/request.js */ \"./source/request/request.js\");\nconst uriTools = __webpack_require__(/*! ../uri/uri.js */ \"./source/uri/uri.js\");\n\nconst renderUiCreate = (xyz, entityClasses, options, TAG) => {\n    const uri = options.uri;\n    request.retrieveMeta(xyz, entityClasses, uri, () => {\n        const entityClassName = uriTools.pathFromUri(uri)[0];\n        const entityClass = entityClasses[entityClassName];\n        const data = {};\n        const INPUT_submit = document.createElement('INPUT');\n        INPUT_submit.type = 'submit';\n        INPUT_submit.value = options.createButtonText || 'Create ' + entityClassName;\n        INPUT_submit.validUris = {};\n        INPUT_submit.onclick = () => {\n            if (entityClass.isAutoIncremented()) {\n                xyz.post(uri, {[entityClassName]: {'new': data}},);\n            } else {\n                const entityId = entityClass.getIdFromContent(data);\n                xyz.put(uri + '/' + entityId, {[entityClassName]: {[entityId]: data}},);\n            }\n            if (typeof options.onSubmit === 'function') {\n                options.onSubmit(data);\n            }\n        };\n        const TABLE = entityClass.createCreator(options, data, INPUT_submit);\n        TAG.appendChild(TABLE);\n        TAG.appendChild(INPUT_submit);\n    });\n    return TAG;\n};\n\nexports.renderUiCreate = renderUiCreate;\n\n//# sourceURL=webpack://xyz/./source/render/create.js?");

/***/ }),

/***/ "./source/render/display.js":
/*!**********************************!*\
  !*** ./source/render/display.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const displays = __webpack_require__(/*! ../../build/displays */ \"./build/displays.js\");\nconst uriTools = __webpack_require__(/*! ../uri/uri.js */ \"./source/uri/uri.js\");\nconst response = __webpack_require__(/*! ../entity/response.js */ \"./source/entity/response.js\");\nconst variables = __webpack_require__(/*! ../variables/variables.js */ \"./source/variables/variables.js\");\n\nconst DEFAULT_ACTION = 'view';\nconst DEFAULT_DISPLAYNAME = 'item';\n\nfunction DisplayParameters(xyz, action, options, WRAPPER, entityClassName, entityId, content, uri) {\n    this.getRequestUri = () => uri;\n    this.getAction = () => action;\n    this.getOptions = () => options;\n    this.getOption = optionName => options[optionName];\n    this.getWRAPPER = () => WRAPPER;\n    this.getEntityClassName = () => entityClassName;\n    this.getEntityId = () => entityId;\n\n    this.getContent = () => content;\n    this.xyz = xyz; // TODO encapsulate\n}\n\nconst displayListenersPerWrapper = new Map();\n\nconst uiElementWaitingForData = (display, displayParameters) => {\n    const WRAPPER = displayParameters.getWRAPPER();\n    WRAPPER.classList.add('xyz-waiting-for-data');\n    if (display && display.hasOwnProperty('waitingForData')) {\n        display.waitingForData(displayParameters);\n    } else {\n        WRAPPER.innerHTML = 'Waiting for user data...';\n    }\n};\n\nconst uiElementWaitingForInput = (display, displayParameters) => {\n    const WRAPPER = displayParameters.getWRAPPER();\n    WRAPPER.classList.add('xyz-waiting-for-input');\n    if (display && display.hasOwnProperty('waitingForInput')) {\n        display.waitingForInput(displayParameters);\n    } else {\n        WRAPPER.innerHTML = 'Waiting for user input...';\n    }\n};\n\nconst uiElementEmpty = (display, displayParameters) => {\n    const WRAPPER = displayParameters.getWRAPPER();\n    WRAPPER.classList.remove('xyz-waiting-for-input');\n    WRAPPER.classList.add('xyz-empty');\n    if (display && display.hasOwnProperty('empty')) {\n        display.empty(displayParameters);\n    } else {\n        WRAPPER.innerHTML = 'Empty';\n    }\n};\n\nconst uiElementFirst = (display, displayParameters) => {\n    const WRAPPER = displayParameters.getWRAPPER();\n    if (WRAPPER.classList.contains('xyz-empty')) {\n        WRAPPER.classList.remove('xyz-empty');\n        if (display && display.hasOwnProperty('first')) {\n            display.first(displayParameters);\n        } else {\n            WRAPPER.innerHTML = '';\n        }\n    }\n};\n\nconst uiElementEntity = (display, displayParameters) => {\n    if (display && display.hasOwnProperty('entity')) {\n        display.entity(displayParameters);\n    } else {\n        //TODO a default way of handeling stuff\n    }\n};\n\nconst uiElementRemove = (display, displayParameters) => {\n    if (display && display.hasOwnProperty('remove')) {\n        display.remove(displayParameters);\n    } else {\n        //TODO a default way of handeling stuff\n    }\n};\n\nconst renderDisplay = (xyz, uri, options, WRAPPER) => (entityClassName, entityId, node, eventName) => {\n    const displayName = options.display || DEFAULT_DISPLAYNAME;\n    const display = displays[displayName];\n    const action = options.action || DEFAULT_ACTION;\n    const path = uriTools.pathFromUri(uri);\n    node = response.filter(node, path.slice(2)); // filter the content that was not requested\n    const displayParameters = new DisplayParameters(xyz, action, options, WRAPPER, entityClassName, entityId, node, uri);\n    uiElementFirst(display, displayParameters);\n    uiElementEntity(display, displayParameters);\n};\n\nconst removeDisplay = (xyz, uri, options, WRAPPER) => (entityClassName, entityId, node, eventName) => {\n    const displayName = options.display || DEFAULT_DISPLAYNAME;\n    const display = displays[displayName];\n    const action = options.action || DEFAULT_ACTION;\n    const displayParameters = new DisplayParameters(xyz, action, options, WRAPPER, entityClassName, entityId, node, uri);\n    uiElementRemove(display, displayParameters)\n};\n\nconst addListeners = (xyz, uri, options, WRAPPER) => {\n    if (displayListenersPerWrapper.has(WRAPPER)) {\n        const listeners = displayListenersPerWrapper.get(WRAPPER);\n        listeners.forEach(listener => listener.stop());\n    }\n    // FIXME dirty way of cleaning up all listeners by garbage collection\n    // the problems lies with ui elements created by references,\n    // those are drawn and then redraw with different wrappers when the base is updated\n    //   e.g. BASE_WRAPPER->REF_WRAPPER1 ->  BASE_WRAPPER->REF_WRAPPER2\n    //  BASE_WRAPPER is handled okay by the displayListenersPerWrapper.has(WRAPPER) above\n    // but REF_WRAPPER1  not\n\n    displayListenersPerWrapper.forEach((listeners, WRAPPER) => {\n        if (!document.body.contains(WRAPPER)) {\n            listeners.forEach(listener => listener.stop());\n            displayListenersPerWrapper.delete(WRAPPER);\n        }\n    });\n\n    const baseUri = uriTools.getBaseUri(uri);\n    const createdListeners = xyz.on(baseUri, 'created', renderDisplay(xyz, uri, options, WRAPPER));\n    const removedListeners = xyz.on(baseUri, 'removed', removeDisplay(xyz, uri, options, WRAPPER));\n\n    displayListenersPerWrapper.set(WRAPPER, [...createdListeners, ...removedListeners]);\n};\n\nconst renderUiElement = (xyz, options, WRAPPER) => {\n    const uri = options.uri;\n    const displayName = options.display || DEFAULT_DISPLAYNAME;\n    if (!displays.hasOwnProperty(displayName)) throw new Error('Unrecognized displayName.');\n\n    const display = displays[displayName]; //TODO check?\n    const action = options.action || DEFAULT_ACTION;\n\n    const path = uri.substr(1).split('/'); //TODO better\n    const entityId = path[1] || '*';\n    const entityClass = path[0];\n    const displayParameters = new DisplayParameters(xyz, action, options, WRAPPER, entityClass, entityId, null, uri);\n\n    uiElementWaitingForData(display, displayParameters);\n\n    variables.registerUri(uri, uri => {\n            //TODO this can be called multiple times on variable changes,\n            uiElementEmpty(display, displayParameters);\n            xyz.get(uri, node => { //TODO this should be handled by having an available instead of created listener\n                WRAPPER.classList.remove('xyz-waiting-for-data');\n\n                for (let entityClassName in node) {\n                    for (let entityId in node[entityClassName]) {\n                        renderDisplay(xyz, uri, options, WRAPPER)(entityClassName, entityId, node[entityClassName][entityId]);\n                    }\n                }\n                addListeners(xyz, uri, options, WRAPPER);\n            });\n        },\n        () => uiElementWaitingForInput(display, displayParameters)\n    );\n};\n\nexports.renderUiElement = renderUiElement;\n\n//# sourceURL=webpack://xyz/./source/render/display.js?");

/***/ }),

/***/ "./source/render/item.js":
/*!*******************************!*\
  !*** ./source/render/item.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const types = __webpack_require__(/*! ../../build/types.js */ \"./build/types.js\");\nconst response = __webpack_require__(/*! ../entity/response.js */ \"./source/entity/response.js\");\nconst json = __webpack_require__(/*! ../web/json.js */ \"./source/web/json.js\");\nconst render = __webpack_require__(/*! ./render */ \"./source/render/render.js\");\nconst DEFAULT_ACTION = 'view';\n// onChange = (content, [additionalSubPropertyPath]) => {...}\n// onDelete = (content, [additionalSubPropertyPath]) => {...}\n\nfunction Item(xyz, baseUri, subPropertyPath, status, content, settings, options, onChange, onDelete, creatorData) {\n    const callbacks = [];\n\n    this.getUri = () => baseUri;\n    this.getStatus = () => status;\n    this.getContent = () => content;\n    this.getOptions = () => options;\n    this.getAction = () => options.hasOwnProperty('action') ? options.action : DEFAULT_ACTION;\n    this.getOption = optionName => options[optionName];\n    this.hasOption = optionName => options.hasOwnProperty(optionName);\n    this.getSettings = () => settings;\n    this.getSetting = settingName => settings[settingName];\n    this.hasSetting = settingName => settings.hasOwnProperty(settingName);\n\n    this.patch = (newContent, additionalSubPropertyPath) => {\n        additionalSubPropertyPath = additionalSubPropertyPath || [];\n        const data = json.set({}, additionalSubPropertyPath, newContent);\n        //TODO these callbacks are done without validation\n        const node = new response.Node({}, '?', 200, data, [], 'PATCH'); // not defining object and entityId\n        for (let callback of callbacks) {\n            callback(node);\n        }\n        // note: adding the subPropertyPath and additionalSubPropertyPath is handled by the onChange function\n        (options.onChange || onChange)(newContent, additionalSubPropertyPath);\n    };\n\n    this.delete = subPropertyPath => {\n        //TODO call callbacks\n        (options.onDelete || onDelete)(subPropertyPath);\n    };\n\n    this.renderSubElement = (action, additionalSubPropertyPath, status, content, settings, options_) => {\n        if (options.display === 'create') {\n            const TABLE = document.createElement('TABLE');\n            TABLE.style.display = 'inline-block';\n            try {\n                json.set(creatorData, subPropertyPath.concat(additionalSubPropertyPath), content);\n            } catch (e) {\n                console.error('Item.renderSubElement json.set failed', e);\n            }\n            const TRs = render.creator(xyz, options_, baseUri, settings, subPropertyPath.concat(additionalSubPropertyPath), creatorData);\n            for (let TR of TRs) {\n                TABLE.appendChild(TR);\n            }\n            return TABLE;\n        } else {\n            return render.element(xyz, action, baseUri, subPropertyPath.concat(additionalSubPropertyPath), status, content, settings, options_);\n        }\n    };\n\n    this.renderCreator = (options, uri, settings, subPropertyPath, newCreatorData, INPUT_submit) => render.creator(xyz, options, uri, settings, subPropertyPath, newCreatorData, INPUT_submit);\n\n    this.ui = xyz.ui;\n\n    // callback = (status,content)=>{...}\n    this.onChange = callback => {\n        if (typeof callback !== 'function') throw new TypeError(\"callback is not a function.\");\n\n        callbacks.push(callback);\n        if (options.display !== 'create') {\n            const fullUri = subPropertyPath.length > 0\n                ? baseUri + '/' + subPropertyPath.join('/')\n                : baseUri;\n            xyz.on(fullUri, 'changed', (entityClass, entityId, node, eventName) => callback(node));\n            // TODO unregister these listeners somehow\n        }\n    };\n    this.validateContent = (content_, settings_) => {\n        content_ = typeof content_ === 'undefined' ? content : content_;\n        settings_ = typeof settings_ === 'object' ? settings_ : settings;\n        const typeName = settings_.type || 'string';\n        if (!types.hasOwnProperty(typeName)) return false;\n        if (!types[typeName].hasOwnProperty('validateContent')) return false;\n        const item = new Item(xyz, baseUri, subPropertyPath, status, content_, settings_, options);\n        return types[typeName].validateContent(item);\n    };\n}\n\nexports.constructor = Item;\n\n//# sourceURL=webpack://xyz/./source/render/item.js?");

/***/ }),

/***/ "./source/render/login.js":
/*!********************************!*\
  !*** ./source/render/login.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\noptions.signUpButtonText || 'Create account',\noptions.loginButtonText || 'Log in',\n */\n\nconst renderUiLogin = (xyz, options, WRAPPER) => {\n    WRAPPER.classList.add('xyz-login');\n    const A_signin = document.createElement('A');\n    A_signin.innerText = 'sign in';\n    const A_signup = document.createElement('A');\n    A_signup.innerText = 'sign up';\n    WRAPPER.appendChild(A_signin);\n    WRAPPER.appendChild(A_signup);\n\n    const DIV_listSession = document.createElement('SPAN');\n\n    xyz.ui({\n        style: 'display:none;',\n        uri: options.uri,\n        display: 'list',\n        showHeader: false\n    }, DIV_listSession);\n    WRAPPER.appendChild(DIV_listSession);\n\n    const A_logout = document.createElement('A');\n    A_logout.innerText = 'log out';\n    A_logout.onclick = () => {\n        xyz.delete(options.uri);\n    };\n    A_logout.style.display = 'none';\n\n    WRAPPER.appendChild(A_logout);\n\n    const DIV_createSession = document.createElement('DIV');\n\n    xyz.ui({\n        style: 'display:none;',\n        uri: options.uri,\n        display: 'create',\n        createButtonText: options.loginButtonText || 'Log in',\n        onSubmit: data => {\n            DIV_listSession.style.display = 'inline-block';\n            DIV_createSession.style.display = 'none';\n            A_signin.style.display = 'none';\n            A_signup.style.display = 'none';\n            A_logout.style.display = 'inline-block';\n        }\n    }, DIV_createSession);\n\n    xyz.on('/session/*', 'created', (entityClassName, entityId, subNode, eventName) => {\n        DIV_listSession.style.display = 'inline-block';\n        DIV_createSession.style.display = 'none';\n        A_signin.style.display = 'none';\n        A_signup.style.display = 'none';\n        A_logout.style.display = 'inline-block';\n    });\n    xyz.on('/session/*', 'removed', (entityClassName, entityId, subNode, eventName) => {\n        A_signin.style.display = 'inline-block';\n        A_signup.style.display = 'inline-block';\n        A_logout.style.display = 'none';\n        //TODO only if all sessions gone\n        //TODO show logout message \"You've been successfully logged out.\"\n        DIV_listSession.style.display = 'none';\n    });\n    WRAPPER.appendChild(DIV_createSession);\n\n    const DIV_account = document.createElement('DIV');\n    xyz.ui({\n        uri: '/account',\n        style: 'display:none;',\n        display: 'create',\n        createButtonText: options.signUpButtonText || 'Create account',\n        onSubmit: data => {\n            //TODO Message \"account x has been created\"\n            //TODO use date to fill in username\n            //console.log('create Account', data);\n            DIV_createSession.style.display = 'block';\n            DIV_account.style.display = 'none';\n        }\n    }, DIV_account); //TODO retrieve /account from session metadata?\n    WRAPPER.appendChild(DIV_account);\n\n    A_signin.onclick = () => {\n        DIV_createSession.style.display = 'block';\n        DIV_account.style.display = 'none';\n    };\n    A_signup.onclick = () => {\n        DIV_account.style.display = 'block';\n        DIV_createSession.style.display = 'none';\n    };\n};\n\nexports.renderUiLogin = renderUiLogin;\n\n//# sourceURL=webpack://xyz/./source/render/login.js?");

/***/ }),

/***/ "./source/render/render.js":
/*!*********************************!*\
  !*** ./source/render/render.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const types = __webpack_require__(/*! ../../build/types.js */ \"./build/types.js\");\nconst uriTools = __webpack_require__(/*! ../uri/uri.js */ \"./source/uri/uri.js\");\nconst Item = __webpack_require__(/*! ./item.js */ \"./source/render/item.js\").constructor;\nconst json = __webpack_require__(/*! ../web/json.js */ \"./source/web/json.js\");\n\nconst DEFAULT_TYPE = 'string';\n\nfunction createTmpContentToValidate(data, content, subPropertyPath, additionalSubPropertyPath) {\n    /*  fix for patching  sub data\n    suppose current your current data data = {myArray: ['value1']}\n    and your patching a (content='value2', additionalSubPropertyPath=[1])\n    then construct tmpContent {myArray: ['value1','value2']} to validate the contents\n    */\n    const mainContent = json.get(data, subPropertyPath);\n    let tmpContent = JSON.parse(JSON.stringify(mainContent));\n    tmpContent = json.set(tmpContent, additionalSubPropertyPath, content);\n    return tmpContent;\n}\n\nfunction element(xyz, action, uri, subPropertyPath, status, content, settings, options) {\n    const typeName = settings.type || DEFAULT_TYPE;\n    if (!types.hasOwnProperty(typeName)) {\n        console.error('problem1');\n        return null;\n    }\n    const type = types[typeName];\n    if (type.hasOwnProperty(action)) {\n        let onChange, onDelete;\n        let TAG;\n        if (action === 'edit') {\n            onChange = (subContent, additionalSubPropertyPath) => {\n\n                const tmpContentToValidate = createTmpContentToValidate(content, subContent, subPropertyPath, additionalSubPropertyPath);\n\n                const item = new Item(xyz, uri, subPropertyPath, status, tmpContentToValidate, settings, options, onChange, onDelete);\n                if (item.validateContent()) {\n                    additionalSubPropertyPath = subPropertyPath.concat(additionalSubPropertyPath);\n                    const subUri = typeof additionalSubPropertyPath === 'undefined' ? '' : ('/' + additionalSubPropertyPath.join('/'));\n                    TAG.classList.remove('xyz-invalid-content');\n                    xyz.patch(uri + subUri, uriTools.wrapContent(uri + subUri, subContent));\n                } else {\n                    TAG.classList.add('xyz-invalid-content');\n                }\n            };\n            onDelete = subUri => {\n                //TODO use subPropertyPath\n                subUri = typeof subUri === 'undefined' ? '' : ('/' + subUri);\n                xyz.delete(uri + subUri);\n            };\n        }\n        const item = new Item(xyz, uri, subPropertyPath, status, content, settings, options, onChange, onDelete);\n        TAG = type[action](item);\n        TAG.classList.add(`xyz-status-${status}`);\n        return TAG;\n    } else if (settings.hasOwnProperty('signature')) { // create editor from signature view\n        //TODO check if content if object\n        //TODO check if settings.signature is object\n        const DIV = document.createElement('DIV');\n        DIV.classList.add(`xyz-status-${status}`);\n        for (let subPropertyName in settings.signature) {\n            const subSettings = settings.signature[subPropertyName];\n            const subContent = content[subPropertyName];\n            const subType = subSettings.type;\n            const subUri = uri + '/' + subPropertyName;\n            const TAG = element(xyz, subType, action, subUri, subPropertyPath.concat([subPropertyName]), status, subContent, subSettings, options);\n            TAG.classList.add(`xyz-status-${status}`);\n            DIV.appendChild(TAG);\n        }\n        return DIV;\n    } else {\n        //TODO something default and/or error\n        console.error('problem2');\n        return null;\n    }\n}\n\nfunction creator(xyz, options, uri, settings, subPropertyPath, data, INPUT_submit) {\n    const typeName = settings.type || DEFAULT_TYPE;\n    if (!types.hasOwnProperty(typeName)) {\n        console.error('problem1'); //TODO return a TR containing the error\n        return [];\n    }\n\n    const entityClassName = uriTools.pathFromUri(uri)[0];\n    if (typeName === 'id' && xyz.isAutoIncremented(entityClassName)) {\n        return [];\n    }\n    const type = types[typeName];\n\n    if (!type.hasOwnProperty('edit')) {\n        console.error('problem1');\n        return []; //TODO return a TR containing the error\n    }\n    const TRs = [];\n    // TODO html label for gebruiken\n    const TR = document.createElement('TR');\n    if (options.showLabels !== false) {\n        const TD_label = document.createElement('TD');\n        TD_label.innerText = typeof options.label === 'string'\n            ? options.label\n            : subPropertyPath[0];\n        TR.appendChild(TD_label);\n    }\n    let TAG;\n\n    const validate = item => {\n\n        const uri = item.getUri();\n        if (item.validateContent()) {\n            TAG.classList.remove('xyz-invalid-content');\n            if (INPUT_submit) {\n                INPUT_submit.validUris[uri] = true;\n                const disabled = Object.values(INPUT_submit.validUris).reduce((disabled, valid) => disabled || !valid, false);\n                if (!disabled) INPUT_submit.removeAttribute('disabled');\n            }\n            return true;\n        } else {\n            TAG.classList.add('xyz-invalid-content');\n            if (INPUT_submit) {\n                INPUT_submit.validUris[uri] = false;\n                INPUT_submit.setAttribute('disabled', 'true');\n            }\n            return false;\n        }\n    };\n\n    let onChange, onDelete;\n    onChange = (content, additionalSubPropertyPath) => {\n        const tmpContentToValidate = createTmpContentToValidate(data, content, subPropertyPath, additionalSubPropertyPath);\n        const item = new Item(xyz, uri, subPropertyPath, 200, tmpContentToValidate, settings, options, onChange, onDelete, data);\n        if (validate(item)) {\n            const keyPath = typeof additionalSubPropertyPath === 'undefined'\n                ? subPropertyPath\n                : subPropertyPath.concat(additionalSubPropertyPath);\n            json.set(data, keyPath, content);\n        }\n    };\n    onDelete = subUri => {\n        //TODO rewrite for subPropertyPath\n        const keyPath = typeof subUri === 'undefined' ?\n            [subPropertyPath] :\n            [...subPropertyPath, ...subUri.split('/')];\n        json.unset(data, keyPath);\n    };\n\n    let content;\n    try {\n        content = json.get(data, subPropertyPath);\n    } catch (e) {\n        content = null;\n    }\n    if (content === null) {\n        if (settings.hasOwnProperty('default')) {\n            content = settings.default;\n        } else if (type.json.hasOwnProperty('default') && type.json.default.hasOwnProperty('default')) {\n            // does the default have a default\n            content = type.json.default.default;\n        }\n        try {\n            json.set(data, subPropertyPath, content);\n        } catch (e) {\n            console.error('render.creator json.set failed', e);\n        }\n    }\n\n    const item = new Item(xyz, uri, subPropertyPath, 200, content, settings, options, onChange, onDelete, data);\n    TAG = type.edit(item);\n    validate(item);\n    // TODO add id from options (also for label for)\n    // TODO add class from options\n    const TD_content = document.createElement('TD');\n    TD_content.appendChild(TAG);\n    TR.appendChild(TD_content);\n    TRs.push(TR);\n    return TRs;\n}\n\nexports.element = element;\nexports.creator = creator;\n\n\n//# sourceURL=webpack://xyz/./source/render/render.js?");

/***/ }),

/***/ "./source/render/ui.js":
/*!*****************************!*\
  !*** ./source/render/ui.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const renderUiCreate = __webpack_require__(/*! ./create */ \"./source/render/create.js\").renderUiCreate;\nconst renderUiLogin = __webpack_require__(/*! ./login */ \"./source/render/login.js\").renderUiLogin;\nconst renderUiElement = __webpack_require__(/*! ./display */ \"./source/render/display.js\").renderUiElement;\n\nconst DEFAULT_TAG = 'DIV';\n\nconst ui = (xyz, entityClasses, options, WRAPPER) => {\n    options = options || {};\n    for (let optionName in options) {\n        if (options[optionName] === 'false') options[optionName] = false;\n        if (options[optionName] === 'true') options[optionName] = true;\n    }\n    if (options.display === 'edit') {\n        options.action = 'edit';\n        options.display = 'item';\n    }\n    if (options.display === 'delete') {\n        options.action = 'view';\n        options.display = 'item';\n        options.showDeleteButton = true;\n    }\n    let SCRIPT;\n    if (typeof WRAPPER === 'undefined') {\n        const tag = options.tag || DEFAULT_TAG;\n        WRAPPER = document.createElement(tag);\n        SCRIPT = document.currentScript;\n    }\n    if (options.id) WRAPPER.id = options.id;\n    if (options.class) WRAPPER.className += ' ' + options.class;\n    if (options.style) WRAPPER.style = options.style;\n\n    if (SCRIPT) {\n        SCRIPT.parentNode.insertBefore(WRAPPER, SCRIPT);\n        SCRIPT.parentNode.removeChild(SCRIPT);\n    }\n    if (options.display === 'create') {\n        renderUiCreate(xyz, entityClasses, options, WRAPPER);\n    } else if (options.display === 'login') {\n        renderUiLogin(xyz, options, WRAPPER);\n    } else {\n        renderUiElement(xyz, options, WRAPPER);\n    }\n    return WRAPPER;\n};\n\nexports.ui = ui;\n\n//# sourceURL=webpack://xyz/./source/render/ui.js?");

/***/ }),

/***/ "./source/request/input.js":
/*!*********************************!*\
  !*** ./source/request/input.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const json = __webpack_require__(/*! ../web/json */ \"./source/web/json.js\");\nconst State = __webpack_require__(/*! ../entity/state.js */ \"./source/entity/state.js\").State;\n\nfunction changed(a, b) {\n    switch (typeof a) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return a !== b;\n        case 'undefined':\n            return typeof b !== 'undefined';\n        case 'function':\n            return false;\n        case 'object':\n            if (a === null) {\n                return b !== null;\n            } else if (typeof b !== 'object' || b === null) {\n                return false\n            } else {\n                for (let key in a) {\n                    if (b.hasOwnProperty(key)) {\n                        if (changed(a[key], b[key])) return true\n                    } else {\n                        return true;\n                    }\n                }\n                for (let key in b) {\n                    if (!a.hasOwnProperty(key)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n    }\n}\n\n\nexports.handlePrimitive = (element, contents, statusses) => (path, method, entityId, responseStatus, responseContent, requestContent) => {\n    if (typeof entityId !== 'string') throw new TypeError('entityId not a string.');\n    if (typeof responseStatus !== 'number') throw new TypeError('responseStatus not a number.');\n\n    const state = new State(method);\n    if (contents.hasOwnProperty(entityId)) {\n        const prevPropertyContent = contents[entityId];\n        switch (responseStatus) {\n            case 200:\n                if ((method === 'PATCH' || method === 'PUT' || method === 'POST') && responseContent === null) {\n                    const content = json.get(responseContent, path, null);\n                    contents[entityId] = json.set(contents[entityId], path, content, null);\n                } else if (method === 'GET') {\n                    contents[entityId] = responseContent;\n                } else if (method === 'DELETE') {\n//                    state.setChanged();\n\n                    json.unset(contents[entityId], path, null);\n                }\n                //console.log('UPDATE', responseContent, requestContent, path);\n\n                /*\n                if (changed(prevPropertyContent, responseContent) && typeof responseContent !== 'undefined') {\n                    state.setChanged();\n                }\n\n                    contents[entityId] = requestContent;\n                } else {\n                    contents[entityId] = responseContent;\n                }*/\n                break;\n            case 404:\n                //TODO use message frop source if available\n                //TODO check if error is new eg compare with current error in errors\n                state.setError(404, 'Not found');\n                break;\n            default:\n                //state.setError(); // TODO compare with current error in errors\n                throw new Error('Unsupported status ' + responseStatus);\n        }\n    } else { // if 200 then changed else error\n        switch (responseStatus) {\n            case 200:\n                if (typeof responseContent !== 'undefined') {\n                    state.setChanged(); // TODO if new array value then Created\n                    // for post and put methods, if no responseContent is returned, use the the requestContent instead\n                    if ((method === 'PUT' || method === 'POST' || method === 'PATCH') && responseContent === null) {\n                        contents[entityId] = requestContent;\n                    } else {\n                        contents[entityId] = responseContent;\n                    }\n                }\n                break;\n            case 403:\n                //TODO use message frop source if available\n                // TODO check if error is new eg compare with current error in errors\n                state.setError(403, 'Forbidden');\n                break;\n            case 404:\n                //TODO use message frop source if available\n                // TODO check if error is new eg compare with current error in errors\n                state.setError(404, 'Not found');\n                break;\n            default:\n                //state.setError(); TODO compare with current error in errors\n                throw new Error('Unsupported status ' + responseStatus);\n        }\n    }\n    statusses[entityId] = state.getStatus();\n    element.callListeners(state, entityId);\n    return state;\n};\n\nexports.handle = (element, statusses, subProperties, entities) => (path, method, entityId, responseStatus, responseContent, requestContent) => {\n    if (typeof entityId !== 'string') throw new TypeError('entityId not a string.');\n    if (typeof responseStatus !== 'number') throw new TypeError('responseStatus not a number.');\n\n    const state = new State(method);\n\n    if (entities) { // only for entity\n        if (!entities.hasOwnProperty(entityId)) {\n            state.setCreated();\n        }\n        entities[entityId] = true; //TODO hier moet meer mee\n    }\n\n    if (responseStatus === 207) {\n        for (let subPropertyName in subProperties) {\n            const subProperty207Wrapper = responseContent[subPropertyName];\n            if (subProperty207Wrapper === null || typeof subProperty207Wrapper !== 'object'\n                || !subProperty207Wrapper.hasOwnProperty('status')\n                || !subProperty207Wrapper.hasOwnProperty('content')\n            ) {\n                //TODO reponse is in error\n                console.error('error response in wrong format');\n            } else {\n                const subProperty = subProperties[subPropertyName];\n                const subStatus = subProperty207Wrapper.status;\n                const subResponseContent = subProperty207Wrapper.content;\n                const subRequestContent = typeof requestContent === 'object' && requestContent !== null ? requestContent[subPropertyName] : null;\n                const subPath = path.slice(1);\n                const subState = subProperty.handleInput(subPath, method, entityId, subStatus, subResponseContent, subRequestContent);\n                state.addSubState(subState);\n            }\n        }\n    } else {\n        for (let subPropertyName in subProperties) {\n            const subProperty = subProperties[subPropertyName];\n            const subResponseContent = (responseContent === null || typeof responseContent !== 'object')\n                ? null\n                : responseContent[subPropertyName];\n            const subRequestContent = typeof requestContent === 'object' && requestContent !== null ? requestContent[subPropertyName] : null;\n            const subPath = path.slice(1);\n            const subState = subProperty.handleInput(subPath, method, entityId, responseStatus, subResponseContent, subRequestContent);\n            state.addSubState(subState);\n        }\n    }\n    statusses[entityId] = state.getStatus();\n    element.callListeners(state, entityId);\n    return state;\n};\n\n//# sourceURL=webpack://xyz/./source/request/input.js?");

/***/ }),

/***/ "./source/request/on.js":
/*!******************************!*\
  !*** ./source/request/on.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const request = __webpack_require__(/*! ./request.js */ \"./source/request/request.js\");\nconst uriTools = __webpack_require__(/*! ../uri/uri.js */ \"./source/uri/uri.js\");\n\nconst on = (xyz, entityClasses, uri, eventName, callback) => {\n    //TODO check type, callback and uri\n    const listeners = [];\n    const entityClassNames = uriTools.getEntityClassNames(uri, entityClasses);\n    request.retrieveMeta(xyz, entityClasses, uri, ()=>{\n        const subPath = uriTools.pathFromUri(uri).slice(1);\n        for (let entityClassName of entityClassNames) {\n            if (entityClasses.hasOwnProperty(entityClassName)) {\n                const entityClassListeners = entityClasses[entityClassName].addListener(subPath, eventName, callback);\n                listeners.push(...entityClassListeners);\n            } else {\n                // TODO callback 404 on listener\n                // if eventName = 'error' or 404  callback(entityClassName);\n            }\n        }\n    });\n    return listeners;\n};\n\nexports.on = on;\n\n//# sourceURL=webpack://xyz/./source/request/on.js?");

/***/ }),

/***/ "./source/request/request.js":
/*!***********************************!*\
  !*** ./source/request/request.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const entity = __webpack_require__(/*! ../entity/entity.js */ \"./source/entity/entity.js\");\nconst addQueryString = __webpack_require__(/*! ../uri/uri.js */ \"./source/uri/uri.js\").addQueryString;\n\nfunction request(method, uri, data, callback) {\n\n    //TODO set content type and length headers\n    //TODO allow for multiple hosts by prepending http(s)://..\n    const location = 'http://localhost:8000/'; //TODO determine dynamically\n\n    const xhr = new XMLHttpRequest();\n    xhr.open(method, location + 'api' + addQueryString(uri, 'expand'), true);\n\n    xhr.onreadystatechange = () => {\n        if (xhr.readyState === 4) {\n            const status = xhr.status;\n            const content = xhr.responseText;\n            callback(status, content);\n        }\n    };\n    xhr.send(data);\n}\n\nconst retrieveMeta = (xyz, entityClasses, uri, callback) => {\n    const path = uri.substr(1).split('/');\n    const entityClassNameList = path[0]; // TODO error if no entityClass\n\n    const entityClassNames = entityClassNameList.split(',').filter(entityClass => !entityClasses.hasOwnProperty((entityClass)));\n    if (entityClassNames.length === 0) {\n        callback();\n    } else {\n        const metaUri = addQueryString('/entity/' + entityClassNames.join(','), 'expand');\n        request('GET', metaUri, undefined, (status, content) => {//TODO add querystring better\n            //TODO check status\n            console.log(metaUri, content);\n            const data = JSON.parse(content); //TODO check\n            if (typeof data !== 'object' || data === null || !data.hasOwnProperty('entity')) {\n                console.error('PROBLEM parsing meta response');\n                return\n            }\n            for (let entityClassName of entityClassNames) {\n                if (!entityClasses.hasOwnProperty(entityClassName)) {\n                    const metaData = data['entity'][entityClassName]['content']; // TODO validate data\n                    entityClasses[entityClassName] = new entity.Class(xyz, entityClassName, metaData);\n                }\n            }\n            callback();\n        });\n    }\n};\n\nexports.delete = (entityClasses, uri) => {\n    request('DELETE', uri, null, (status, response) => {\n        console.log('delete response: ' + uri + ' ' + response);\n        const responseContent = JSON.parse(response);\n        entity.handleInput('DELETE', uri, status, responseContent, null, entityClasses);\n    });\n};\n\nexports.head = uri => {\n    request('HEAD', uri, null, (status, response) => {\n        console.log('head response: ' + uri + ' ' + response);\n    });\n};\n\nconst handleModifyRequest = (entityClasses, method, uri, requestObjectContent) => {\n    console.log(method + ' request', uri, requestObjectContent);\n    const requestStringContent = JSON.stringify(requestObjectContent);\n    request(method, uri, requestStringContent, (status, responseStringContent) => {\n        console.log(method + ' response:' + responseStringContent, uri);\n        const responseObjectContent = JSON.parse(responseStringContent);\n        entity.handleInput(method, uri, status, responseObjectContent, requestObjectContent, entityClasses);\n    });\n};\n\nexports.post = (entityClasses, uri, content) => handleModifyRequest(entityClasses, 'POST', uri, content);\nexports.patch = (entityClasses, uri, content) => handleModifyRequest(entityClasses, 'PATCH', uri, content);\nexports.put = (entityClasses, uri, content) => handleModifyRequest(entityClasses, 'PUT', uri, content);\n\n// callback = Response =>{}\n// get the requested uri from cache or request it from server\nexports.get = (xyz, entityClasses, uri, dataCallback, metaCallBack) => {\n    retrieveMeta(xyz, entityClasses, uri, () => {\n        if (typeof metaCallBack === 'function') metaCallBack();\n\n        //TODO meta should be good or we have a problem\n        //TODO get the data from cache if already in cache\n        request('GET', uri, undefined, (status, responseStringContent) => {\n            let responseObjectContent;\n            try {\n                responseObjectContent = JSON.parse(responseStringContent);\n            } catch (e) {\n                console.error('GET', uri, responseStringContent, e);\n            }\n            console.log('GET', uri, status, responseObjectContent);\n            //TODO replace null with current content?\n            const state = entity.handleInput('GET', uri, status, responseObjectContent, null, entityClasses);\n            //TODO  word er nog iets met state gedaan...?\n            if (typeof dataCallback === 'function') {\n                const node = entity.getResponse(uri, entityClasses, 'GET');\n                dataCallback(node);\n            }\n        });\n    });\n};\n\nexports.retrieveMeta = retrieveMeta;\n\n//# sourceURL=webpack://xyz/./source/request/request.js?");

/***/ }),

/***/ "./source/uri/uri.js":
/*!***************************!*\
  !*** ./source/uri/uri.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const pathFromUri = uri => {\n    if (uri.startsWith('/')) {\n        uri = uri.substr(1);\n    }\n    if (uri.endsWith('/')) {\n        uri = uri.slice(0, -1);\n    }\n    return uri.split('/');\n};\n\nconst wrapContent = (uri, content) => {\n    const wrapper = {};\n    const path = pathFromUri(uri);\n    let wrapperIterator = wrapper;\n    for (let depth = 0; depth < path.length; ++depth) {\n        const key = path[depth];\n        wrapperIterator = wrapperIterator[key] = (depth === path.length - 1) ? content : {};\n    }\n    return wrapper;\n};\n\nconst getEntityClassNames = (uri, entityClasses) => {\n    const path = pathFromUri(uri);\n    const entityClassNameList = path[0] || '*';\n    if (entityClassNameList === '*') {\n        return Object.keys(entityClasses);\n    } else {\n        return entityClassNameList.split(','); //TODO check if exist\n    }\n};\n\nconst getBaseUri = uri => {\n    const path = pathFromUri(uri);\n    if (path.length === 1) {\n        return '/' + path[0] + '/*';\n    } else if (path.length === 0) {\n        console.error('PROBLEM ERROR'); // TODO\n    } else {\n        return '/' + path[0] + '/' + path[1];\n    }\n};\n\nconst addQueryString = (uri, queryString) => {\n\n    return uri.indexOf('?') ===-1\n        ? uri + '?' + queryString\n        : uri + '&'+ queryString;\n};\n\nexports.getBaseUri = getBaseUri;\nexports.getEntityClassNames = getEntityClassNames;\nexports.pathFromUri = pathFromUri;\nexports.wrapContent = wrapContent;\nexports.addQueryString = addQueryString;\n\n//# sourceURL=webpack://xyz/./source/uri/uri.js?");

/***/ }),

/***/ "./source/variables/variables.js":
/*!***************************************!*\
  !*** ./source/variables/variables.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const web = __webpack_require__(/*! ../web/web.js */ \"./source/web/web.js\");\n\nconst variables = {};\nconst uriCallbacks = {};\n\nconst handleVariableChange = variableName => {\n    web.setQueryParameter(variableName, variables[variableName]);\n    for (let uri in uriCallbacks) {\n        if (uri.indexOf('$' + variableName) !== -1) { // TODO find ${variableName} and ignore $variableNameWithPostfix\n            for (let callback of uriCallbacks[uri]) {\n                handleUri(uri, callback);\n            }\n        }\n    }\n};\n\nconst hasVariable = variableName => variables.hasOwnProperty(variableName);\nconst getVariable = (variableName, fallback) => variables.hasOwnProperty(variableName) ? variables[variableName] : fallback;\n\nconst clearVariable = variableName => {\n    delete variables[variableName];\n    handleVariableChange(variableName);\n};\n\nconst setVariable = (variableName, value) => {\n    if (value !== variables[variableName]) {\n        variables[variableName] = value;\n        handleVariableChange(variableName);\n    }\n};\n\nconst setVariables = (variableObject) => {\n    for (let variableName in variableObject) {\n        setVariable(variableName, variableObject[variableName]);\n    }\n};\n\nfunction handleUri(uri, callbacks) {\n    let complete = true;\n    //TODO find ${variableName}\n    uri = uri.replace(/\\$(\\w+)/, (_, variableName) => {\n        if (variables.hasOwnProperty(variableName)) {\n            return variables[variableName];\n        } else {\n            complete = false;\n            return '$' + variableName;\n        }\n    });\n    if (typeof callbacks.wait === 'function') {\n        callbacks.wait(uri);\n    }\n    if (complete) {\n        callbacks.ready(uri);\n    }\n}\n\nconst registerUri = (uri, readyCallback, waitCallback) => {\n    const callbacks = {ready: readyCallback, wait: waitCallback};\n    if (!uriCallbacks.hasOwnProperty(uri)) {\n        uriCallbacks[uri] = [callbacks];\n    } else {\n        uriCallbacks[uri].push(callbacks);\n    }\n    handleUri(uri, callbacks);\n};\n\nexports.getVariable = getVariable;\nexports.hasVariable = hasVariable;\nexports.setVariable = setVariable;\nexports.setVariables = setVariables;\nexports.clearVariable = clearVariable;\nexports.registerUri = registerUri;\n\n//# sourceURL=webpack://xyz/./source/variables/variables.js?");

/***/ }),

/***/ "./source/web/json.js":
/*!****************************!*\
  !*** ./source/web/json.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function json_set(object, keyPath, content) {\n    {\n        const length = keyPath.length;\n        if (length === 0) {\n            return content;\n        }\n        if (typeof object !== 'object' || object === null) {\n            throw new TypeError('object not an object');\n        } else if (object.hasOwnProperty(keyPath[0])) {\n            if (length === 1) {\n                object[keyPath[0]] = content;\n            } else {\n                json_set(object[keyPath[0]], keyPath.slice(1), content);\n            }\n        } else if (length === 1) {\n            object[keyPath[0]] = content;\n        } else {\n            object[keyPath[0]] = {};\n            json_set(object[keyPath[0]], keyPath.slice(1), content);\n        }\n        return object;\n    }\n}\n\nfunction json_unset(object, keyPath, fallBack) {\n    {\n        const length = keyPath.length;\n        if (length === 0) {\n            return undefined;\n        }\n        if (typeof object !== 'object' || object === null) {\n            if (typeof fallBack !== 'undefined') {\n                return null\n            } else {\n                throw new TypeError('object not an object');\n            }\n        } else if (object.hasOwnProperty(keyPath[0])) {\n            if (length === 1) {\n                delete object[keyPath[0]];\n            } else {\n                json_unset(object[keyPath[0]], keyPath.slice(1));\n            }\n        }\n        return object;\n    }\n}\n\n\nfunction json_get(object, keyPath, fallBack) {\n    {\n        const length = keyPath.length;\n        if (length === 0) {\n            return object;\n        }\n        if (typeof object !== 'object' || object === null) {\n            if (typeof fallBack !== 'undefined') {\n                return null\n            } else {\n                throw new TypeError('object not an object');\n            }\n        } else if (object.hasOwnProperty(keyPath[0])) {\n            return json_get(object[keyPath[0]], keyPath.slice(1));\n        }\n        return null;\n    }\n}\n\n//TODO json_get\n\nexports.get = json_get;\nexports.set = json_set;\nexports.unset = json_unset;\n\n//# sourceURL=webpack://xyz/./source/web/json.js?");

/***/ }),

/***/ "./source/web/web.js":
/*!***************************!*\
  !*** ./source/web/web.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.setCookie = function (keyValues, expiresInDays) {\n    const date = new Date();\n    date.setTime(date.getTime() + (expiresInDays * 24 * 60 * 60 * 1000));\n    const expires = 'expires=' + date.toUTCString();\n    for (let key in keyValues) {\n        document.cookie = key + '=' + keyValues[key] + ';' + expires + ';path=/';\n    }\n};\n\nexports.getCookie = function () {\n    if (document.cookie === '') {\n        return null;\n    }\n    const keyValuesPairs = document.cookie.split(';');\n    const cookie = {};\n    for (let keyValuePair of keyValuesPairs) {\n        const [key, value] = keyValuePair.split('=');\n        cookie[key.trim()] = value.trim();\n    }\n    return cookie;\n};\n\nfunction getQueryParameters() {\n    const queryParameters = {};\n    location.search\n        .substr(1) // '?a=1&b=2' -> 'a=1&b=2'\n        .split('&') // ['a=1','b=2']\n        .filter(x => x !== '')\n        .forEach(function (item) {\n            const [key, value] = item.split('='); // 'a=1' -> ['a','1']\n            queryParameters[decodeURIComponent(key)] = decodeURIComponent(value);\n        });\n    return queryParameters;\n}\n\nexports.getQueryParameters = getQueryParameters;\n\nexports.getQueryParameter = function (queryParameterName) {\n    return getQueryParameters()[queryParameterName];\n};\n\nfunction updateQueryParameter(queryParameterName, value) {\n    // '?a=1&b=2' -> ['a=1','b=2']\n    const keyValuePairs = document.location.search.substr(1).split('&').filter(x => x !== '');\n\n    let found = false;\n    for (let i = 0; i < keyValuePairs.length; ++i) {\n        const keyValuePair = keyValuePairs[i];\n        const otherKey = keyValuePair.split('=')[0];  //  'a=1' -> 'a'\n        if (otherKey === encodeURIComponent(queryParameterName)) {\n            if (typeof value === 'undefined') {\n                keyValuePairs.splice(i,1);\n            }else {\n                keyValuePairs[i] = [encodeURIComponent(queryParameterName), encodeURIComponent(value)].join('='); // 'a=value'\n            }\n            found = true;\n            break;\n        }\n    }\n\n    if (!found && typeof value !== 'undefined') {\n        keyValuePairs[keyValuePairs.length] = [encodeURIComponent(queryParameterName), encodeURIComponent(value)].join('=');\n    }\n    if (keyValuePairs.length) {\n        return window.location.protocol + '//' + window.location.host + window.location.pathname + '?' + keyValuePairs.join('&');\n    } else {\n        return window.location.protocol + '//' + window.location.host + window.location.pathname;\n    }\n}\n\nexports.setQueryParameter = function (queryParameterName, value) {\n    const newUrl = updateQueryParameter(queryParameterName, value);\n    window.history.pushState({path: newUrl}, '', newUrl);\n};\n\n//# sourceURL=webpack://xyz/./source/web/web.js?");

/***/ })

/******/ });