var xyz =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./source/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../core/displays/item.js":
/*!*****************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/displays/item.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const list = __webpack_require__(/*! ./list.js */ \"../../core/displays/list.js\");\n\nexports.display = {\n    waitingForInput: (xyz, action, options, WRAPPER) => {\n        WRAPPER.innerHTML = 'Waiting for input...';\n    },\n    waitingForData: (xyz, action, options, WRAPPER) => {\n        WRAPPER.innerHTML = 'Waiting for data...';\n    },\n    empty: (xyz, action, options, WRAPPER) => {\n        WRAPPER.innerHTML = 'No items to display.';\n    },\n    first: (xyz, action, options, WRAPPER, entityId, content) => {\n        WRAPPER.innerHTML = '';\n    },\n    entity: (xyz, action, options, WRAPPER, entityId, content) => {\n        const columns = list.flatten(content);\n        const TABLE_entity = document.createElement('TR');\n        TABLE_entity.className = 'xyz-item';\n\n        for (let flatPropertyName in columns) {\n            const TR_flatProperty = document.createElement('TR');\n\n            if (options.showLabel !== false) {\n                const TD_flatPropertyName = document.createElement('TD');\n                TD_flatPropertyName.innerHTML = flatPropertyName;\n                TR_flatProperty.appendChild(TD_flatPropertyName);\n            }\n            const TD_flatPropertyContent = document.createElement('TD');\n            const node = columns[flatPropertyName];\n            const TAG = node.render(action, options);\n            TD_flatPropertyContent.appendChild(TAG);\n            TR_flatProperty.appendChild(TD_flatPropertyContent);\n            TABLE_entity.appendChild(TR_flatProperty);\n        }\n        WRAPPER.appendChild(TABLE_entity);\n    }\n};\n\n\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/displays/item.js?");

/***/ }),

/***/ "../../core/displays/list.js":
/*!*****************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/displays/list.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\noptions\n- select\n- multiSelect\n- addCreateButton\n- TODO default\n- TODO addDeleteButtons\n- TODO addEditButtons\n- TODO add multiselect tools\n */\n\nfunction select(xyz, options, entityId) {\n    if (typeof options.select === 'string') {\n        xyz.setVariable(options.select, entityId);\n    } else if (typeof options.select === 'function') {\n        options.select(entityId);\n    }\n}\n\nfunction flatten2(source, target, prefix) {\n    if(source.constructor !== Object){\n        return;\n    }\n    for (let key in source) {\n        const value = source[key];\n        if (value.constructor === Object) {\n            flatten2(value, target, prefix + key + '.');\n        } else {\n            target[prefix + key] = value;\n        }\n    }\n}\n\nfunction flatten(source) {\n    const target = {};\n    flatten2(source, target, '');\n    return target;\n}\n\nfunction addCreateButton(xyz, fullUri, WRAPPER, options) {\n    //TODO only if has the permissions to add\n    if (options.addCreateButton !== false) {\n        const INPUT = document.createElement('INPUT');\n        INPUT.type = \"submit\";\n        //TODO add class\n        INPUT.value = \"+\";\n        INPUT.onclick = () => {\n            if (DIV.style.display === 'none') {\n                DIV.style.display = 'block';\n                INPUT.value = \"-\";\n            } else {\n                INPUT.value = \"+\";\n                DIV.style.display = 'none';\n            }\n        };\n        WRAPPER.appendChild(INPUT);\n        const DIV = document.createElement('DIV');\n        DIV.style.display = 'none';\n        const entityClassName = fullUri.substr(1).split('/')[0];\n        xyz.ui('/' + entityClassName, {display: 'create'}, DIV);\n        WRAPPER.appendChild(DIV);\n    }\n}\n\nexports.display = {\n    waitingForInput: (xyz, action, options, WRAPPER) => {\n        WRAPPER.innerHTML = 'Waiting for input...';\n    },\n    waitingForData: (xyz, action, options, WRAPPER) => {\n        WRAPPER.innerHTML = 'Waiting for data...';\n    },\n    empty: (xyz, action, options, WRAPPER, uri) => {\n        WRAPPER.innerHTML = '';\n        const TABLE = document.createElement('TABLE');\n        TABLE.className = 'xyz-list';\n        WRAPPER.appendChild(TABLE);\n        addCreateButton(xyz, uri, WRAPPER, options);\n    },\n    first: (xyz, action, options, WRAPPER, entityId, content) => {\n        const columns = flatten(content);\n        const TR_header = document.createElement('TR');\n        TR_header.className = 'xyz-list-header';\n        if (options.multiSelect) {\n            const TD_checkbox = document.createElement('TD');\n            TR_header.appendChild(TD_checkbox);\n        }\n        for (let flatPropertyName in columns) {\n            const TD_header = document.createElement('TD');\n            TD_header.innerHTML = flatPropertyName;\n            TR_header.appendChild(TD_header);\n        }\n        const TABLE = WRAPPER.firstChild;\n        TABLE.appendChild(TR_header);\n    },\n    //TODO uri\n    entity: (xyz, action, options, WRAPPER, entityId, content) => {\n        const columns = flatten(content);\n        const TR_entity = document.createElement('TR');\n        TR_entity.className = 'xyz-list-item';\n\n        if (options.multiSelect) {\n            const variableName = options.multiSelect;\n            const TD_checkbox = document.createElement('TD');\n            const INPUT_checkbox = document.createElement('INPUT');\n            INPUT_checkbox.type = \"checkbox\";\n            INPUT_checkbox.onclick = event => {\n                const entityIds = xyz.hasVariable(variableName)\n                    ? xyz.getVariable(variableName).split(',')\n                    : [];\n                if (INPUT_checkbox.checked) {\n                    if (!entityIds.includes(entityId)) {\n                        entityIds.push(entityId);\n                    }\n                } else {\n                    const index = entityIds.indexOf(entityId);\n                    if (index !== -1) {\n                        entityIds.splice(index, 1);\n                    }\n                }\n                if (entityIds.length === 0) {\n                    xyz.clearVariable(variableName);\n                } else {\n                    xyz.setVariable(variableName, entityIds.join(','));\n                }\n                event.stopPropagation();\n            };\n            TD_checkbox.appendChild(INPUT_checkbox);\n            TR_entity.appendChild(TD_checkbox);\n        }\n\n        for (let flatPropertyName in columns) {\n            const TD_flatProperty = document.createElement('TD');\n            const node = columns[flatPropertyName];\n            const TAG = node.render(action, options);\n            TD_flatProperty.appendChild(TAG);\n            TR_entity.appendChild(TD_flatProperty);\n        }\n\n        const TABLE = WRAPPER.firstChild;\n        if (options.select) {\n            if (xyz.getVariable(options.select) === entityId || options.default === entityId) {\n                TR_entity.classList.add('xyz-list-selected');\n            }\n            TR_entity.onclick = () => {\n                select(xyz, options, entityId);\n                for (let row of TABLE.childNodes) {\n                    if (row === TR_entity) {\n                        row.classList.add('xyz-list-selected');\n                    } else {\n                        row.classList.remove('xyz-list-selected');\n                    }\n                }\n            };\n        }\n        TABLE.appendChild(TR_entity);\n    }\n};\n\nexports.addCreateButton = addCreateButton;\nexports.flatten = flatten;\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/displays/list.js?");

/***/ }),

/***/ "../../core/displays/select.js":
/*!*******************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/displays/select.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const list = __webpack_require__(/*! ./list.js */ \"../../core/displays/list.js\");\n\n/*\nTODO add radio flavor to provide radio box\n\noptions\n- select\n- flavor  dropdown|TODO radio\n- addCreateButton\n */\n\nfunction select(xyz, options, entityId) {\n    if (typeof options.select === 'string') {\n        xyz.setVariable(options.select, entityId);\n    } else if (typeof options.select === 'function') {\n        options.select(entityId);\n    }\n}\n\nexports.display = {\n    waitingForInput: (xyz, action, options, WRAPPER) => {\n        WRAPPER.innerHTML = 'Waiting for input...';\n    },\n    waitingForData: (xyz, action, options, WRAPPER) => {\n        WRAPPER.innerHTML = 'Waiting for data...';\n    },\n    empty: (xyz, action, options, WRAPPER, entityClassNameList) => {\n        WRAPPER.innerHTML = '';\n        const SELECT = document.createElement('SELECT');\n        SELECT.className = 'xyz-select';\n        SELECT.onchange = () => {\n            const entityId = SELECT.options[SELECT.selectedIndex].value;\n            select(xyz, options, entityId);\n        };\n        WRAPPER.appendChild(SELECT);\n        const fullUri = '/' + entityClassNameList; //TODO this could be multiple classes\n        list.addCreateButton(xyz, fullUri, WRAPPER, options);\n    },\n    first: (xyz, action, options, WRAPPER, entityId, content) => {\n        //TODO something with wrapper?\n    },\n\n    entity: (xyz, action, options, WRAPPER, entityId, content) => {\n        const columns = list.flatten(content);\n\n        const SELECT = WRAPPER.firstChild;\n\n        if (SELECT.childElementCount === 0 && !options.initialValue) { // select the first option as default TODO unless other default is defined\n            select(xyz, options, entityId);\n        }\n\n        const OPTION = document.createElement('OPTION');\n        if (options.initialValue === entityId) {\n            select(xyz, options, entityId);\n            OPTION.selected = true;\n        }\n        for (let flatPropertyName in columns) {\n            const node = columns[flatPropertyName];\n            const TAG = node.render(action, options);\n            OPTION.appendChild(TAG);\n        }\n\n        SELECT.appendChild(OPTION);\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/displays/select.js?");

/***/ }),

/***/ "../../core/types/array.js":
/*!***************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/array.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        // TODO create ui for adding/removing elements\n        // TODO create drop ui to drag elements to\n        const SPAN = document.createElement('SPAN');\n        //TODO check if content is array\n        const content = item.getContent();\n        const subSettings = item.getSetting('subType');\n        const subOptions = item.getOptions(); //TODO\n        for (let key in content) {\n            const subUri = item.getUri() + '/' + key;\n            const subContent = content[key];\n            const TAG = item.renderElement('edit', subUri, item.getStatus(), subContent, subSettings, subOptions);\n            const DIV_sub = document.createElement('DIV');\n            const INPUT_remove = document.createElement('INPUT');\n            INPUT_remove.type = 'submit';\n            //TODO add class\n            INPUT_remove.value = 'x';\n            DIV_sub.appendChild(INPUT_remove);\n            DIV_sub.appendChild(TAG);\n            SPAN.appendChild(DIV_sub);\n        }\n        const subUri = item.getUri(); //TODO add something\n        const newContent = null;//TODO default value\n        const DIV_CREATE = document.createElement('DIV');\n        const INPUT_create = document.createElement('INPUT');\n        INPUT_create.type = \"submit\";\n        //TODO add class\n        INPUT_create.value = \"Add\";\n        const TAG_create = item.renderElement('edit', subUri, item.getStatus(), newContent, subSettings, subOptions);\n        DIV_CREATE.appendChild(TAG_create);\n        DIV_CREATE.appendChild(INPUT_create);\n        SPAN.appendChild(DIV_CREATE);\n        return SPAN;\n    },\n    view: function (item) {\n        const SPAN = document.createElement('SPAN');\n        //TODO check if content is array\n        const subSettings = item.getSetting('subType');\n        const subOptions = item.getOptions(); //TODO\n        const content = item.getContent();\n        for (let key in content) {\n            const subUri = item.getUri() + '/' + key;\n            const subContent = content[key];\n            const TAG = item.renderElement('view', subUri, item.getStatus(), subContent, subSettings, subOptions);\n            SPAN.appendChild(TAG);\n        }\n        return SPAN;\n    },\n    validate: function (item) {\n        const content = item.getContent();\n        if (content === null || typeof content !== 'object') {\n            return false;\n        }\n        const subSettings = item.getSetting('subType');\n        const subOptions = item.getOptions(); //TODO\n        for (let key in content) {\n            const subUri = item.getUri() + '/' + key;\n            const subContent = content[key];\n            if (!item.validate(subUri, item.getStatus(), subContent, subSettings, subOptions)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/array.js?");

/***/ }),

/***/ "../../core/types/bool.js":
/*!**************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/bool.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        //TODO radio flavor to distinguish two options\n        const INPUT = document.createElement('INPUT');\n        INPUT.type='checkbox';\n        INPUT.checked=!!item.getContent();\n        INPUT.onchange = () => {\n            item.patch(INPUT.checked);\n        };\n        return INPUT;\n    },\n    view: function (item) {\n        const SPAN = document.createElement('SPAN');\n        //TODO 404 etc status outputs (refactor from string)\n        //TODO use settings to get yes|no label\n        SPAN.innerText = item.getContent() ? 'yes':'no';\n        return SPAN;\n    },\n    validate: function (item) {\n        return typeof item.getContent() === 'boolean';\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/bool.js?");

/***/ }),

/***/ "../../core/types/enum.js":
/*!**************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/enum.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        const SELECT = document.createElement('SELECT');\n        SELECT.onchange = () => {\n            const content = SELECT.options[SELECT.selectedIndex].value;\n            item.patch(content);\n        };\n\n        const choices = item.getSetting('choices') instanceof Array ? item.getSetting('choices') : [];\n        // TODO select default by default\n\n        const subSettings = item.getSetting('subType')|| {};\n        const content = item.getContent();\n        for (let choice of choices) {\n            const OPTION = document.createElement('OPTION');\n            if (choice === content) {\n                OPTION.selected = true;\n            }\n            OPTION.innerText = choice; //TODO render choice content\n           // item.renderElement('view', item.getUri(), item.getStatus(), choice, subSettings, options);\n            SELECT.appendChild(OPTION);\n        }\n        return SELECT;\n    },\n    view: function (item) {\n        const subSettings = item.getSetting('subType')|| {};\n        const TAG = item.renderElement('view', item.getUri(), item.getStatus(), item.getContent(), subSettings, item.getOptions());\n        return TAG;\n    },\n    validate: function (item) {\n        const choices = item.getSetting('choices');\n        if (!choices instanceof Array) {\n            return false;\n        }\n        return choices.indexOf(item.getContent()) !== -1;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/enum.js?");

/***/ }),

/***/ "../../core/types/file.js":
/*!**************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/file.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        const prepareContent = (files) => {\n            //TODO add filetype validation (using accept to catch client side injections)\n            const data = {};\n            if (item.getSetting('multiple')) {\n                //TODO content = '[' + files.map(file => file.text()).join(',') + ']';\n            } else if (files.length === 0) {\n                //TODO\n            } else {\n                const reader = new FileReader();\n                reader.onload = evt => {\n                    data['content'] = evt.target.result;\n                    const extension = item.getSetting('signature').id.storage.extension;\n                    let key;\n                    //TODO or extension is mixed extensions for example \"json|xml\"\n                    if (extension && extension !== '*') {\n                        key = files[0].name.split('.').splice('.').slice(0, -1).join('.');\n                    } else {\n                        key = files[0].name;\n                    }\n                    data['id'] = key;\n                    item.patch(data);\n                };\n                reader.onerror = evt => {\n                    //TODO\n                };\n                reader.readAsText(files[0], \"UTF-8\");\n            }\n        };\n\n        // TODO add id from options (for label for)\n        const INPUT = document.createElement('INPUT');\n        INPUT.type = 'file';\n        const content = item.getContent();\n        if (content) {\n            INPUT.value = content;\n        }\n        if (item.patch) {\n            INPUT.addEventListener('change', event => {\n                prepareContent(event.target.files, item.patch);\n            });\n        }\n        INPUT.multiple = item.getSetting('multiple');\n        INPUT.accept = item.getSetting('accept');\n\n        return INPUT;\n    },\n    /*view: function (item) {\n        //TODO use a file viewer:   https://viewerjs.org/\n        return content;\n    },*/\n    validate: function (item) {\n        //TODO implement client side validation\n        //todo mime/accept\n        //todo max size\n        return true;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/file.js?");

/***/ }),

/***/ "../../core/types/id.js":
/*!************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/id.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        //TODO make visible with options.something\n        const SPAN = document.createElement('SPAN');\n        SPAN.innerText = 'auto increment';\n        return SPAN;\n    },\n    view: function (item) {\n        //TODO make visible with options.something\n        const SPAN = document.createElement('SPAN');\n        SPAN.innerText = item.getContent();\n        return SPAN;\n    },\n    validate: function (item) {\n        //TODO should be 0 or null always?\n        return true;//TODO\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/id.js?");

/***/ }),

/***/ "../../core/types/json.js":
/*!**************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/json.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        const TEXTAREA = document.createElement('TEXTAREA');\n        TEXTAREA.value = item.getContent();\n        TEXTAREA.oninput = ()=>{\n            let content;\n            try{\n                content = JSON.parse(TEXTAREA.value);\n            }catch (e) {\n                //TODO\n                return;\n            }\n            item.patch(content);\n        };\n        return TEXTAREA;\n    },\n    view: function (item) {\n        const DIV = document.createElement('DIV');\n        DIV.innerText = JSON.stringify(item.getContent());\n        return DIV;\n    },\n    validate: function (item) {\n        try{\n            JSON.parse(item.getContent());\n            return true;\n        }catch (e) {\n            return false;\n        }\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/json.js?");

/***/ }),

/***/ "../../core/types/number.js":
/*!****************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/number.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        const INPUT = document.createElement('INPUT');\n        INPUT.type = 'number';\n\n        const content = item.getContent();\n        if (content) {\n            INPUT.value = content;\n        }\n\n        INPUT.step = item.getSetting('step');\n        INPUT.min = item.getSetting('min');\n        INPUT.max = item.getSetting('max');\n\n        if (item.patch) {\n            INPUT.oninput = () => {\n                item.patch(INPUT.value)\n            };\n        }\n\n        // TODO add id from options (for label for)\n\n        return INPUT;\n    },\n    view: function (item) {\n        const SPAN = document.createElement('SPAN');\n        switch (item.getStatus()) {\n            case 500 :\n                SPAN.innerText = 'Server error';\n                break;\n            case 400 :\n                SPAN.innerText = 'Bad request';\n                break;\n            case 403 :\n                SPAN.innerText = 'Forbidden';\n                break;\n            case 404 :\n                SPAN.innerText = 'Not found';\n                break;\n            default:\n                SPAN.innerText = item.getContent();\n                break;\n        }\n        return SPAN;\n    },\n    validate: function (item) {\n        const content = item.getContent();\n        if (typeof content !== 'number') {\n            return false;\n        }\n        if (item.getSetting('max') && content > item.getSetting('max')) {\n            return false;\n        }\n        if (item.getSetting('min') && content < item.getSetting('min')) {\n            return false;\n        }\n        if (item.getSetting('step') && content / item.getSetting('step') !== Math.floor(content / item.getSetting('step'))) {\n            return false;\n        }\n        return true;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/number.js?");

/***/ }),

/***/ "../../core/types/object.js":
/*!****************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/object.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        // TODO create ui for adding/removing elements\n        // TODO create drop ui to drag elements to\n        //TODO check if content is array\n        const content = item.getContent();\n        const subSettings = item.getSetting('subType');\n        const subOptions = item.getOptions(); //TODO\n        const TABLE = document.createElement('TABLE');\n        for (let key in content) {\n            const TR = document.createElement('TR');\n            const TD_key = document.createElement('TD');\n            const TD_value = document.createElement('TD');\n\n            const INPUT_remove = document.createElement('INPUT');\n            INPUT_remove.type = 'submit';\n            //TODO add class\n            INPUT_remove.value = 'x';\n            TD_key.appendChild(INPUT_remove);\n            const TEXT_key = document.createTextNode(key)\n            TD_key.appendChild(TEXT_key);\n\n            const subUri = item.getUri() + '/' + key;\n            const subContent = content[key];\n            const TAG = item.renderElement('edit', subUri,  item.getStatus(), subContent, subSettings, subOptions);\n            TD_value.appendChild(TAG);\n\n            TR.appendChild(TD_key);\n            TR.appendChild(TD_value);\n            TABLE.appendChild(TR);\n        }\n        const TR_add = document.createElement('TR');\n        const TD_key = document.createElement('TD');\n        const TD_value = document.createElement('TD');\n        const INPUT_key = document.createElement('INPUT');\n\n        const subUri = item.getUri(); //TODO add something\n        const newContent = null;//TODO default value\n        const INPUT_create = document.createElement('INPUT');\n        INPUT_create.type = \"submit\";\n        //TODO add class\n        INPUT_create.value = \"Add\";\n        const TAG_create = item.renderElement('edit', subUri, item.getStatus(), newContent, subSettings, subOptions);\n        TD_key.appendChild(INPUT_key);\n        TD_value.appendChild(TAG_create);\n        TD_value.appendChild(INPUT_create);\n\n        TR_add.appendChild(TD_key);\n        TR_add.appendChild(TD_value);\n        TABLE.appendChild(TR_add);\n        return TABLE;\n    },\n    view: function (item) {\n        //TODO check if content is array\n        const content = item.getContent();\n        const subSettings = item.getSetting('subType');\n        const subOptions = item.getOptions(); //TODO\n        const TABLE = document.createElement('TABLE');\n        for (let key in content) {\n            const TR = document.createElement('TR');\n            const TD_key = document.createElement('TD');\n            const TD_value = document.createElement('TD');\n            TD_key.innerText = key;\n            TR.appendChild(TD_key);\n\n            const subUri = item.getUri() + '/' + key;\n            const subContent = content[key];\n            const TAG = item.renderElement('view', subUri, item.getStatus(), subContent, subSettings, subOptions);\n            TD_value.appendChild(TAG);\n            TR.appendChild(TD_value);\n            TABLE.appendChild(TR);\n        }\n        return TABLE;\n    },\n    validate: function (item) {\n        const content = item.getContent();\n        if (content === null || typeof content !== 'object') {\n            return false;\n        }\n        const subSettings = item.getSetting('subType');\n        const subOptions = item.getOptions(); //TODO\n        for (let key in content) {\n            const subUri = item.getUri() + '/' + key;\n            const subContent = content[key];\n            if (!item.validate(subUri, item.getStatus(), subContent, subSettings, subOptions)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/object.js?");

/***/ }),

/***/ "../../core/types/reference.js":
/*!*******************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/reference.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        const TAG = item.ui('/' + item.getSetting('class') + '/*/id', {\n            display: 'select',\n            select: item.patch,\n            initialValue: item.getContent()\n        }); // TODO how to determine id or title?\n        return TAG;\n    },\n    view: function (item) {\n        const DIV = document.createElement('DIV');\n        item.ui('/' + item.getSetting('class') + '/' + item.getContent(), {display: 'item'}, DIV);\n        return DIV;\n    },\n    validate: function (item) {\n        //TODO implement client side validation specific for referenced entity type\n        return true;//TODO\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/reference.js?");

/***/ }),

/***/ "../../core/types/string.js":
/*!****************************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/engine/core/types/string.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (item) {\n        const INPUT = document.createElement('INPUT');\n        const content = item.getContent();\n        if (content) {\n            INPUT.value = content;\n        }\n        if (item.patch) {\n            INPUT.oninput = () => {\n                item.patch(INPUT.value)\n            };\n        }\n\n        // TODO add id from options (for label for)\n        //TODO add validation regex\n\n        return INPUT;\n    },\n    view: function (item) {\n        const SPAN = document.createElement('SPAN');\n        switch (item.getStatus()) {\n            case 500 :\n                SPAN.innerText = 'Server error';\n                break;\n            case 400 :\n                SPAN.innerText = 'Bad request';\n                break;\n            case 403 :\n                SPAN.innerText = 'Forbidden';\n                break;\n            case 404 :\n                SPAN.innerText = 'Not found';\n                break;\n            default:\n                SPAN.innerText = item.getContent();\n                break;\n        }\n        return SPAN;\n    },\n    validate: function (item) {\n        //TODO implement client side validation\n        return typeof item.getContent() === 'string';//TODO min max length, regex\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/engine/core/types/string.js?");

/***/ }),

/***/ "./build/displays.js":
/*!***************************!*\
  !*** ./build/displays.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// This file is created by gulpfile.js using the type definitions of engine/core/displays/*.js. \n\nexports.item = __webpack_require__(/*! ../../../core/displays/item.js */ \"../../core/displays/item.js\").display;\nexports.list = __webpack_require__(/*! ../../../core/displays/list.js */ \"../../core/displays/list.js\").display;\nexports.select = __webpack_require__(/*! ../../../core/displays/select.js */ \"../../core/displays/select.js\").display;\n\n\n//# sourceURL=webpack://xyz/./build/displays.js?");

/***/ }),

/***/ "./build/types.js":
/*!************************!*\
  !*** ./build/types.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// This file is created by gulpfile.js using the type definitions of engine/core/types/*.js. \n\nexports.array = __webpack_require__(/*! ../../../core/types/array.js */ \"../../core/types/array.js\").actions;\nexports.bool = __webpack_require__(/*! ../../../core/types/bool.js */ \"../../core/types/bool.js\").actions;\nexports.enum = __webpack_require__(/*! ../../../core/types/enum.js */ \"../../core/types/enum.js\").actions;\nexports.file = __webpack_require__(/*! ../../../core/types/file.js */ \"../../core/types/file.js\").actions;\nexports.id = __webpack_require__(/*! ../../../core/types/id.js */ \"../../core/types/id.js\").actions;\nexports.json = __webpack_require__(/*! ../../../core/types/json.js */ \"../../core/types/json.js\").actions;\nexports.number = __webpack_require__(/*! ../../../core/types/number.js */ \"../../core/types/number.js\").actions;\nexports.object = __webpack_require__(/*! ../../../core/types/object.js */ \"../../core/types/object.js\").actions;\nexports.reference = __webpack_require__(/*! ../../../core/types/reference.js */ \"../../core/types/reference.js\").actions;\nexports.string = __webpack_require__(/*! ../../../core/types/string.js */ \"../../core/types/string.js\").actions;\n\n\n//# sourceURL=webpack://xyz/./build/types.js?");

/***/ }),

/***/ "./source/entity/entity.js":
/*!*********************************!*\
  !*** ./source/entity/entity.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Property = __webpack_require__(/*! ./property.js */ \"./source/entity/property.js\").constructor;\nconst listener = __webpack_require__(/*! ./listener.js */ \"./source/entity/listener.js\");\nconst uriTools = __webpack_require__(/*! ../uri/uri.js */ \"./source/uri/uri.js\");\nconst State = __webpack_require__(/*! ./state.js */ \"./source/entity/state.js\").State;\nconst response = __webpack_require__(/*! ./response.js */ \"./source/entity/response.js\");\n\nfunction EntityClass(xyz, entityClassName, settings) {\n    if (typeof entityClassName !== 'string') throw new TypeError('entityClassName not a string.');\n\n    const entities = {}; //TODO mark if entities are new or have been removed\n    const statusses = {};\n\n    listener.Handler.call(this);\n\n    const properties = {};\n\n    for (let propertyName in settings) {\n        properties[propertyName] = new Property(xyz, this, propertyName, settings[propertyName]);\n    }\n\n    this.getSettings = () => settings;\n\n    this.getUri = entityId => {\n        if (typeof entityId !== 'string') throw new TypeError('entityId not a string.');\n\n        return '/' + entityClassName + '/' + entityId;\n    };\n\n    const addEntityListener = (entityId, path, eventName, callback) => {\n        const listeners = [];\n        if (path.length === 0) {\n            const listener = this.addAtomicListener(entityId, eventName, callback);\n            listeners.push(listener);\n        } else {\n            const propertNameList = path[0];\n            const propertyNames = propertNameList === '*'\n                ? Object.keys(properties)\n                : propertNameList.split(',');\n            const subPath = path.slice(1);\n            for (let propertyName of propertyNames) {\n                if (properties.hasOwnProperty(propertyName)) {\n                    const propertyListeners = properties[propertyName].addPropertyListener(entityId, subPath, eventName, callback);\n                    listeners.push(...propertyListeners);\n                } else {\n                    //TODO throw error?\n                    console.error(subPropertyName + 'not available')\n                }\n            }\n        }\n        return listeners;\n    };\n\n    this.addListener = (path, eventName, callback) => {\n        //TODO check path, callback and eventName\n        // TODO only if path.length <= 1 ? otherwise send to properties\n        const listeners = [];\n        const entityIds = (path.length === 0 || path[0] === '*')\n            ? ['*']\n            : path[0].split(',');\n        const subPath = path.splice(1);\n        for (let entityId of entityIds) {\n            const entityListeners = addEntityListener(entityId, subPath, eventName, callback);\n            listeners.push(...entityListeners);\n        }\n        return listeners;\n    };\n\n    this.getResponse = (path, entityId) => {\n        const propertyNames = (path.length === 0 || path[0] === '*')\n            ? Object.keys(properties)\n            : path[0].split(',');\n        const content = {};\n        const subPath = path.slice(1);\n        for (let propertyName of propertyNames) {\n            if (properties.hasOwnProperty(propertyName)) {\n                content[propertyName] = properties[propertyName].getResponse(subPath, entityId);\n            } else {\n                content[propertyName] = new response.Node(this, entityId, 400, null, [`${propertyName} does not exist.`]); //TODO\n            }\n        }\n        return content;\n    };\n\n    //TODO MAYBE make private /remove\n    this.getEntityClassResponse = path => {\n        const entityIds = (path.length === 0 || path[0] === '*')\n            ? Object.keys(entities)\n            : path[0].split(',');\n        const content = {};\n        const subPath = path.slice(1);\n        for (let entityId of entityIds) {\n            if (entities.hasOwnProperty(entityId)) {\n                content[entityId] = this.getResponse(subPath, entityId);\n            } else {\n                content[entityId] = new response.Node(this, entityId, 404, null, [`/${entityClassName}/${entityId} not found.`]); //TODO\n            }\n        }\n        return content;\n    };\n\n    this.createCreator = (options, data, xyz) => {\n        const TABLE = document.createElement('TABLE');\n        for (let propertyName in properties) {\n            for (let TR of properties[propertyName].createCreator(options, data, xyz)) {\n                TABLE.appendChild(TR);\n            }\n        }\n        return TABLE;\n    };\n\n    this.isAutoIncremented = () => {\n        for (let propertyName in properties) {\n            if (properties[propertyName].isAutoIncremented()) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    this.getIdFromContent = data => {\n        if (typeof data !== 'object' || data === null) {//TODO is_object\n            return null;\n        }\n        for (let propertyName in properties) {\n            if (data.hasOwnProperty(propertyName)) {\n                const id = properties[propertyName].getIdFromContent(data[propertyName]);\n                if (id) {\n                    return id;\n                }\n            }\n        }\n        return null;\n    };\n\n    this.callListeners = (state, entityId) => {\n        this.callAtomicListeners(state, entityId, this.getResponse([], entityId))\n    };\n\n    const handleEntityIdInput = (entityId, entityStatus, entityContent) => {\n\n        if (typeof entityId !== 'string') throw new TypeError('entityId not a string.');\n        if (typeof entityStatus !== 'number') throw new TypeError('entityStatus not a number.');\n\n        let state = new State();\n        if (!entities.hasOwnProperty(entityId)) {\n            state.setCreated();\n        }\n        entities[entityId] = true; //TODO hier moet meer mee\n\n        if (entityStatus === 207) {\n            for (let propertyName in properties) {\n                const property207Wrapper = entityContent[propertyName];\n                if (property207Wrapper === null || typeof property207Wrapper !== 'object'\n                    || !property207Wrapper.hasOwnProperty('status')\n                    || !property207Wrapper.hasOwnProperty('content')\n                ) {\n                    //TODO response is in error\n                    console.error('error response in wrong format');\n                } else {\n                    const property = properties[propertyName];\n                    const propertyStatus = property207Wrapper.status;\n                    const propertyContent = property207Wrapper.content;\n                    const propertyState = property.handleInput(entityId, propertyStatus, propertyContent);\n                    state.addSubState(propertyState);\n                }\n            }\n        } else {\n            for (let propertyName in properties) {\n                const property = properties[propertyName];\n                const propertyContent = (entityContent === null || typeof entityContent !== 'object')\n                    ? null\n                    : entityContent[propertyName];\n                const propertyState = property.handleInput(entityId, entityStatus, propertyContent);\n                state.addSubState(propertyState);\n            }\n        }\n        statusses[entityId] = state.getStatus();\n        this.callListeners(state, entityId);\n        return state;\n    };\n\n    this.handleInput = (entityClassStatus, entityClassContent, entityIds) => {\n        const state = new State();\n        if (entityClassStatus === 207) {\n            for (let entityId of entityIds) {\n                const entity207Wrapper = entityClassContent[entityId];\n                if (entity207Wrapper === null || typeof entity207Wrapper !== 'object'\n                    || !entity207Wrapper.hasOwnProperty('status')\n                    || !entity207Wrapper.hasOwnProperty('content')\n                ) {\n                    //TODO reponse is in error\n                    console.error('error response in wrong format');\n                } else {\n                    const entityStatus = entity207Wrapper.status;\n                    const entityContent = entity207Wrapper.content;\n                    const entityState = handleEntityIdInput(entityId, entityStatus, entityContent);\n                    state.addSubState(entityState);\n                }\n            }\n        } else {\n            //TODO if error set error\n            //            state.setError(404, 'Not found');\n            for (let entityId of entityIds) {\n                const entityContent = (entityClassContent === null || typeof entityClassContent !== 'object')\n                    ? null\n                    : entityClassContent[entityId];\n                const entityState = handleEntityIdInput(entityId, entityClassStatus, entityContent);\n                state.addSubState(entityState);\n            }\n        }\n        return state;\n    };\n\n    this.render = (action, options, entityId) => {\n        //TODO get xyz here\n        const DIV = document.createElement('DIV');\n        for (let propertyName in properties) {\n            const TAG = properties[propertyName].render(action, options, entityId);\n            DIV.appendChild(TAG);\n        }\n        return DIV;\n    };\n}\n\n\nconst handleInput = (uri, status, content, entityClasses) => {\n    const state = new State();\n    //TODO check status\n    try {\n        content = JSON.parse(content);//TODO check\n    }catch(e){\n        console.error(content);\n        content = {};\n        state.setError(500,'Could not parse JSON');\n    }\n\n    const path = uriTools.pathFromUri(uri);\n    const entityClassNameList = path[0]; // TODO error if no entityClass\n    const entityIdList = path[1] || '*';\n    const entityClassNames = entityClassNameList.split(',');\n    if (status === 207) {\n        for (let entityClassName of entityClassNames) {\n            const entityClass207Wrapper = content[entityClassName];\n            if (entityClass207Wrapper === null || typeof entityClass207Wrapper !== 'object'\n                || !entityClass207Wrapper.hasOwnProperty('status')\n                || !entityClass207Wrapper.hasOwnProperty('content')\n            ) {\n                console.error('error response in wrong format');//TODO\n            } else {\n                const entityClassStatus = entityClass207Wrapper.status;\n                const entityClassContent = entityClass207Wrapper.content;\n                const entityClass = entityClasses[entityClassName];\n                let entityIds;\n                if (entityIdList === '*') {\n                    entityIds = Object.keys(entityClassContent);\n                } else {\n                    entityIds = entityIdList.split(',');\n                }\n                const entityClassState = entityClass.handleInput(entityClassStatus, entityClassContent, entityIds);\n                state.addSubState(entityClassState);\n            }\n        }\n    } else {\n        for (let entityClassName of entityClassNames) {\n            //TODO check if content of right form otherwise null\n            const entityClassContent = content[entityClassName];\n            const entityClass = entityClasses[entityClassName];\n            let entityIds;\n            if (entityIdList === '*') {\n                entityIds = Object.keys(entityClassContent);\n            } else {\n                entityIds = entityIdList.split(',');\n            }\n            const entityClassState = entityClass.handleInput(status, entityClassContent, entityIds);\n            state.addSubState(entityClassState);\n        }\n    }\n    return state;\n};\n\nfunction getResponse(uri, entityClasses) {\n    const path = uriTools.pathFromUri(uri);\n    const entityClassNames = (path.length === 0 || path[0] === '*')\n        ? Object.keys(entityClasses)\n        : path[0].split(',');\n    const content = {};\n    const subPath = path.slice(1);\n    for (let entityClassName of entityClassNames) {\n        if (entityClasses.hasOwnProperty(entityClassName)) {\n            content[entityClassName] = entityClasses[entityClassName].getEntityClassResponse(subPath);\n        } else {\n            //TODO replace null with something that has the endpoints required by Node\n            content[entityClassName] = new response.Node(null, entityId, 404, null, [`/${entityClassName} not found.`]); //TODO\n        }\n    }\n    return content;\n}\n\nexports.getResponse = getResponse;\nexports.Class = EntityClass;\nexports.handleInput = handleInput;\n\n//# sourceURL=webpack://xyz/./source/entity/entity.js?");

/***/ }),

/***/ "./source/entity/listener.js":
/*!***********************************!*\
  !*** ./source/entity/listener.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const State = __webpack_require__(/*! ./state.js */ \"./source/entity/state.js\").State;\nconst eventNames = ['changed', 'created', 'removed']; //TODO , 'error'\n\nfunction Listener(listenerHandler, eventName, entityId) {\n    this.stop = () => {\n        listenerHandler.removeListener(this);\n    };\n    this.getEntityId = () => entityId;\n    this.getEventName = () => eventName;\n}\n\nfunction ListenerHandler() {\n    const listenersPerEntityIdPerEventName = {};\n\n    const callListners = (eventName, entityId, listenerEntityId, node) => {\n        if (listenersPerEntityIdPerEventName.hasOwnProperty(listenerEntityId)) {\n            const listenersPerEventName = listenersPerEntityIdPerEventName[listenerEntityId];\n            if (listenersPerEventName.hasOwnProperty(eventName)) {\n                const listeners = listenersPerEventName[eventName];\n                listeners.forEach(callback => callback(entityId, node, eventName));\n            }\n        }\n    };\n\n    const callAllListeners = (eventName, entityId, node) => {\n        if (eventNames.indexOf(eventName) === -1) throw new Error('Listener eventName \"' + eventName + '\"  is not in allowed event names: ' + eventNames.join(', ') + '.');\n        console.log('callListener', this.getUri(entityId) + ':' + eventName);\n\n        callListners(eventName, entityId, '*', node);\n        callListners(eventName, entityId, entityId, node)\n    };\n\n    this.callAtomicListeners = (state, entityId, node) => {\n\n        if (typeof entityId !== 'string') throw new TypeError(\"entityId is not a string.\");\n        if (!state instanceof State) throw new TypeError(\"state is not a State.\");\n\n        if (state.isCreated()) {\n            callAllListeners('created', entityId, node);\n        } else if (state.isChanged()) {\n            callAllListeners('changed', entityId, node);\n        } else if (state.isRemoved()) {\n            callAllListeners('removed', entityId, node);\n            //TODO }else if(state.isError()){\n            callAllListeners('error', entityId, node);\n        } else {\n            // nothing to do\n        }\n    };\n\n    this.addAtomicListener = (entityId, eventName, callback) => {\n        if (typeof callback !== 'function') throw new TypeError(\"Listener callback is not a function.\");\n        if (typeof entityId !== 'string') throw new TypeError(\"Listener entityId is not a string.\");\n        if (typeof eventName !== 'string') throw new TypeError(\"Listener eventName is not a string.\");\n        if (eventNames.indexOf(eventName) === -1) throw new Error('Listener eventName \"' + eventName + '\"  is not in allowed event names: ' + eventNames.join(', ') + '.');\n\n        let listenersPerEventName;\n        if (!listenersPerEntityIdPerEventName.hasOwnProperty(entityId)) {\n            listenersPerEntityIdPerEventName[entityId] = {};\n        }\n        listenersPerEventName = listenersPerEntityIdPerEventName[entityId];\n        let listeners;\n        if (!listenersPerEventName.hasOwnProperty(eventName)) {\n            listenersPerEventName[eventName] = new Map();\n        }\n        const listener = new Listener(this, eventName, entityId);\n        listeners = listenersPerEventName[eventName];\n        listeners.set(listener, callback);\n\n        let count = 0;\n        for (let entityId in listenersPerEntityIdPerEventName) {\n            listenersPerEventName = listenersPerEntityIdPerEventName[entityId];\n            for (let eventName in listenersPerEventName) {\n                listeners = listenersPerEventName[eventName];\n                count += listeners.size;\n            }\n\n        }\n        console.log('addListener', this.getUri(entityId) + ':' + eventName, count);\n        return listener;\n    };\n\n    this.removeListener = listener => {\n        if (!listener instanceof Listener) throw new TypeError(\"listener is not a Listener.\");\n\n        const entityId = listener.getEntityId();\n        if (listenersPerEntityIdPerEventName.hasOwnProperty(entityId)) {\n            const listenersPerEventName = listenersPerEntityIdPerEventName[entityId];\n            const eventName = listener.getEventName();\n            if (listenersPerEventName.hasOwnProperty(eventName)) {\n                const listeners = listenersPerEventName[eventName];\n                if (listeners.has(listener)) {\n                    listeners.delete(listener);\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    this.hasListeners = (entityId, eventName) => {\n        if (typeof entityId === 'undefined') {\n            return Object.keys(listenersPerEntityIdPerEventName).length > 0;\n        } else if (entityId === '*') {\n            if (typeof eventName === 'undefined') {\n                return Object.keys(listenersPerEntityIdPerEventName).length > 0;\n            } else if (typeof eventName === 'string') {\n                for (let entityId in listenersPerEntityIdPerEventName) {\n                    if (listenersPerEntityIdPerEventName[entityId].hasOwnProperty(eventName)) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                throw new TypeError(\"eventName is not a string.\");\n            }\n        } else if (typeof entityId === 'string') {\n            if (listenersPerEntityIdPerEventName.hasOwnProperty(entityId)) {\n                if (typeof eventName === 'undefined') {\n                    return true;\n                } else if (typeof eventName === 'string') {\n                    return listenersPerEntityIdPerEventName[entityId].hasOwnProperty(eventName);\n                } else {\n                    throw new TypeError(\"eventName is not a string.\");\n                }\n            }\n        } else {\n            throw new TypeError(\"entityId is not a string.\");\n        }\n    };\n\n    this.removeListeners = (entityId, eventName) => {\n        if (typeof entityId === 'undefined') {\n            for (let entityId in listenersPerEntityIdPerEventName) {\n                delete listenersPerEntityIdPerEventName[entityId];\n            }\n        } else if (entityId === '*') {\n            if (typeof eventName === 'undefined') {\n                for (let entityId in listenersPerEntityIdPerEventName) {\n                    delete listenersPerEntityIdPerEventName[entityId];\n                }\n            } else if (typeof eventName === 'string') {\n                for (let entityId in listenersPerEntityIdPerEventName) {\n                    if (listenersPerEntityIdPerEventName[entityId].hasOwnProperty(eventName)) {\n                        delete listenersPerEntityIdPerEventName[entityId][eventName];\n                    }\n                }\n                if (Object.keys(listenersPerEntityIdPerEventName[entityId]).length === 0) {\n                    delete listenersPerEntityIdPerEventName[entityId];\n                }\n                return false;\n            } else {\n                throw new TypeError(\"eventName is not a string.\");\n            }\n        } else if (typeof entityId === 'string') {\n            if (listenersPerEntityIdPerEventName.hasOwnProperty(entityId)) {\n                if (typeof eventName === 'undefined') {\n                    delete listenersPerEntityIdPerEventName[entityId];\n                } else if (typeof eventName === 'string') {\n                    delete listenersPerEntityIdPerEventName[entityId][eventName];\n                    if (Object.keys(listenersPerEntityIdPerEventName[entityId]).length === 0) {\n                        delete listenersPerEntityIdPerEventName[entityId];\n                    }\n                } else {\n                    throw new TypeError(\"eventName is not a string.\");\n                }\n            }\n        } else {\n            throw new TypeError(\"entityId is not a string.\");\n        }\n    }\n}\n\nexports.Handler = ListenerHandler;\n\n\n//# sourceURL=webpack://xyz/./source/entity/listener.js?");

/***/ }),

/***/ "./source/entity/property.js":
/*!***********************************!*\
  !*** ./source/entity/property.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const types = __webpack_require__(/*! ../../build/types.js */ \"./build/types.js\");\nconst listener = __webpack_require__(/*! ./listener.js */ \"./source/entity/listener.js\");\nconst State = __webpack_require__(/*! ./state.js */ \"./source/entity/state.js\").State;\nconst response = __webpack_require__(/*! ./response.js */ \"./source/entity/response.js\");\nconst render = __webpack_require__(/*! ../render/render.js */ \"./source/render/render.js\");\nconst Item = __webpack_require__(/*! ../render/item.js */ \"./source/render/item.js\").constructor;\n\nfunction changed(a, b) {\n    switch (typeof a) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return a !== b;\n        case 'undefined':\n            return typeof b !== 'undefined';\n        case 'function':\n            return false;\n        case 'object':\n            if (a === null) {\n                return b !== null;\n            } else if (typeof b !== 'object' || b === null) {\n                return false\n            } else {\n                for (let key in a) {\n                    if (b.hasOwnProperty(key)) {\n                        if (changed(a[key], b[key])) return true\n                    }else{\n                        return true;\n                    }\n                }\n                for (let key in b) {\n                    if (!a.hasOwnProperty(key)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n    }\n}\n\nexports.constructor = function Property(xyz, parent, propertyName, meta) {\n    listener.Handler.call(this);\n\n    const subProperties = {};\n    const contents = {};\n    const errors = {};//TODO\n    const statusses = {};//TODO\n\n    const type = meta.type;\n    //TODO handle type alliasses?\n    const settings = meta; //TODO check if object\n    let isId = false;\n    if (settings.hasOwnProperty('storage')) {\n        if (settings.storage.key === 'key' || settings.storage.key === 'basename') {\n            isId = true;\n        }\n    }\n    let isPrimitive = true;\n    if (settings.hasOwnProperty('signature')) {\n        isPrimitive = false;\n        for (let propertyName in settings.signature) {\n            subProperties[propertyName] = new Property(xyz, this, propertyName, settings.signature[propertyName]);\n        }\n    }\n\n    this.getSettings = () => settings;\n\n    this.getUri = entityId => parent.getUri(entityId) + '/' + propertyName;\n\n    this.getResponse = (path, entityId) => {\n        if (isPrimitive) {\n            return new response.Node(this, entityId, statusses[entityId], contents[entityId], errors[entityId]);\n        } else {\n            const subPropertyNames = (path.length === 0 || path[0] === '*')\n                ? Object.keys(subProperties)\n                : path[0].split(',');\n            const content = {};\n            const subPath = path.slice(1);\n            for (let subPropertyName of subPropertyNames) {\n                if (subProperties.hasOwnProperty(subPropertyName)) {\n                    content[subPropertyName] = subProperties[subPropertyName].getResponse(subPath, entityId);\n                } else {\n                    content[subPropertyName] = new response.Node(this, entityId, 400, null, [`${subPropertyName} does not exist.`]); //TODO\n                }\n            }\n            return content;\n        }\n    };\n\n    this.callListeners = (state, entityId) => {\n        this.callAtomicListeners(state, entityId, this.getResponse([], entityId));\n        parent.callListeners(state.getParentState(), entityId);\n    };\n\n    this.handleInput = (entityId, propertyStatus, propertyContent) => {\n        const state = new State();\n        if (isPrimitive) {\n            if (contents.hasOwnProperty(entityId)) {\n                const prevPropertyContent = contents[entityId];\n                switch (propertyStatus) {\n                    case 200:\n                        if (changed(prevPropertyContent, propertyContent) && typeof propertyContent !== 'undefined') {\n                            state.setChanged();\n                        }\n                        contents[entityId] = propertyContent;\n                        break;\n                    case 404:\n                        //TODO use message frop source if available\n                        // TODO check if error is new eg compare with current error in errors\n                        state.setError(404, 'Not found');\n                        break;\n                    default:\n                        //state.setError(); // TODO compare with current error in errors\n                        throw new Error('Unsupported status ' + propertyStatus);\n                }\n            } else { // if 200 then changed else error\n                switch (propertyStatus) {\n                    case 200:\n                        if (typeof propertyContent !== 'undefined') {\n                            state.setChanged(); // TODO if new array value then Created\n                            contents[entityId] = propertyContent;\n                        }\n                        break;\n                    case 404:\n                        //TODO use message frop source if available\n                        // TODO check if error is new eg compare with current error in errors\n                        state.setError(404, 'Not found');\n                        break;\n                    default:\n                        //state.setError(); TODO compare with current error in errors\n                        throw new Error('Unsupported status ' + propertyStatus);\n                }\n            }\n        } else if (propertyStatus === 207) {\n            for (let subPropertyName in subProperties) {\n                const subProperty207Wrapper = propertyContent[subPropertyName];\n                if (subProperty207Wrapper === null || typeof subProperty207Wrapper !== 'object'\n                    || !subProperty207Wrapper.hasOwnProperty('status')\n                    || !subProperty207Wrapper.hasOwnProperty('content')\n                ) {\n                    //TODO reponse is in error\n                    console.error('error response in wrong format');\n                } else {\n                    const subProperty = subProperties[subPropertyName];\n                    const subStatus = subProperty207Wrapper.status;\n                    const subContent = subProperty207Wrapper.content;\n                    const subState = subProperty.handleInput(entityId, subStatus, subContent);\n                    state.addSubState(subState);\n                }\n            }\n        } else {\n            for (let subPropertyName in subProperties) {\n                const subProperty = subProperties[subPropertyName];\n                const subPropertyContent = (propertyContent === null || typeof propertyContent !== 'object')\n                    ? null\n                    : propertyContent[subPropertyName];\n                const subState = subProperty.handleInput(entityId, propertyStatus, subPropertyContent);\n                state.addSubState(subState);\n            }\n        }\n        statusses[entityId] = state.getStatus();\n        this.callListeners(state, entityId);\n        return state;\n    };\n\n    this.addPropertyListener = (entityId, path, eventName, callback) => {\n        const listeners = [];\n        if (path.length === 0) {\n            const listener = this.addAtomicListener(entityId, eventName, callback);\n            listeners.push(listener);\n        } else if (isPrimitive) {\n            //TODO error\n            console.error('No subproperties, property is primitive')\n        } else {\n            const subPropertNameList = path[0];\n            const subPropertyNames = subPropertNameList === '*'\n                ? Object.keys(properties)\n                : subPropertNameList.split(',');\n            const subPath = path.slice(1);\n            for (let subPropertyName of subPropertyNames) {\n                if (subProperties.hasOwnProperty(subPropertyName)) {\n                    const subPropertyListeners = subProperties[subPropertyName].addPropertyListener(entityId, subPath, eventName, callback)\n                    listeners.push(...subPropertyListeners);\n                } else {\n                    //TODO throw error?\n                    console.error(subPropertyName + 'not available')\n                }\n            }\n        }\n        return listeners;\n    };\n\n    this.createCreator = (options, data, xyz) => {\n        const TRs = [];\n        if (types.hasOwnProperty(type) && types[type].hasOwnProperty('edit')) {\n            if (type === 'id') {\n                return TRs;\n            }\n            const uri = this.getUri('*'); //TODO double check this\n            const content = settings.hasOwnProperty('default') ? settings.default : null;\n            // TODO html label for gebruiken\n            const TR = document.createElement('TR');\n            const TD_label = document.createElement('TD');\n            TD_label.innerText = propertyName;\n            TR.appendChild(TD_label);\n            const onChange = content => {\n                data[propertyName] = content;\n            };\n            const item = new Item(xyz, uri, 200, content, settings, options, onChange);\n            const element = types[type].edit(item);\n            const TD_content = document.createElement('TD');\n            TD_content.appendChild(element);\n            TR.appendChild(TD_content);\n            TRs.push(TR);\n        } else if (!isPrimitive) {\n            for (let propertyName in subProperties) {\n                data[propertyName] = {};\n                TRs.push(...subProperties[propertyName].createCreator(options, data[propertyName], xyz));\n            }\n        }\n        return TRs;\n    };\n\n    this.isAutoIncremented = () => {\n        if (isPrimitive) {\n            return type === 'id';\n        } else {\n            for (let subPropertyName in subProperties) {\n                if (subProperties[subPropertyName].isAutoIncremented()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n\n    this.getIdFromContent = data => {\n        if (isPrimitive) {\n            return isId ? data : null;\n        } else {\n\n            if (typeof data !== 'object' || data === null) { //TODO is_object\n                return null;\n            }\n\n            for (let subPropertyName in subProperties) {\n                if (data.hasOwnProperty(subPropertyName)) {\n                    const id = subProperties[subPropertyName].getIdFromContent(data[subPropertyName]);\n                    if (id) {\n                        return id;\n                    }\n                }\n            }\n            return null;\n        }\n    };\n\n    this.render = (action, options, entityId) => {\n        //TODO get xyz here\n        if (isPrimitive) {\n            const uri = this.getUri(entityId);\n            const content = contents[entityId];\n            const status = statusses[entityId];\n            const TAG = render.element(xyz, action, uri, status, content, settings, options);\n            return TAG;\n        } else {\n            //TODO loop through subproperties and render all\n            const DIV = document.createElement('DIV');\n            for (let subPropertyName in subProperties) {\n                const TAG = subProperties[subPropertyName].render(action, options, entityId);\n                DIV.appendChild(TAG);\n            }\n            return DIV;\n        }\n    };\n};\n\n//# sourceURL=webpack://xyz/./source/entity/property.js?");

/***/ }),

/***/ "./source/entity/response.js":
/*!***********************************!*\
  !*** ./source/entity/response.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function filter(content, path) {\n    if (path.length === 0) {\n        return;\n    }\n    const subPath = path.slice(1);\n    const propertyNameList = path[0];\n    if (propertyNameList === '*') {\n        for (let propertyName in content) {\n            filter(content[propertyName], subPath);\n        }\n    } else {\n        const propertyNames = propertyNameList.split(',');\n        for (let propertyName in content) {\n            if (propertyNames.indexOf(propertyName) === -1) {\n                delete content[propertyName];\n            } else {\n                filter(content[propertyName], subPath);\n            }\n        }\n    }\n}\n\nfunction Node(object, entityId, status_, content_, errors_) {\n    const status = status_;\n    const content = content_;\n    const errors = errors_;\n    this.getStatus = () => status;\n    this.getContent = () => content;\n    this.getErrors = () => errors;\n    this.render = (action, options) => object.render(action, options, entityId);\n}\n\nexports.filter = filter;\nexports.Node = Node;\n\n//# sourceURL=webpack://xyz/./source/entity/response.js?");

/***/ }),

/***/ "./source/entity/state.js":
/*!********************************!*\
  !*** ./source/entity/state.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function State() {\n    // let status;\n    let created = false;\n    let changed = false;\n    let removed = false;\n    let error = false;\n    const errors = [];\n\n    let subStatus;\n\n    this.getParentState = () => {\n        const parentState = new State();\n        if (changed || created || removed) parentState.setChanged();\n        for (let error of errors) {\n            parentState.setError(error.status, error.message);\n        }\n        return parentState;\n    };\n\n    this.setCreated = () => {\n        created = true;\n    };\n    this.setChanged = () => {\n        changed = true;\n    };\n    this.setRemoved = () => {\n        removed = true;\n    };\n    this.setError = (status, message) => {\n        error = true;\n        errors.push({status, message})\n    };\n    this.isChanged = () => changed && !created;\n    this.isRemoved = () => removed;\n    this.isCreated = () => created;\n    this.isError = () => error;\n\n    this.getStatus = () => {\n        // TODO mixed?\n        if (this.isError()) return 404; //TODO support more errors etc\n        if (this.isCreated()) return 201;\n        if (this.isChanged()) return 201;\n        if (this.isRemoved()) return 410;\n        return 304;\n    };\n\n    this.addSubState = subState => {\n        const newSubStatus = subState.getStatus();\n\n        if (typeof subStatus === 'undefined') {\n            subStatus = newSubStatus;\n        } else if (newSubStatus !== subStatus) {\n            subStatus = 207;\n        }\n\n        if (subState.isChanged() || subState.isRemoved() || subState.isCreated()) {\n            changed = true;\n        }\n    };\n}\n\nexports.State = State;\n\n//# sourceURL=webpack://xyz/./source/entity/state.js?");

/***/ }),

/***/ "./source/main.js":
/*!************************!*\
  !*** ./source/main.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const entity = __webpack_require__(/*! ./entity/entity.js */ \"./source/entity/entity.js\");\nconst response = __webpack_require__(/*! ./entity/response.js */ \"./source/entity/response.js\");\nconst uriTools = __webpack_require__(/*! ./uri/uri.js */ \"./source/uri/uri.js\");\nconst render = __webpack_require__(/*! ./render/render.js */ \"./source/render/render.js\");\nconst web = __webpack_require__(/*! ./web/web.js */ \"./source/web/web.js\");\nconst displays = __webpack_require__(/*! ../build/displays */ \"./build/displays.js\");\n\n\nconst DEFAULT_ACTION = 'view';\nconst DEFAULT_DISPLAYNAME = 'item';\nconst DEFAULT_TAG = 'DIV';\n\nfunction request(method, uri, data, callback) {\n    //TODO allow for multiple hosts by prepending http(s)://..\n    const location = 'http://localhost:8888/site/'; //TODO determine dynamically\n    const xhr = new XMLHttpRequest();\n    xhr.open(method, location + 'api' + uri, true);\n\n    xhr.onreadystatechange = e => {\n        if (xhr.readyState === 4) {\n            const status = xhr.status;\n            const content = xhr.responseText;\n            callback(status, content);\n        }\n    };\n    xhr.send(data);\n}\n\nfunction XYZ() {\n    const entityClasses = {};\n    const variables = {};\n\n    this.hasVariable = variableName => variables.hasOwnProperty(variableName);\n    this.getVariable = (variableName, fallback) => variables.hasOwnProperty(variableName) ? variables[variableName] : fallback;\n\n    const handleVariableChange = variableName => {\n        web.setQueryParameter(variableName, variables[variableName]);\n\n        for (let uri in uriCallbacks) {\n            if (uri.indexOf('$' + variableName) !== -1) { // TODO find ${variableName} and ignore $variableNameWithPostfix\n                for (let callback of uriCallbacks[uri]) {\n                    handleUri(uri, callback);\n                }\n            }\n        }\n    };\n\n    this.clearVariable = variableName => {\n        delete variables[variableName];\n        handleVariableChange(variableName);\n    };\n\n    this.setVariable = (variableName, value) => {\n        if (value !== variables[variableName]) {\n            variables[variableName] = value;\n            handleVariableChange(variableName);\n        }\n    };\n\n    this.setVariables = (variableObject) => {\n        for (let variableName in variableObject) {\n            this.setVariable(variableName, variableObject[variableName]);\n        }\n    };\n\n    const loadWindowListener = window.addEventListener('load', () => {\n        this.setVariables(web.getQueryParameters());\n        window.removeEventListener('load', loadWindowListener);\n    });\n\n    const uriCallbacks = {};\n\n    function handleUri(uri, callbacks) {\n        let complete = true;\n        //TODO find ${variableName}\n        uri = uri.replace(/\\$(\\w+)/, (_, variableName) => {\n            if (variables.hasOwnProperty(variableName)) {\n                return variables[variableName];\n            } else {\n                complete = false;\n                return '$' + variableName;\n            }\n        });\n        if (typeof callbacks.wait === 'function') {\n            callbacks.wait(uri);\n        }\n        if (complete) {\n            callbacks.ready(uri);\n        }\n    }\n\n    /* setInterval(()=>{\n         for(let uri in uriCallbacks){\n             for(let callback of uriCallbacks[uri]){\n                 handleUri(uri,callback);\n             }\n         }\n     },2000)*/\n\n    function registerUri(uri, readyCallback, waitCallback) {\n        const callbacks = {ready: readyCallback, wait: waitCallback};\n        if (!uriCallbacks.hasOwnProperty(uri)) {\n            uriCallbacks[uri] = [callbacks];\n        } else {\n            uriCallbacks[uri].push(callbacks);\n        }\n        handleUri(uri, callbacks);\n    }\n\n    const retrieveMeta = (uri, callback) => {\n        const path = uri.substr(1).split('/');\n        const entityClassNameList = path[0]; // TODO error if no entityClass\n\n        const entityClassNames = entityClassNameList.split(',').filter(entityClass => !entityClasses.hasOwnProperty((entityClass)));\n        if (entityClassNames.length === 0) {\n            callback();\n        } else {\n            request('GET', '/' + entityClassNames.join(',') + '?meta', undefined, (status, content) => {//TODO add querystring better\n                //TODO check status\n                console.log(uri, content);\n                const data = JSON.parse(content); //TODO check\n                // TODO validate data\n                for (let entityClassName of entityClassNames) {\n                    if (!entityClasses.hasOwnProperty(entityClassName)) {\n                        entityClasses[entityClassName] = new entity.Class(this, entityClassName, data[entityClassName]['*']);\n                    }\n                }\n                callback();\n            });\n        }\n    };\n\n    this.patch = (uri, content, callback) => {\n        console.log('patch request', uri, content)\n        content = typeof content === 'string' ? content : JSON.stringify(content);\n        request('PATCH', uri, content, (status, response) => {\n            //TODO check for errors\n            console.log('patch response:' + response, uri);\n            const state = entity.handleInput(uri, status, content, entityClasses);\n            //TODO callback?\n        });\n    };\n\n    this.put = (uri, content, callback) => {\n        console.log('put request', uri, content)\n        content = typeof content === 'string' ? content : JSON.stringify(content);\n        request('PUT', uri, content, (status, response) => {\n            //TODO check for errors\n            console.log('put response', uri, response)\n            const state = entity.handleInput(uri, status, content, entityClasses);\n            //TODO callback\n        });\n    };\n\n    this.head = (uri, content, callback) => {\n        //TODO\n    };\n    this.post = (uri, content, callback) => {\n        console.log('post request', uri, content);\n        content = typeof content === 'string' ? content : JSON.stringify(content);\n        request('POST', uri, content, (status, response) => {\n            //TODO check for errors\n            console.log('post response:' + response, uri)\n            const state = entity.handleInput(uri, status, content, entityClasses);\n            //TODO callback\n        });\n    };\n\n    // callback = Response =>{}\n    // get the requested uri from cache or request it from server\n    this.get = (uri, dataCallback, metaCallBack) => {\n        // get the meta data\n\n        retrieveMeta(uri, () => {\n            if (typeof metaCallBack === 'function') {\n                metaCallBack();\n            }\n\n            //TODO meta should be good or we have a problem\n            //TODO get the data from cache if already in cache\n            request('GET', uri, undefined, (status, content) => {//TODO add querystring better\n                const state = entity.handleInput(uri, status, content, entityClasses);\n                if (typeof dataCallback === 'function') {\n                    dataCallback(state);//TODO hier wordt nog niets mee gedaan...\n                }\n            });\n        });\n    };\n\n    //============================================================\n    // RENDERING should be refactored with better naming\n    //============================================================\n\n\n    const renderUiCreate = (uri, options, TAG) => {\n        retrieveMeta(uri, () => {\n            const entityClassName = uriTools.pathFromUri(uri)[0];\n            const entityClass = entityClasses[entityClassName];\n            const data = {};\n            const TABLE = entityClass.createCreator(options, data, this);\n            TAG.appendChild(TABLE);\n            const INPUT = document.createElement('INPUT');\n            INPUT.type = 'submit';\n            INPUT.onclick = () => {\n                if (entityClass.isAutoIncremented()) {\n                    this.post(uri, {[entityClassName]: {'new': data}},);\n                } else {\n                    const entityId = entityClass.getIdFromContent(data);\n                    this.put(uri + '/' + entityId, {[entityClassName]: {[entityId]: data}},);\n                }\n            };\n            TAG.appendChild(INPUT);\n        });\n        return TAG;\n    };\n\n\n    this.on = (uri, eventName, callback) => {\n        //TODO check type, callback and uri\n        const listeners = [];\n        const entityClassNames = uriTools.getEntityClassNames(uri, entityClasses);\n        const subPath = uriTools.pathFromUri(uri).slice(1);\n        for (let entityClassName of entityClassNames) {\n            if (entityClasses.hasOwnProperty(entityClassName)) {\n                const entityClassListeners = entityClasses[entityClassName].addListener(subPath, eventName, callback);\n                listeners.push(...entityClassListeners);\n            } else {\n                // TODO callback 404 on listener\n                // if eventName = 'error' or 404  callback(entityClassName);\n            }\n        }\n        return listeners;\n    };\n\n\n    const renderDisplay = (uri, options, WRAPPER) => (entityId, node) => {\n        const displayName = options.display || DEFAULT_DISPLAYNAME;\n        const display = displays[displayName];\n        const action = options.action || DEFAULT_ACTION;\n        const path = uriTools.pathFromUri(uri);\n        const entityClassNameList = path[0] || '*';\n        response.filter(node, path.slice(2)); // filter the content that was not requested\n\n        if (WRAPPER.classList.contains('xyz-empty')) {\n            WRAPPER.classList.remove('xyz-empty');\n            if (display && display.hasOwnProperty('first')) {\n                display.first(this, action, options, WRAPPER, entityId, node);\n            } else {\n                WRAPPER.innerHTML = '';\n            }\n        }\n\n        if (display && display.hasOwnProperty('entity')) {\n            display.entity(this, action, options, WRAPPER, entityId, node);\n        } else {\n            //TODO a default way of handeling stuff\n        }\n    };\n\n    this.renderElement = (action, uri, status, content, settings, options) => {\n        return render.element(this, action, uri, status, content, settings, options);\n    };\n\n    const displayListenersPerWrapper = new Map();\n\n    const renderUiElement = (uri, options, WRAPPER) => { //TODO rename\n        const displayName = options.display || DEFAULT_DISPLAYNAME;\n        if (!displays.hasOwnProperty(displayName)) {\n            throw new Error('Unrecognized displayName.');\n        }\n        const display = displays[displayName]; //TODO check?\n        const action = options.action || DEFAULT_ACTION;\n\n        WRAPPER.classList.add('xyz-waiting-for-data');\n        if (display && display.hasOwnProperty('waitingForData')) {\n            display.waitingForData(this, action, options, WRAPPER);\n        } else {\n            WRAPPER.innerHTML = 'Waiting for user data...';\n        }\n        registerUri(uri, uri => {\n                //TODO this can be called multiple times on variable changes,\n                WRAPPER.classList.remove('xyz-waiting-for-input');\n\n                WRAPPER.classList.add('xyz-empty');\n                if (display && display.hasOwnProperty('empty')) {\n                    display.empty(this, action, options, WRAPPER, uri);\n                } else {\n                    WRAPPER.innerHTML = 'Empty';\n                }\n\n                this.get(uri, () => {\n                    WRAPPER.classList.remove('xyz-waiting-for-data');\n                }, () => {\n                    const node = entity.getResponse(uri, entityClasses);\n                    for (let entityClassName in node) {\n                        for (let entityId in node[entityClassName]) {\n                            renderDisplay(uri, options, WRAPPER)(entityId, node[entityClassName][entityId]);\n                        }\n                    }\n\n                    if (displayListenersPerWrapper.has(WRAPPER)) {\n                        const listeners = displayListenersPerWrapper.get(WRAPPER);\n                        listeners.forEach(listener => listener.stop());\n                    }\n                    // FIXME dirty way of cleaning up all listeners by garbage collection\n                    // the problems lies with ui elements created by references,\n                    // those are drawn and then redraw with different wrappers when the base is updated\n                    //   e.g. BASE_WRAPPER->REF_WRAPPER1 ->  BASE_WRAPPER->REF_WRAPPER2\n                    //  BASE_WRAPPER is handled okay by the displayListenersPerWrapper.has(WRAPPER) above\n                    // but REF_WRAPPER1  not\n\n                    displayListenersPerWrapper.forEach((listeners, WRAPPER) => {\n                        if (!document.body.contains(WRAPPER)) {\n                            listeners.forEach(listener => listener.stop());\n                            displayListenersPerWrapper.delete(WRAPPER);\n                        }\n                    });\n\n                    const baseUri = uriTools.getBaseUri(uri);\n                    const listeners = this.on(baseUri, 'created', renderDisplay(uri, options, WRAPPER));\n                    displayListenersPerWrapper.set(WRAPPER, listeners);\n                });\n            },\n            () => {\n                WRAPPER.classList.add('xyz-waiting-for-input');\n                if (display && display.hasOwnProperty('waitingForInput')) {\n                    display.waitingForInput(this, action, options, WRAPPER);\n                } else {\n                    WRAPPER.innerHTML = 'Waiting for user input...';\n                }\n            });\n    };\n\n    this.ui = (uri, options, WRAPPER) => {//TODO rename\n        options = options || {};\n        let SCRIPT;\n        if (typeof WRAPPER === 'undefined') {\n            const tag = options.tag || DEFAULT_TAG;\n            WRAPPER = document.createElement(tag);\n            SCRIPT = document.currentScript;\n        }\n        if (options.id) {\n            WRAPPER.id = options.id;\n        }\n        if (options.class) {\n            WRAPPER.class = options.class || '';\n        }\n        if (SCRIPT) {\n            SCRIPT.parentNode.insertBefore(WRAPPER, SCRIPT);\n            SCRIPT.parentNode.removeChild(SCRIPT);\n        }\n        if (options.display === 'create') {\n            renderUiCreate(uri, options, WRAPPER);\n        } else {\n            renderUiElement(uri, options, WRAPPER);//TODO rename\n        }\n        return WRAPPER;\n    };\n}\n\nconst xyz = new XYZ();\nexports.ui = xyz.ui;\nexports.on = xyz.on;\n\n//TODO get(Variable)\n//TODO set(Variable(s))\n//TODO globals()\n\n\n\n//# sourceURL=webpack://xyz/./source/main.js?");

/***/ }),

/***/ "./source/render/item.js":
/*!*******************************!*\
  !*** ./source/render/item.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function Item(xyz, uri, status, content, settings, options, onChange) {\n\n    this.getUri = () => uri;\n    this.getStatus = () => status;\n    this.getContent = () => content;\n    this.getOptions = () => options;\n    this.getOption = optionName => options[optionName];\n    this.hasOption = optionName => options.hasOwnProperty(optionName);\n    this.getSettings = () => settings;\n    this.getSetting = settingName => settings[settingName];\n    this.hasSetting = settingName => settings.hasOwnProperty(settingName);\n\n    this.patch = onChange;\n    this.renderElement = xyz.renderElement;\n    this.validate = xyz.validate;\n    this.ui = xyz.ui;\n\n    // callback = (status,content)=>{...}\n    this.onChange = callback => {\n        xyz.on(uri, 'change', (entityId, node, eventName)=>{\n            //TODO get Node from node wrapper YOYO1\n        });\n        // TODO unregister these listeners somehow\n    }\n\n}\n\nexports.constructor = Item;\n\n//# sourceURL=webpack://xyz/./source/render/item.js?");

/***/ }),

/***/ "./source/render/render.js":
/*!*********************************!*\
  !*** ./source/render/render.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const types = __webpack_require__(/*! ../../build/types.js */ \"./build/types.js\");\nconst uriTools = __webpack_require__(/*! ../uri/uri.js */ \"./source/uri/uri.js\");\nconst Item = __webpack_require__(/*! ./item.js */ \"./source/render/item.js\").constructor;\n\nconst DEFAULT_TYPE = 'string';\n\nfunction renderElement(xyz, action, uri, status, content, settings, options) {\n    const type = settings.type || DEFAULT_TYPE;\n    if (!types.hasOwnProperty(type)) {\n        console.error('problem1');\n        return;\n    }\n    if (types[type].hasOwnProperty(action)) {\n        let onChange;\n        if (action === 'edit') {\n            onChange = content => {\n                xyz.patch(uri, uriTools.wrapContent(uri, content));\n            }\n        }\n        const item = new Item(xyz, uri, status, content, settings, options, onChange);\n        let TAG = types[type][action](item);\n\n        //TODO remove this in favor of item.onChange YOYO2\n\n        // Redraw the type on content change\n        const listeners = xyz.on(uri, 'changed', (entityId, node) => {\n            const newContent = node.getContent();\n            const newStatus = node.getStatus();\n            const PARENT = TAG.parentNode;\n            if(PARENT) {\n                const item = new Item(xyz, uri, newStatus, newContent, settings, options, onChange);\n                const TAG_new = types[type][action](item);\n                PARENT.insertBefore(TAG_new, TAG);\n                PARENT.removeChild(TAG);\n                TAG = TAG_new;\n            }else{\n                // TODO ERROR?? listeners should have been removed, remove them now?\n            }\n        });\n\n        TAG.className = `xyz-status-${status}`;\n        return TAG;\n    } else if (settings.hasOwnProperty('signature')) { // create editor from signature view\n        //TODO check if content if object\n        //TODO check if settings.signature is object\n        const DIV = document.createElement('DIV');\n        DIV.className = `xyz-status-${status}`;\n        for (let subPropertyName in settings.signature) {\n            const subSettings = settings.signature[subPropertyName];\n            const subContent = content[subPropertyName];\n            const subType = subSettings.type;\n            const subUri = uri + '/' + subPropertyName;\n            const TAG = renderElement(xyz, subType, action, subUri, status, subContent, subSettings, options);\n            TAG.className = `xyz-status-${status}`;\n            DIV.appendChild(TAG);\n        }\n        return DIV;\n    } else {\n        console.error('problem2');\n        //TODO something default and/or error\n    }\n}\n\nexports.element = renderElement;\n\n//# sourceURL=webpack://xyz/./source/render/render.js?");

/***/ }),

/***/ "./source/uri/uri.js":
/*!***************************!*\
  !*** ./source/uri/uri.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const pathFromUri = uri => {\n    if (uri.startsWith('/')) {\n        uri = uri.substr(1);\n    }\n    if (uri.endsWith('/')) {\n        uri = uri.slice(0, -1);\n    }\n    return uri.split('/');\n};\n\nconst wrapContent = (uri, content) => {\n    const wrapper = {};\n    const path = pathFromUri(uri);\n    let wrapperIterator = wrapper;\n    for (let depth = 0; depth < path.length; ++depth) {\n        const key = path[depth];\n        wrapperIterator = wrapperIterator[key] = (depth === path.length - 1) ? content : {};\n    }\n    return wrapper;\n};\n\nconst getEntityClassNames = (uri, entityClasses) => {\n    const path = pathFromUri(uri);\n    const entityClassNameList = path[0] || '*';\n    if (entityClassNameList === '*') {\n        return Object.keys(entityClasses);\n    } else {\n        return entityClassNameList.split(','); //TODO check if exist\n    }\n};\n\nconst getBaseUri = uri => {\n    const path0 = pathFromUri(uri)[0];\n    return '/' + (typeof path0 === 'string' ? path0 : '*');\n};\n\nexports.getBaseUri = getBaseUri;\nexports.getEntityClassNames = getEntityClassNames;\nexports.pathFromUri = pathFromUri;\nexports.wrapContent = wrapContent;\n\n//# sourceURL=webpack://xyz/./source/uri/uri.js?");

/***/ }),

/***/ "./source/web/web.js":
/*!***************************!*\
  !*** ./source/web/web.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.setCookie = function (keyValues, expiresInDays) {\n    const date = new Date();\n    date.setTime(date.getTime() + (expiresInDays * 24 * 60 * 60 * 1000));\n    const expires = 'expires=' + date.toUTCString();\n    for (let key in keyValues) {\n        document.cookie = key + '=' + keyValues[key] + ';' + expires + ';path=/';\n    }\n};\n\nexports.getCookie = function () {\n    if (document.cookie === '') {\n        return null;\n    }\n    const keyValuesPairs = document.cookie.split(';');\n    const cookie = {};\n    for (let keyValuePair of keyValuesPairs) {\n        const [key, value] = keyValuePair.split('=');\n        cookie[key.trim()] = value.trim();\n    }\n    return cookie;\n};\n\nfunction getQueryParameters() {\n    const queryParameters = {};\n    location.search\n        .substr(1) // '?a=1&b=2' -> 'a=1&b=2'\n        .split('&') // ['a=1','b=2']\n        .filter(x => x !== '')\n        .forEach(function (item) {\n            const [key, value] = item.split('='); // 'a=1' -> ['a','1']\n            queryParameters[decodeURIComponent(key)] = decodeURIComponent(value);\n        });\n    return queryParameters;\n}\n\nexports.getQueryParameters = getQueryParameters;\n\nexports.getQueryParameter = function (queryParameterName) {\n    return getQueryParameters()[queryParameterName];\n};\n\nfunction updateQueryParameter(queryParameterName, value) {\n    // '?a=1&b=2' -> ['a=1','b=2']\n    const keyValuePairs = document.location.search.substr(1).split('&').filter(x => x !== '');\n\n    let found = false;\n    for (let i = 0; i < keyValuePairs.length; ++i) {\n        const keyValuePair = keyValuePairs[i];\n        const otherKey = keyValuePair.split('=')[0];  //  'a=1' -> 'a'\n        if (otherKey === encodeURIComponent(queryParameterName)) {\n            keyValuePairs[i] = [encodeURIComponent(queryParameterName), encodeURIComponent(value)].join('='); // 'a=value'\n            found = true;\n            break;\n        }\n    }\n\n    if (!found) {\n        keyValuePairs[keyValuePairs.length] = [encodeURIComponent(queryParameterName), encodeURIComponent(value)].join('=');\n    }\n    if (keyValuePairs.length) {\n        return window.location.protocol + '//' + window.location.host + window.location.pathname + '?' + keyValuePairs.join('&');\n    } else {\n        return window.location.protocol + '//' + window.location.host + window.location.pathname;\n    }\n}\n\nexports.setQueryParameter = function (queryParameterName, value) {\n    const newUrl = updateQueryParameter(queryParameterName, value);\n    window.history.pushState({path: newUrl}, '', newUrl);\n};\n\n//# sourceURL=webpack://xyz/./source/web/web.js?");

/***/ })

/******/ });