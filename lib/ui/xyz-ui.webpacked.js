var xyz =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./source/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../types/array.js":
/*!*******************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/lib/types/array.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (xyz, uri, status, content, settings, options, onChange) {\n        // TODO create ui for adding/removing elements\n        // TODO create drop ui to drag elements to\n        const SPAN = document.createElement('SPAN');\n        //TODO check if content is array\n        const subSettings = settings.subType;\n        const subOptions = options; //TODO\n        for (let key in content) {\n            const subUri = uri + '/' + key;\n            const subContent = content[key];\n            const TAG = xyz.renderElement('view', subUri, status, subContent, subSettings, subOptions);\n            const DIV_sub = document.createElement('DIV');\n            const INPUT_remove = document.createElement('INPUT');\n            INPUT_remove.type = 'submit';\n            //TODO add class\n            // INPUT_remove.value = 'x';\n            DIV_sub.appendChild(INPUT_remove);\n            DIV_sub.appendChild(TAG);\n            SPAN.appendChild(DIV_sub);\n        }\n        const subUri = uri; //TODO add something\n        const newContent = null;//TODO default value\n        const DIV_CREATE = document.createElement('DIV');\n        const INPUT_create = document.createElement('INPUT');\n        INPUT_create.type = \"submit\";\n        //TODO add class\n        // INPUT_create.value = \"Add\";\n        const TAG_create = xyz.renderElement('edit', subUri, status, newContent, subSettings, subOptions);\n        DIV_CREATE.appendChild(TAG_create);\n        DIV_CREATE.appendChild(INPUT_create);\n        SPAN.appendChild(DIV_CREATE);\n        return SPAN;\n    },\n    view: function (xyz, uri, status, content, settings, options) {\n        const SPAN = document.createElement('SPAN');\n        //TODO check if content is array\n        const subSettings = settings.subType;\n        const subOptions = options; //TODO\n        for (let key in content) {\n            const subUri = uri + '/' + key;\n            const subContent = content[key];\n            const TAG = xyz.renderElement('view', subUri, status, subContent, subSettings, subOptions);\n            SPAN.appendChild(TAG);\n        }\n        return SPAN;\n    },\n    validate: function (xyz, uri, status, content, settings, options) {\n        if (content === null || typeof content !== 'object') {\n            return false;\n        }\n        const subSettings = settings.subType;\n        const subOptions = options; //TODO\n        for (let key in content) {\n            const subUri = uri + '/' + key;\n            const subContent = content[key];\n            if(!xyz.validate(subUri, subStatus, subContent, subSettings, subOptions)){return false;}\n        }\n        return true;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/lib/types/array.js?");

/***/ }),

/***/ "../../types/bool.js":
/*!******************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/lib/types/bool.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (xyz, uri, status, content, settings, options, onChange) {\n        //TODO radio flavor to distinguish two options\n        const INPUT = document.createElement('INPUT');\n        INPUT.type='checkbox';\n        INPUT.checked=!!content;\n        INPUT.onchange = () => {\n            const content = INPUT.checked;\n            onChange(content);\n        };\n        return INPUT;\n    },\n    view: function (xyz, uri, status, content, settings, options) {\n        const SPAN = document.createElement('SPAN');\n        //TODO 404 etc status outputs (refactor from string)\n        //TODO use settings to get yes|no label\n        SPAN.innerText = content ? 'yes':'no';\n        return SPAN;\n    },\n    validate: function (xyz, uri, status, content, settings, options) {\n        return typeof content === 'boolean';\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/lib/types/bool.js?");

/***/ }),

/***/ "../../types/enum.js":
/*!******************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/lib/types/enum.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (xyz, uri, status, content, settings, options, onChange) {\n        settings = settings || {};\n        const SELECT = document.createElement('SELECT');\n        SELECT.onchange = () => {\n            const content = SELECT.options[SELECT.selectedIndex].value;\n            onChange(content);\n        };\n\n        const choices = settings.choices instanceof Array ? settings.choices : [];\n        // TODO select default by default\n        for (let choice of choices) {\n            const OPTION = document.createElement('OPTION');\n            if (choice === content) {\n                OPTION.selected = true;\n            }\n            OPTION.innerText = choice; //TODO render choice content\n            // xyz.renderElement('view', uri, status, content, subSettings, options)\n            SELECT.appendChild(OPTION);\n        }\n        return SELECT;\n    },\n    view: function (xyz, uri, status, content, settings, options) {\n        const subSettings = settings.subType || {};\n        const TAG = xyz.renderElement('view', uri, status, content, subSettings, options);\n        return TAG;\n    },\n    validate: function (xyz, uri, status, content, settings, options) {\n        if (typeof settings !== 'object' || settings === null) {\n            return false;\n        }\n        const choices = settings.choices;\n        if (!choices instanceof Array) {\n            return false;\n        }\n        return choices.indexOf(content) !== -1;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/lib/types/enum.js?");

/***/ }),

/***/ "../../types/file.js":
/*!******************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/lib/types/file.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (xyz, uri, status, content, settings, options, onChange) {\n        const prepareContent = (files) => {\n            //TODO add filetype validation (using accept to catch client side injections)\n            const data = {};\n            if (settings.multiple) {\n                //TODO content = '[' + files.map(file => file.text()).join(',') + ']';\n            } else if (files.length === 0) {\n                //TODO\n            } else {\n                const reader = new FileReader();\n                reader.onload = evt => {\n                    data['content'] = evt.target.result;\n                    const extension = settings.signature['id'].storage.extension;\n                    let key;\n                    //TODO or extension is mixed extensions for example \"json|xml\"\n                    if (extension && extension !== '*') {\n                        key = files[0].name.split('.').splice('.').slice(0, -1).join('.');\n                    } else {\n                        key = files[0].name;\n                    }\n                    data['id'] = key;\n                    onChange(data);\n                };\n                reader.onerror = evt => {\n                    //TODO\n                };\n                reader.readAsText(files[0], \"UTF-8\");\n            }\n        };\n\n        // TODO add id from options (for label for)\n        const INPUT = document.createElement('INPUT');\n        INPUT.type = 'file';\n        if (content) {\n            INPUT.value = content;\n        }\n        if (onChange) {\n            INPUT.addEventListener('change', event => {\n                prepareContent(event.target.files, onChange);\n            });\n        }\n        if (settings.multiple) {\n            INPUT.multiple = true;\n        }\n        if (settings.accept) {\n            INPUT.accept = settings.accept;\n        }\n        return INPUT;\n    },\n    /*view: function (xyz, uri, status, content, settings, options) {\n        //TODO use a file viewer:   https://viewerjs.org/\n        return content;\n    },*/\n    validate: function (xyz, uri, status, content, settings, options) {\n        //TODO implement client side validation\n        //todo mime/accept\n        //todo max size\n        return true;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/lib/types/file.js?");

/***/ }),

/***/ "../../types/id.js":
/*!****************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/lib/types/id.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (xyz, uri, status, content, settings, options, onChange) {\n        //TODO make visible with options.something\n        const SPAN = document.createElement('SPAN');\n        SPAN.innerText = 'auto increment';\n        return SPAN;\n    },\n    view: function (xyz, uri, status, content, settings, options) {\n        //TODO make visible with options.something\n        const SPAN = document.createElement('SPAN');\n        SPAN.innerText = content;\n        return SPAN;\n    },\n    validate: function (xyz, uri, status, content, settings, options) {\n        //TODO should be 0 or null always?\n        return true;//TODO\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/lib/types/id.js?");

/***/ }),

/***/ "../../types/reference.js":
/*!***********************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/lib/types/reference.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (xyz, uri, status, content, settings, options, onChange) {\n        const flavor = options.flavor || 'dropdown';\n        //TODO set value\n        const TAG = xyz.ui('/' + settings.class + '/*/id', {\n            display: 'list',\n            flavor,\n            select: onChange,\n            initialValue: content\n        }); // TODO how to determine id or title?\n        return TAG;\n    },\n    view: function (xyz, uri, status, content, settings, options) {\n        const DIV = document.createElement('DIV');\n        xyz.ui('/' + settings.class + '/' + content, {display: 'item'}, DIV);\n        return DIV;\n    },\n    validate: function (xyz, uri, status, content, settings, options) {\n        //TODO implement client side validation specific for referenced entity type\n        return true;//TODO\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/lib/types/reference.js?");

/***/ }),

/***/ "../../types/string.js":
/*!********************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/lib/types/string.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (xyz, uri, status, content, settings, options, onChange) {\n        const INPUT = document.createElement('INPUT');\n        if (content) {\n            INPUT.value = content;\n        }\n        if (onChange) {\n            INPUT.oninput = event => {\n                onChange(event.target.value)\n            };\n        }\n\n        // TODO add id from options (for label for)\n        //TODO add validation regex\n\n        return INPUT;\n    },\n    view: function (xyz, uri, status, content, settings, options) {\n        const SPAN = document.createElement('SPAN');\n        switch (status) {\n            case 500 :\n                SPAN.innerText = 'Server error';\n                break;\n            case 400 :\n                SPAN.innerText = 'Bad request';\n                break;\n            case 403 :\n                SPAN.innerText = 'Forbidden';\n                break;\n            case 404 :\n                SPAN.innerText = 'Not found';\n                break;\n            default:\n                SPAN.innerText = content;\n                break;\n        }\n        return SPAN;\n    },\n    validate: function (xyz, uri, status, content, settings, options) {\n        //TODO implement client side validation\n        return true;//TODO\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/lib/types/string.js?");

/***/ }),

/***/ "./build/types.js":
/*!************************!*\
  !*** ./build/types.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// This file is created by gulpfile.js using the type definitions of lib/types/*.js. \n\nexports.array = __webpack_require__(/*! ../../../types/array.js */ \"../../types/array.js\").actions;\nexports.bool = __webpack_require__(/*! ../../../types/bool.js */ \"../../types/bool.js\").actions;\nexports.enum = __webpack_require__(/*! ../../../types/enum.js */ \"../../types/enum.js\").actions;\nexports.file = __webpack_require__(/*! ../../../types/file.js */ \"../../types/file.js\").actions;\nexports.id = __webpack_require__(/*! ../../../types/id.js */ \"../../types/id.js\").actions;\nexports.reference = __webpack_require__(/*! ../../../types/reference.js */ \"../../types/reference.js\").actions;\nexports.string = __webpack_require__(/*! ../../../types/string.js */ \"../../types/string.js\").actions;\n\n\n//# sourceURL=webpack://xyz/./build/types.js?");

/***/ }),

/***/ "./source/display/item.js":
/*!********************************!*\
  !*** ./source/display/item.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.render = (options, xyz) => (PARENT, TAG, key, uri, status, depth, primitive, fullUri) => {\n    if (depth === 0) {\n        const TABLE = document.createElement('TABLE');\n        PARENT.appendChild(TABLE);\n        return TABLE;\n    } else if (primitive) {\n        const TR = document.createElement('TR');\n        if (options.showLabel !== false) {\n            const TD_label = document.createElement('TD');\n            TD_label.innerHTML = key;\n            TR.appendChild(TD_label);\n        }\n        const TD_content = document.createElement('TD');\n        TD_content.appendChild(TAG);\n        TR.appendChild(TD_content);\n        PARENT.appendChild(TR);\n        return null;\n    } else {\n        return PARENT;\n    }\n};\n\n//# sourceURL=webpack://xyz/./source/display/item.js?");

/***/ }),

/***/ "./source/display/list.js":
/*!********************************!*\
  !*** ./source/display/list.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\nTODO add radio flavor to provide radio box\n\noptions\n- select\n- multiSelect\n- flavor  table|dropdown|TODO radio\n- addCreateButton\n- TODO default\n- TODO addDeleteButtons\n- TODO addEditButtons\n- TODO add multiselect tools\n */\n\nconst DEFAULT_FLAVORNAME = 'table';\nconst flavors = {};\n\nfunction select(xyz, options, entityId) {\n    if (typeof options.select === 'string') {\n        xyz.setVariable(options.select, entityId);\n    } else if (typeof options.select === 'function') {\n        options.select(entityId);\n    }\n}\n\nflavors.table = (options, xyz) => (PARENT, TAG, key, uri, status, depth, primitive, fullUri) => {\n    if (depth === 0) {\n        const TABLE = document.createElement('TABLE');\n        TABLE.className = 'xyz-list';\n        const TR_header = document.createElement('TR');\n        TR_header.className = 'xyz-list-header';\n        if (options.multiSelect) {\n            const TD = document.createElement('TD');\n            TR_header.appendChild(TD);\n        }\n        TABLE.appendChild(TR_header);\n        PARENT.appendChild(TABLE);\n        return TABLE;\n    } else if (depth === 2) {\n        const TABLE = PARENT;\n        const entityId = key;\n        const TR = document.createElement('TR');\n        TR.className = 'xyz-list-item';\n        if (options.multiSelect) {\n            const variableName = options.multiSelect;\n            const TD = document.createElement('TD');\n            const INPUT = document.createElement('INPUT');\n            INPUT.type = \"checkbox\";\n            INPUT.onclick = event => {\n                const entityIds = xyz.hasVariable(variableName)\n                    ? xyz.getVariable(variableName).split(',')\n                    : [];\n                if (INPUT.checked) {\n                    if (!entityIds.includes(entityId)) {\n                        entityIds.push(entityId);\n                    }\n                } else {\n                    const index = entityIds.indexOf(entityId);\n                    if (index !== -1) {\n                        entityIds.splice(index, 1);\n                    }\n                }\n                if (entityIds.length === 0) {\n                    xyz.clearVariable(variableName);\n                } else {\n                    xyz.setVariable(variableName, entityIds.join(','));\n                }\n                event.stopPropagation();\n            };\n            TD.appendChild(INPUT);\n            TR.appendChild(TD);\n        }\n        if (options.select) {\n            if (xyz.getVariable(options.select) === entityId || options.default === entityId) {\n                TR.classList.add('xyz-list-selected');\n            }\n            TR.onclick = () => {\n                select(xyz, options, entityId);\n                for (let row of TABLE.childNodes) {\n                    if (row === TR) {\n                        row.classList.add('xyz-list-selected');\n                    } else {\n                        row.classList.remove('xyz-list-selected');\n                    }\n                }\n            };\n        }\n        TABLE.appendChild(TR);\n        return TR;\n    } else if (primitive) {\n        const TR = PARENT;\n        const TABLE = TR.parentNode;\n        const TR_header = TABLE.firstChild;\n        let found = false;\n        for (let TD_header of TR_header.childNodes) {\n            if (TD_header.innerHTML === key) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            const TD_header = document.createElement('TD');\n            TD_header.innerHTML = key;\n            TR_header.appendChild(TD_header);\n        }\n        const TD = document.createElement('TD');\n        TD.appendChild(TAG);\n        TR.appendChild(TD);\n        return null;\n    } else {\n        return PARENT;\n    }\n};\n\nflavors.dropdown = (options, xyz) => (PARENT, TAG, key, uri, status, depth, primitive, fullUri) => {\n    if (depth === 0) {\n        const SELECT = document.createElement('SELECT');\n        SELECT.onchange = () => {\n            const entityId = SELECT.options[SELECT.selectedIndex].value;\n            select(xyz, options, entityId);\n        };\n        PARENT.appendChild(SELECT);\n        return SELECT;\n    } else if (primitive) {\n        const SELECT = PARENT;\n        const entityId = TAG.innerHTML;\n        if (SELECT.childElementCount === 0 && !options.initialValue) { // select the first option as default TODO unless other default is defined\n            select(xyz, options, entityId);\n        }\n\n        const OPTION = document.createElement('OPTION');\n        if (options.initialValue === entityId) {\n            select(xyz, options, entityId);\n            OPTION.selected = true;\n        }\n        OPTION.appendChild(TAG);\n        SELECT.appendChild(OPTION);\n        return PARENT;\n    } else {\n        return PARENT;\n    }\n};\n\nfunction addCreateButton(xyz, fullUri, PARENT, options) {\n    //TODO only if has the permissions to add\n    if (options.addCreateButton !== false) {\n        const INPUT = document.createElement('INPUT');\n        INPUT.type = \"submit\";\n        //TODO add class\n        INPUT.value = \"+\";\n        INPUT.onclick = () => {\n            if (DIV.style.display === 'none') {\n                DIV.style.display = 'block';\n                INPUT.value = \"-\";\n            } else {\n                INPUT.value = \"+\";\n                DIV.style.display = 'none';\n            }\n        };\n        PARENT.appendChild(INPUT);\n        const DIV = document.createElement('DIV');\n        DIV.style.display = 'none';\n        const entityClassName = fullUri.substr(1).split('/')[0];\n        xyz.ui('/' + entityClassName, {display: 'create'}, DIV);\n        PARENT.appendChild(DIV);\n    }\n}\n\nexports.render = (options, xyz) => (PARENT, TAG, key, uri, status, depth, primitive, fullUri) => {\n    const flavorName = options.flavor || DEFAULT_FLAVORNAME;\n    //TODO check if flavor exists\n    if (depth === 0) {\n        const DIV = document.createElement('DIV');\n        const TAG_display = flavors[flavorName](options, xyz)(DIV, TAG, key, uri, status, depth, primitive, fullUri);\n        PARENT.appendChild(DIV);\n        addCreateButton(xyz, fullUri, DIV, options);\n        return TAG_display;\n    } else {\n        return flavors[flavorName](options, xyz)(PARENT, TAG, key, uri, status, depth, primitive, fullUri);\n    }\n};\n\n\n\n//# sourceURL=webpack://xyz/./source/display/list.js?");

/***/ }),

/***/ "./source/entity/entity.js":
/*!*********************************!*\
  !*** ./source/entity/entity.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Property = __webpack_require__(/*! ./property.js */ \"./source/entity/property.js\").constructor;\nconst Response = __webpack_require__(/*! ../response/response.js */ \"./source/response/response.js\").constructor;\nconst listener = __webpack_require__(/*! ./listener.js */ \"./source/entity/listener.js\");\nconst uriTools = __webpack_require__(/*! ../uri/uri.js */ \"./source/uri/uri.js\");\nconst State = __webpack_require__(/*! ./state.js */ \"./source/entity/state.js\").State;\nconst response = __webpack_require__(/*! ./response.js */ \"./source/entity/response.js\");\n\nfunction EntityClass(entityClassName, settings) {\n    if (typeof entityClassName !== 'string') throw new TypeError('entityClassName not a string.');\n\n    const entities = {}; //TODO mark if entities are new or have been removed\n\n    listener.Handler.call(this);\n\n    const properties = {};\n\n    for (let propertyName in settings) {\n        properties[propertyName] = new Property(this, propertyName, settings[propertyName]);\n    }\n\n    this.getSettings = () => settings;\n\n    this.getUri = entityId => {\n        if (typeof entityId !== 'string') throw new TypeError('entityId not a string.');\n\n        return '/' + entityClassName + '/' + entityId;\n    };\n\n    this.addListener = (path, eventName, callback) => {\n        //TODO check path, callback and uri\n        // TODO only if path.length <= 1 ? otherwise send to properties\n        const entityIds = (path.length === 0 || path[0] === '*')\n            ? ['*']\n            : entityIds.split('.');\n        for (let entityId of entityIds) {\n            this.addEntityIdListener(entityId, eventName, callback);\n        }\n    };\n\n    //TODO MAYBE make private / remove\n    this.getEntityIdResponse = (path, entityId) => {\n        const propertyNames = (path.length === 0 || path[0] === '*')\n            ? Object.keys(properties)\n            : path[0].split(',');\n        const response = {};\n        const subPath = path.slice(1);\n        for (let propertyName of propertyNames) {\n            if (properties.hasOwnProperty(propertyName)) {\n                response[propertyName] = properties[propertyName].getResponse(subPath, entityId);\n            } else {\n                response[propertyName] = new response.Node(400, null, [`${propertyName} does not exist.`]); //TODO\n            }\n        }\n        return response;\n    };\n\n    //TODO MAYBE make private /remove\n    this.getResponse = path => {\n        const entityIds = (path.length === 0 || path[0] === '*')\n            ? Object.keys(entities)\n            : path[0].split(',');\n        const response = {};\n        const subPath = path.slice(1);\n        for (let entityId of entityIds) {\n            if (entities.hasOwnProperty(entityId)) {\n                response[entityId] = this.getEntityIdResponse(subPath, entityId);\n            } else {\n                response[entityId] = new response.Node(404, null, [`/${entityClassName}/${entityId} not found.`]); //TODO\n            }\n        }\n        return response;\n    };\n\n    this.createEntityIdResponse = (entityId, entityStatus, entityContent, isDelta) => {\n        if (typeof entityId !== 'string') throw new TypeError('entityId not a string.');\n        if (typeof entityStatus !== 'number') throw new TypeError('entityStatus not a number.');\n\n        const entityResponse = new Response();\n        if (entityStatus === 207) {\n            for (let propertyName in properties) {\n                const property207Wrapper = entityContent[propertyName];\n                if (property207Wrapper === null || typeof property207Wrapper !== 'object'\n                    || !property207Wrapper.hasOwnProperty('status')\n                    || !property207Wrapper.hasOwnProperty('content')\n                ) {\n                    //TODO response is in error\n                    console.error('error response in wrong format');\n                } else {\n                    const property = properties[propertyName];\n                    const propertyStatus = property207Wrapper.status;\n                    const propertyContent = property207Wrapper.content;\n                    const propertyResponse = property.createResponse(entityId, propertyStatus, propertyContent, isDelta);\n                    entityResponse.set(propertyName, propertyResponse);\n                }\n            }\n        } else {\n            for (let propertyName in properties) {\n                const property = properties[propertyName];\n                const propertyContent = (entityContent === null || typeof entityContent !== 'object')\n                    ? null\n                    : entityContent[propertyName];\n                const propertyResponse = property.createResponse(entityId, entityStatus, propertyContent, isDelta);\n                entityResponse.set(propertyName, propertyResponse)\n            }\n        }\n        //TOD this.callListeners(entityId, entityResponse, isDelta);\n        return entityResponse;\n    };\n\n    this.createEntityClassResponse = (entityClassStatus, entityClassContent, entityIds, isDelta) => {\n        const entityClassResponse = new Response();\n\n        if (entityClassStatus === 207) {\n            for (let entityId of entityIds) {\n                const entity207Wrapper = entityClassContent[entityId];\n                if (entity207Wrapper === null || typeof entity207Wrapper !== 'object'\n                    || !entity207Wrapper.hasOwnProperty('status')\n                    || !entity207Wrapper.hasOwnProperty('content')\n                ) {\n                    //TODO reponse is in error\n                    console.error('error response in wrong format');\n                } else {\n                    const entityStatus = entity207Wrapper.status;\n                    const entityContent = entity207Wrapper.content;\n                    const entityResponse = this.createEntityIdResponse(entityId, entityStatus, entityContent, isDelta);\n                    entityClassResponse.set(entityId, entityResponse)\n                }\n            }\n        } else {\n            for (let entityId of entityIds) {\n                const entityContent = (entityClassContent === null || typeof entityClassContent !== 'object')\n                    ? null\n                    : entityClassContent[entityId];\n                const entityResponse = this.createEntityIdResponse(entityId, entityClassStatus, entityContent, isDelta);\n                entityClassResponse.set(entityId, entityResponse)\n            }\n        }\n        return entityClassResponse;\n    };\n\n\n    this.createCreator = (options, data, xyz) => {\n        const TABLE = document.createElement('TABLE');\n        for (let propertyName in properties) {\n            for (let TR of properties[propertyName].createCreator(options, data, xyz)) {\n                TABLE.appendChild(TR);\n            }\n        }\n        return TABLE;\n    };\n\n    this.isAutoIncremented = () => {\n        for (let propertyName in properties) {\n            if (properties[propertyName].isAutoIncremented()) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    this.getIdFromContent = data => {\n        if (typeof data !== 'object' || data === null) {//TODO is_object\n            return null;\n        }\n        for (let propertyName in properties) {\n            if (data.hasOwnProperty(propertyName)) {\n                const id = properties[propertyName].getIdFromContent(data[propertyName]);\n                if (id) {\n                    return id;\n                }\n            }\n        }\n        return null;\n    };\n\n    this.transform = (entityClassSource, transformation) => {\n        const entityClassTarget = new Response();\n        for (let entityId of entityClassSource.keys()) {\n            const entitySource = entityClassSource.get(entityId);\n            const entityTarget = new Response();\n            for (let propertyName of entitySource.keys()) {\n                if (properties.hasOwnProperty(propertyName)) {\n                    const property = properties[propertyName];\n                    const subTarget = property.transform(entitySource.get(propertyName), transformation, entityId);\n                    entityTarget.set(propertyName, subTarget);\n                } else {\n                    console.error('entity transform: property does not exist');\n                    //TODO error\n                }\n            }\n            entityClassTarget.set(entityId, entityTarget);\n        }\n        return entityClassTarget;\n    };\n\n    const handleEntityIdInput = (entityId, entityStatus, entityContent) => {\n\n        if (typeof entityId !== 'string') throw new TypeError('entityId not a string.');\n        if (typeof entityStatus !== 'number') throw new TypeError('entityStatus not a number.');\n\n        entities[entityId] = true; //TODO hier moet meer mee\n        let state = new State();\n        if (entityStatus === 207) {\n            for (let propertyName in properties) {\n                const property207Wrapper = entityContent[propertyName];\n                if (property207Wrapper === null || typeof property207Wrapper !== 'object'\n                    || !property207Wrapper.hasOwnProperty('status')\n                    || !property207Wrapper.hasOwnProperty('content')\n                ) {\n                    //TODO response is in error\n                    console.error('error response in wrong format');\n                } else {\n                    const property = properties[propertyName];\n                    const propertyStatus = property207Wrapper.status;\n                    const propertyContent = property207Wrapper.content;\n                    const propertyState = property.handleInput(entityId, propertyStatus, propertyContent);\n                    state.addSubState(propertyState);\n                }\n            }\n        } else {\n            for (let propertyName in properties) {\n                const property = properties[propertyName];\n                const propertyContent = (entityContent === null || typeof entityContent !== 'object')\n                    ? null\n                    : entityContent[propertyName];\n                const propertyState = property.handleInput(entityId, entityStatus, propertyContent);\n                state.addSubState(propertyState);\n            }\n        }\n\n        this.callListeners(state, entityId, this.getEntityIdResponse([],entityId));\n        return state;\n    };\n\n    this.handleInput = (entityClassStatus, entityClassContent, entityIds) => {\n        const state = new State();\n        if (entityClassStatus === 207) {\n            for (let entityId of entityIds) {\n                const entity207Wrapper = entityClassContent[entityId];\n                if (entity207Wrapper === null || typeof entity207Wrapper !== 'object'\n                    || !entity207Wrapper.hasOwnProperty('status')\n                    || !entity207Wrapper.hasOwnProperty('content')\n                ) {\n                    //TODO reponse is in error\n                    console.error('error response in wrong format');\n                } else {\n                    const entityStatus = entity207Wrapper.status;\n                    const entityContent = entity207Wrapper.content;\n                    const entityState = handleEntityIdInput(entityId, entityStatus, entityContent);\n                    state.addSubState(entityState);\n                }\n            }\n        } else {\n            for (let entityId of entityIds) {\n                const entityContent = (entityClassContent === null || typeof entityClassContent !== 'object')\n                    ? null\n                    : entityClassContent[entityId];\n                const entityState = handleEntityIdInput(entityId, entityClassStatus, entityContent);\n                state.addSubState(entityState);\n            }\n        }\n        return state;\n    };\n}\n\n\nconst handleInput = (uri, status, content, entityClasses) => {\n    //TODO check status\n    content = JSON.parse(content);//TODO check\n\n    const state = new State();\n    const path = uriTools.pathFromUri(uri);\n    const entityClassNameList = path[0]; // TODO error if no entityClass\n    const entityIdList = path[1] || '*';\n    const entityClassNames = entityClassNameList.split(',');\n    if (status === 207) {\n        for (let entityClassName of entityClassNames) {\n            const entityClass207Wrapper = content[entityClassName];\n            if (entityClass207Wrapper === null || typeof entityClass207Wrapper !== 'object'\n                || !entityClass207Wrapper.hasOwnProperty('status')\n                || !entityClass207Wrapper.hasOwnProperty('content')\n            ) {\n                console.error('error response in wrong format');//TODO\n            } else {\n                const entityClassStatus = entityClass207Wrapper.status;\n                const entityClassContent = entityClass207Wrapper.content;\n                const entityClass = entityClasses[entityClassName];\n                let entityIds;\n                if (entityIdList === '*') {\n                    entityIds = Object.keys(entityClassContent);\n                } else {\n                    entityIds = entityIdList.split(',');\n                }\n                const entityClassState = entityClass.handleInput(entityClassStatus, entityClassContent, entityIds);\n                state.addSubState(entityClassState);\n            }\n        }\n    } else {\n        for (let entityClassName of entityClassNames) {\n            //TODO check if content of right form otherwise null\n            const entityClassContent = content[entityClassName];\n            const entityClass = entityClasses[entityClassName];\n            let entityIds;\n            if (entityIdList === '*') {\n                entityIds = Object.keys(entityClassContent);\n            } else {\n                entityIds = entityIdList.split(',');\n            }\n            const entityClassState = entityClass.handleInput(status, entityClassContent, entityIds);\n            state.addSubState(entityClassState);\n        }\n    }\n    return state;\n};\n\nfunction getResponse(uri, entityClasses) {\n    const path = uriTools.pathFromUri(uri);\n    const entityClassNames = (path.length === 0 || path[0] === '*')\n        ? Object.keys(entityClasses)\n        : path[0].split(',');\n    const response = {};\n    const subPath = path.slice(1);\n    for (let entityClassName of entityClassNames) {\n        if (entityClasses.hasOwnProperty(entityClassName)) {\n            response[entityClassName] = entityClasses[entityClassName].getResponse(subPath);\n        } else {\n            response[entityClassName] = new response.Node(404, null, [`/${entityClassName} not found.`]); //TODO\n        }\n    }\n    return response;\n}\n\nexports.getResponse = getResponse;\nexports.Class = EntityClass;\nexports.handleInput = handleInput;\n\n//# sourceURL=webpack://xyz/./source/entity/entity.js?");

/***/ }),

/***/ "./source/entity/listener.js":
/*!***********************************!*\
  !*** ./source/entity/listener.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const State = __webpack_require__(/*! ./state.js */ \"./source/entity/state.js\").State;\nconst eventNames = ['changed', 'created', 'removed']; //TODO , 'error'\n\nfunction Listener(listenerHandler, eventName, entityId) {\n    this.stop = () => {\n        listenerHandler.removeListener(this);\n    };\n    this.getEntityId = () => entityId;\n    this.getEventName = () => eventName;\n}\n\nfunction ListenerHandler() {\n    const listenersPerEntityIdPerEventName = {};\n\n    const callListners = (eventName, entityId, listenerEntityId, node) => {\n        if (listenersPerEntityIdPerEventName.hasOwnProperty(listenerEntityId)) {\n            const listenersPerEventName = listenersPerEntityIdPerEventName[listenerEntityId];\n            if (listenersPerEventName.hasOwnProperty(eventName)) {\n                const listeners = listenersPerEventName[eventName];\n                listeners.forEach(callback => callback(entityId, node, eventName));\n            }\n        }\n    };\n\n    this.callListeners = (state, entityId, node) => {\n        if (typeof entityId !== 'string') throw new TypeError(\"entityId is not a string.\");\n        if (!state instanceof State) throw new TypeError(\"state is not a State.\");\n\n        let eventName;\n        if (state.isCreated()) {\n            eventName = 'created';\n        } else if (state.isChanged()) {\n            eventName = 'created';\n        } else if (state.isRemoved()) {\n            eventName = 'created';\n            //TODO }else if(state.isError()){\n            //   eventName = 'error';\n        } else {\n            return;\n        }\n        console.log('callListener', entityId, eventName);\n\n        callListners(eventName, entityId, '*', node);\n        callListners(eventName, entityId, entityId, node)\n    };\n\n    this.addEntityIdListener = (entityId, eventName, callback) => {\n        if (typeof callback !== 'function') throw new TypeError(\"Listener callback is not a function.\");\n        if (typeof entityId !== 'string') throw new TypeError(\"Listener entityId is not a string.\");\n        if (typeof eventName !== 'string') throw new TypeError(\"Listener eventName is not a string.\");\n        if (eventNames.indexOf(eventName) === -1) throw new Error('Listener eventName \"' + eventName + '\"  is not in allowed event names: ' + eventNames.join(', ') + '.');\n\n        console.log('addListener', entityId, eventName);\n\n        let listenersPerEventName;\n        if (!listenersPerEntityIdPerEventName.hasOwnProperty(entityId)) {\n            listenersPerEntityIdPerEventName[entityId] = {};\n        }\n        listenersPerEventName = listenersPerEntityIdPerEventName[entityId];\n        let listeners;\n        if (!listenersPerEventName.hasOwnProperty(eventName)) {\n            listenersPerEventName[eventName] = new Map();\n        }\n        const listener = new Listener(this, eventName, entityId);\n        listeners = listenersPerEventName[eventName];\n        listeners.set(listener, callback);\n\n        return listener;\n    };\n\n    this.removeListener = listener => {\n        if (!listener instanceof Listener) throw new TypeError(\"listener is not a Listener.\");\n\n        const entityId = listener.getEntityId();\n        if (listenersPerEntityIdPerEventName.hasOwnProperty(entityId)) {\n            const listenersPerEventName = listenersPerEntityIdPerEventName[entityId];\n            const eventName = listener.getEventName();\n            if (listenersPerEventName.hasOwnProperty(eventName)) {\n                const listeners = listenersPerEventName[eventName];\n                if (listeners.has(listener)) {\n                    listeners.delete(listener);\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    this.hasListeners = (entityId, eventName) => {\n        if (typeof entityId === 'undefined') {\n            return Object.keys(listenersPerEntityIdPerEventName).length > 0;\n        } else if (entityId === '*') {\n            if (typeof eventName === 'undefined') {\n                return Object.keys(listenersPerEntityIdPerEventName).length > 0;\n            } else if (typeof eventName === 'string') {\n                for (let entityId in listenersPerEntityIdPerEventName) {\n                    if (listenersPerEntityIdPerEventName[entityId].hasOwnProperty(eventName)) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                throw new TypeError(\"eventName is not a string.\");\n            }\n        } else if (typeof entityId === 'string') {\n            if (listenersPerEntityIdPerEventName.hasOwnProperty(entityId)) {\n                if (typeof eventName === 'undefined') {\n                    return true;\n                } else if (typeof eventName === 'string') {\n                    return listenersPerEntityIdPerEventName[entityId].hasOwnProperty(eventName);\n                } else {\n                    throw new TypeError(\"eventName is not a string.\");\n                }\n            }\n        } else {\n            throw new TypeError(\"entityId is not a string.\");\n        }\n    };\n\n    this.removeListeners = (entityId, eventName) => {\n        if (typeof entityId === 'undefined') {\n            for (let entityId in listenersPerEntityIdPerEventName) {\n                delete listenersPerEntityIdPerEventName[entityId];\n            }\n        } else if (entityId === '*') {\n            if (typeof eventName === 'undefined') {\n                for (let entityId in listenersPerEntityIdPerEventName) {\n                    delete listenersPerEntityIdPerEventName[entityId];\n                }\n            } else if (typeof eventName === 'string') {\n                for (let entityId in listenersPerEntityIdPerEventName) {\n                    if (listenersPerEntityIdPerEventName[entityId].hasOwnProperty(eventName)) {\n                        delete listenersPerEntityIdPerEventName[entityId][eventName];\n                    }\n                }\n                if (Object.keys(listenersPerEntityIdPerEventName[entityId]).length === 0) {\n                    delete listenersPerEntityIdPerEventName[entityId];\n                }\n                return false;\n            } else {\n                throw new TypeError(\"eventName is not a string.\");\n            }\n        } else if (typeof entityId === 'string') {\n            if (listenersPerEntityIdPerEventName.hasOwnProperty(entityId)) {\n                if (typeof eventName === 'undefined') {\n                    delete listenersPerEntityIdPerEventName[entityId];\n                } else if (typeof eventName === 'string') {\n                    delete listenersPerEntityIdPerEventName[entityId][eventName];\n                    if (Object.keys(listenersPerEntityIdPerEventName[entityId]).length === 0) {\n                        delete listenersPerEntityIdPerEventName[entityId];\n                    }\n                } else {\n                    throw new TypeError(\"eventName is not a string.\");\n                }\n            }\n        } else {\n            throw new TypeError(\"entityId is not a string.\");\n        }\n    }\n}\n\n//TODO remove\nfunction combineStatus(currentStatus, additionalStatus) {\n    switch (typeof currentStatus) {\n        case 'undefined' :\n            return additionalStatus;\n        case 'number' :\n            return currentStatus === additionalStatus ? currentStatus : 207;\n    }\n    throw new TypeError('currentStatus is not a number.')\n}\n\nexports.Handler = ListenerHandler;\nexports.combineStatus = combineStatus;\n\n//# sourceURL=webpack://xyz/./source/entity/listener.js?");

/***/ }),

/***/ "./source/entity/property.js":
/*!***********************************!*\
  !*** ./source/entity/property.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Response = __webpack_require__(/*! ../response/response.js */ \"./source/response/response.js\").constructor;\nconst types = __webpack_require__(/*! ../../build/types.js */ \"./build/types.js\");\nconst listener = __webpack_require__(/*! ./listener.js */ \"./source/entity/listener.js\");\nconst State = __webpack_require__(/*! ./state.js */ \"./source/entity/state.js\").State;\nconst response = __webpack_require__(/*! ./response.js */ \"./source/entity/response.js\");\n\nexports.constructor = function Property(parent, propertyName, meta) {\n    listener.Handler.call(this);\n\n    const subProperties = {};\n    const contents = {};\n    const errors = {};//TODO\n    const statusses = {};//TODO\n\n    const type = meta.type;\n    //TODO handle type alliasses?\n    const settings = meta; //TODO check if object\n    let isId = false;\n    if (settings.hasOwnProperty('storage')) {\n        if (settings.storage.key === 'key' || settings.storage.key === 'basename') {\n            isId = true;\n        }\n    }\n    let isPrimitive = true;\n    if (settings.hasOwnProperty('signature')) {\n        isPrimitive = false;\n        for (let propertyName in settings.signature) {\n            subProperties[propertyName] = new Property(this, propertyName, settings.signature[propertyName]);\n        }\n    }\n\n    this.getSettings = () => settings;\n\n    this.getUri = entityId => parent.getUri(entityId) + '/' + propertyName;\n\n    this.getResponse = (path, entityId) => {\n        if (isPrimitive) {\n            return new response.Node(statusses[entityId], contents[entityId], errors[entityId]);\n        } else {\n            const subPropertyNames = (path.length === 0 || path[0] === '*')\n                ? Object.keys(subProperties)\n                : path[0].split(',');\n            const response = {};\n            const subPath = path.slice(1);\n            for (let subPropertyName of subPropertyNames) {\n                if (subProperties.hasOwnProperty(subPropertyName)) {\n                    response[subPropertyName] = subProperties[subPropertyName].getResponse(subPath, entityId);\n                } else {\n                    response[subPropertyName] = new response.Node(400, null, [`${subPropertyName} does not exist.`]); //TODO\n                }\n            }\n            return response;\n        }\n    };\n\n    this.handleInput = (entityId, propertyStatus, propertyContent) => {\n        const state = new State();\n        if (isPrimitive) {\n            if (contents.hasOwnProperty(entityId)) {\n                const prevPropertyContent = contents[entityId];\n                switch (propertyStatus) {\n                    case 200:\n                        if (prevPropertyContent !== propertyContent) {\n                            state.setChanged();\n                        }\n                        contents[entityId] = propertyContent;\n                        break;\n                    case 404:\n                        //state.setError(); TODO compare with current error in errors\n                        status = 404;\n                        break;\n                    default:\n                        //state.setError(); TODO compare with current error in errors\n                        throw new Error('Unsupported status ' + propertyStatus);\n                }\n            } else { // if 200 then created, else error\n                switch (propertyStatus) {\n                    case 200:\n                        state.setCreated();\n                        contents[entityId] = propertyContent;\n                        break;\n                    case 404:\n                        //state.setError(); TODO compare with current error in errors\n                        break;\n                    default:\n                        //state.setError(); TODO compare with current error in errors\n                        throw new Error('Unsupported status ' + propertyStatus);\n                }\n            }\n        } else if (propertyStatus === 207) {\n            for (let subPropertyName in subProperties) {\n                const subProperty207Wrapper = propertyContent[subPropertyName];\n                if (subProperty207Wrapper === null || typeof subProperty207Wrapper !== 'object'\n                    || !subProperty207Wrapper.hasOwnProperty('status')\n                    || !subProperty207Wrapper.hasOwnProperty('content')\n                ) {\n                    //TODO reponse is in error\n                    console.error('error response in wrong format');\n                } else {\n                    const subProperty = subProperties[subPropertyName];\n                    const subStatus = subProperty207Wrapper.status;\n                    const subContent = subProperty207Wrapper.content;\n                    const subState = subProperty.handleInput(entityId, subStatus, subContent);\n                    state.addSubState(subState);\n                }\n            }\n        } else {\n            for (let subPropertyName in subProperties) {\n                const subProperty = subProperties[subPropertyName];\n                const subPropertyContent = (propertyContent === null || typeof propertyContent !== 'object')\n                    ? null\n                    : propertyContent[subPropertyName];\n                const subState = subProperty.handleInput(entityId, propertyStatus, subPropertyContent);\n                state.addSubState(subState);\n            }\n        }\n        this.callListeners(state, entityId, this.getResponse([],entityId));\n        return state;\n    };\n\n    this.createResponse = (entityId, propertyStatus, propertyContent, isDelta) => {\n        const propertyResponse = new Response();\n        const prevStatus = statusses[entityId];\n        if (isPrimitive) {\n            if (contents.hasOwnProperty(entityId)) {\n                const prevPropertyContent = contents[entityId];\n                switch (propertyStatus) {\n                    case 200:\n                        propertyStatus = prevPropertyContent === propertyContent ? 200 : 304;\n                        contents[entityId] = propertyContent;\n                        break;\n                    case 404:\n                        break;\n                    default:\n                        throw new Error('Unsupported status ' + propertyStatus);\n                }\n            } else { // if 200 then created, else error\n                switch (propertyStatus) {\n                    case 200:\n                        propertyStatus = 201;\n                        contents[entityId] = propertyContent;\n                        break;\n                    case 404:\n                        break;\n                    default:\n                        throw new Error('Unsupported status ' + propertyStatus);\n                }\n            }\n            statusses[entityId] = propertyStatus;\n            propertyResponse.setContent(propertyStatus, propertyContent);\n        } else if (propertyStatus === 207) {\n            for (let subPropertyName in subProperties) {\n                const subProperty207Wrapper = propertyContent[subPropertyName];\n                if (subProperty207Wrapper === null || typeof subProperty207Wrapper !== 'object'\n                    || !subProperty207Wrapper.hasOwnProperty('status')\n                    || !subProperty207Wrapper.hasOwnProperty('content')\n                ) {\n                    //TODO reponse is in error\n                    console.error('error response in wrong format');\n                } else {\n                    const subProperty = subProperties[subPropertyName];\n                    const subStatus = subProperty207Wrapper.status;\n                    const subContent = subProperty207Wrapper.content;\n                    const subResponse = subProperty.createResponse(entityId, subStatus, subContent, isDelta);\n                    propertyResponse.set(subPropertyName, subResponse)\n                }\n            }\n        } else {\n            for (let subPropertyName in subProperties) {\n                const subProperty = subProperties[subPropertyName];\n                const subPropertyContent = (propertyContent === null || typeof propertyContent !== 'object')\n                    ? null\n                    : propertyContent[subPropertyName];\n                const subPropertyResponse = subProperty.createResponse(entityId, propertyStatus, subPropertyContent, isDelta);\n                propertyResponse.set(subPropertyName, subPropertyResponse)\n            }\n        }\n        return propertyResponse;\n    };\n\n    this.createCreator = (options, data, xyz) => {\n        const TRs = [];\n        if (types.hasOwnProperty(type) && types[type].hasOwnProperty('edit')) {\n            if (type === 'id') {\n                return TRs;\n            }\n            const uri = this.getUri('*'); //TODO double check this\n            const content = settings.hasOwnProperty('default') ? settings.default : null;\n            // TODO html label for gebruiken\n            const TR = document.createElement('TR');\n            const TD_label = document.createElement('TD');\n            TD_label.innerText = propertyName;\n            TR.appendChild(TD_label);\n            const onChange = content => {\n                data[propertyName] = content;\n            };\n            const element = types[type].edit(xyz, uri, 200, content, settings, options, onChange);\n            const TD_content = document.createElement('TD');\n            TD_content.appendChild(element);\n            TR.appendChild(TD_content);\n            TRs.push(TR);\n        } else if (!isPrimitive) {\n            for (let propertyName in subProperties) {\n                data[propertyName] = {};\n                TRs.push(...subProperties[propertyName].createCreator(options, data[propertyName], xyz));\n            }\n        }\n        return TRs;\n    };\n\n    this.isAutoIncremented = () => {\n        if (isPrimitive) {\n            return type === 'id';\n        } else {\n            for (let subPropertyName in subProperties) {\n                if (subProperties[subPropertyName].isAutoIncremented()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n\n    this.getIdFromContent = data => {\n        if (isPrimitive) {\n            return isId ? data : null;\n        } else {\n\n            if (typeof data !== 'object' || data === null) { //TODO is_object\n                return null;\n            }\n\n            for (let subPropertyName in subProperties) {\n                if (data.hasOwnProperty(subPropertyName)) {\n                    const id = subProperties[subPropertyName].getIdFromContent(data[subPropertyName]);\n                    if (id) {\n                        return id;\n                    }\n                }\n            }\n            return null;\n        }\n    };\n\n    // transformation =  (Response, Property, entityId) => transformedContent\n    this.transform = (propertySource, transformation, entityId) => {\n        const propertyTarget = new Response();\n        if (isPrimitive) {\n            const transformedContent = transformation(propertySource, this, entityId);\n            propertyTarget.setContent(propertySource.getStatus(), transformedContent);\n        } else {\n            for (let subPropertyName of propertySource.keys()) {\n                if (subProperties.hasOwnProperty(subPropertyName)) {\n                    const subProperty = subProperties[subPropertyName];\n                    const subPropertyTarget = subProperty.transform(propertySource.get(subPropertyName), transformation, entityId);\n                    propertyTarget.set(subPropertyName, subPropertyTarget);\n                } else {\n                    console.error('entity transform: property does not exist');\n                    //TODO error\n                }\n            }\n        }\n        return propertyTarget;\n    };\n};\n\n//# sourceURL=webpack://xyz/./source/entity/property.js?");

/***/ }),

/***/ "./source/entity/response.js":
/*!***********************************!*\
  !*** ./source/entity/response.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function filter(content, path) {\n    if (path.length === 0) {\n        return;\n    }\n    const subPath = path.slice(1);\n    const propertyNameList = path[0];\n    if (propertyNameList === '*') {\n        for (let propertyName of propertyNames) {\n            filter(content[propertyName], subPath);\n        }\n    } else {\n        const propertyNames = propertyNameList.split(',');\n        for (let propertyName in content) {\n            if (propertyNames.indexOf(propertyName)===-1) {\n                delete content[propertyName];\n            } else {\n                filter(content[propertyName], subPath);\n            }\n        }\n    }\n}\n\nfunction Node(status_, content_, errors_) {\n    const status = status_;\n    const content = content_;\n    const errors = errors_;\n    this.getStatus = () => status;\n    this.getContent = () => content;\n    this.getErrors = () => errors;\n}\n\nexports.filter = filter;\nexports.Node = Node;\n\n//# sourceURL=webpack://xyz/./source/entity/response.js?");

/***/ }),

/***/ "./source/entity/state.js":
/*!********************************!*\
  !*** ./source/entity/state.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function State() {\n    // let status;\n    let created = false;\n    let changed = false;\n    let removed = false;\n    //TODO let error = false;\n\n    this.setCreated = () => {\n        created = true;\n    };\n    this.setChanged = () => {\n        changed = true;\n    };\n    this.setRemoved = () => {\n        removed = true;\n    };\n    /*TODO this.setError = () => {\n        error = true;\n    };*/\n    this.isChanged = () => changed && !created;\n    this.isRemoved = () => removed;\n    this.isCreated = () => created;\n    //TODO this.isError = () => created;\n\n    this.addSubState = subState => {\n        if (subState.isChanged() || subState.isRemoved() || subState.isCreated()) {\n            changed = true;\n        }\n    };\n}\n\nexports.State = State;\n\n//# sourceURL=webpack://xyz/./source/entity/state.js?");

/***/ }),

/***/ "./source/main.js":
/*!************************!*\
  !*** ./source/main.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const entity = __webpack_require__(/*! ./entity/entity.js */ \"./source/entity/entity.js\");\nconst response = __webpack_require__(/*! ./entity/response.js */ \"./source/entity/response.js\");\nconst Response = __webpack_require__(/*! ./response/response.js */ \"./source/response/response.js\");\nconst uriTools = __webpack_require__(/*! ./uri/uri.js */ \"./source/uri/uri.js\");\nconst render = __webpack_require__(/*! ./render/render.js */ \"./source/render/render.js\");\n\n//TODO remove\nconst displays = {\n    list: __webpack_require__(/*! ./display/list.js */ \"./source/display/list.js\").render,\n    item: __webpack_require__(/*! ./display/item.js */ \"./source/display/item.js\").render\n};\n\nconst DEFAULT_ACTION = 'view';\nconst DEFAULT_DISPLAY = 'item';\nconst DEFAULT_TAG = 'DIV';\n\nfunction request(method, uri, data, callback) {\n    //TODO allow for multiple hosts by prepending http(s)://..\n    const location = 'http://localhost:8888/site/'; //TODO determine dynamically\n    const xhr = new XMLHttpRequest();\n    xhr.open(method, location + 'api' + uri, true);\n\n    xhr.onreadystatechange = e => {\n        if (xhr.readyState === 4) {\n            const status = xhr.status;\n            const content = xhr.responseText;\n            callback(status, content);\n        }\n    };\n    xhr.send(data);\n}\n\nfunction XYZ() {\n    const entityClasses = {};\n    const variables = {};\n\n    this.hasVariable = variableName => variables.hasOwnProperty(variableName);\n    this.getVariable = (variableName, fallback) => variables.hasOwnProperty(variableName) ? variables[variableName] : fallback;\n\n    const handleVariableChange = variableName => {\n        for (let uri in uriCallbacks) {\n            if (uri.indexOf('$' + variableName) !== -1) { // TODO find ${variableName} and ignore $variableNameWithPostfix\n                for (let callback of uriCallbacks[uri]) {\n                    handleUri(uri, callback);\n                }\n            }\n        }\n    };\n\n    this.clearVariable = variableName => {\n        delete variables[variableName];\n        handleVariableChange(variableName);\n    };\n\n    this.setVariable = (variableName, value) => {\n        if (value !== variables[variableName]) {\n            variables[variableName] = value;\n            handleVariableChange(variableName);\n        }\n    };\n\n    this.setVariables = (variableObject) => {\n        for (let variableName in variableObject) {\n            this.setVariable(variableName, variableObject[variableName]);\n        }\n    };\n\n    const uriCallbacks = {};\n\n    function handleUri(uri, callbacks) {\n        let complete = true;\n        //TODO find ${variableName}\n        uri = uri.replace(/\\$(\\w+)/, (_, variableName) => {\n            if (variables.hasOwnProperty(variableName)) {\n                return variables[variableName];\n            } else {\n                complete = false;\n                return '$' + variableName;\n            }\n        });\n        if (complete) {\n            callbacks.ready(uri);\n        } else {\n            callbacks.wait(uri);\n        }\n    }\n\n    /* setInterval(()=>{\n         for(let uri in uriCallbacks){\n             for(let callback of uriCallbacks[uri]){\n                 handleUri(uri,callback);\n             }\n         }\n     },2000)*/\n\n    function registerUri(uri, readyCallback, waitCallback) {\n        const callbacks = {ready: readyCallback, wait: waitCallback};\n        if (!uriCallbacks.hasOwnProperty(uri)) {\n            uriCallbacks[uri] = [callbacks];\n        } else {\n            uriCallbacks[uri].push(callbacks);\n        }\n        handleUri(uri, callbacks);\n    }\n\n    const retrieveMeta = (uri, callback) => {\n        const path = uri.substr(1).split('/');\n        const entityClassNameList = path[0]; // TODO error if no entityClass\n\n        const entityClassNames = entityClassNameList.split(',').filter(entityClass => !entityClasses.hasOwnProperty((entityClass)));\n        if (entityClassNames.length === 0) {\n            callback();\n        } else {\n            request('GET', '/' + entityClassNames.join(',') + '?meta', undefined, (status, content) => {//TODO add querystring better\n                //TODO check status\n                console.log(content)\n                const data = JSON.parse(content); //TODO check\n                for (let entityClassName of entityClassNames) {\n                    if (!entityClasses.hasOwnProperty(entityClassName)) {\n                        entityClasses[entityClassName] = new entity.Class(entityClassName, data[entityClassName]['*']);\n                    }\n                }\n                callback();\n            });\n        }\n    };\n\n    this.patch = (uri, content, callback) => {\n        console.log('patch request', uri, content)\n        content = typeof content === 'string' ? content : JSON.stringify(content);\n        request('PATCH', uri, content, (status, response) => {\n            //TODO check for errors\n            console.log('patch response:' + response, uri)\n            //TODO callback\n        });\n    };\n\n    this.put = (uri, content, callback) => {\n        console.log('put request', uri, content)\n        content = typeof content === 'string' ? content : JSON.stringify(content);\n        request('PUT', uri, content, (status, response) => {\n            //TODO check for errors\n            console.log('put response', uri, response)\n            //TODO callback\n        });\n    };\n\n    this.head = (uri, content, callback) => {\n        //TODO\n    };\n    this.post = (uri, content, callback) => {\n        console.log('post request', uri, content);\n        content = typeof content === 'string' ? content : JSON.stringify(content);\n        request('POST', uri, content, (status, response) => {\n            //TODO check for errors\n            console.log('post response:' + response, uri)\n            //TODO callback\n        });\n    };\n\n    // callback = Response =>{}\n    // get the requested uri from cache or request it from server\n    this.get = (uri, dataCallback, metaCallBack) => {\n        // get the meta data\n        retrieveMeta(uri, () => {\n            if (typeof metaCallBack === 'function') {\n                metaCallBack();\n            }\n            //TODO meta should be good or we have a problem\n            //TODO get the data from cache if already in cache\n            request('GET', uri, undefined, (status, content) => {//TODO add querystring better\n                const state = entity.handleInput(uri, status, content, entityClasses);\n                //for(let id in entityClasses){\n                /*if (entityClasses.hasOwnProperty('source')) {\n                    const s = entityClasses['source'].getContent([], 'fruit');\n                    console.log('yes',test)\n                } else {\n                }\n                console.log('no');\n                //}*/\n                const response = Response.create(uri, status, content, entityClasses);\n                if (typeof dataCallback === 'function') {\n                    dataCallback(response);\n                }\n            });\n        });\n    };\n\n    //============================================================\n    // RENDERING should be refactored with better naming\n    //============================================================\n\n    this.renderElement = (action, uri, status, content, settings, options) => {\n        return render.element(this, action, uri, status, content, settings, options);\n    };\n\n    const renderNode = (action, options) => (source, property, entityId) => {\n        const uri = property.getUri(entityId);\n        const settings = property.getSettings();\n        const content = source.getContent();\n        const status = source.getStatus();\n        return this.renderElement(action, uri, status, content, settings, options);\n    };\n\n    const renderDisplay = (TAG, options) => (uri) => {\n        this.get(uri, response => {\n            const action = options.action || DEFAULT_ACTION;\n            const display = options.display || DEFAULT_DISPLAY;\n            response = response.filter(uri);\n            const node = Response.transform(response, renderNode(action, options), entityClasses);\n            const mapper = displays[display](options, this); // TODO check if exists,use default or custom otherwise\n            TAG.innerHTML = '';\n            TAG.classList.remove('xyz-waiting');\n            node.map(mapper, uri, TAG);\n        });\n    };\n\n    const renderUiElement = (uri, options, TAG) => {\n        registerUri(uri,\n            renderDisplay(TAG, options),\n            uri => {\n                TAG.classList.add('xyz-waiting');\n                TAG.innerHTML = 'Not ready'\n            }\n        );\n    };\n\n    const renderUiCreate = (uri, options, TAG) => {\n        retrieveMeta(uri, () => {\n            const entityClassName = uriTools.pathFromUri(uri)[0];\n            const entityClass = entityClasses[entityClassName];\n            const data = {};\n            const TABLE = entityClass.createCreator(options, data, this);\n            TAG.appendChild(TABLE);\n            const INPUT = document.createElement('INPUT');\n            INPUT.type = 'submit';\n            INPUT.onclick = () => {\n                if (entityClass.isAutoIncremented()) {\n                    this.post(uri, {[entityClassName]: {'new': data}},);\n                } else {\n                    const entityId = entityClass.getIdFromContent(data);\n                    this.put(uri + '/' + entityId, {[entityClassName]: {[entityId]: data}},);\n                }\n            };\n            TAG.appendChild(INPUT);\n        });\n        return TAG;\n    };\n\n    this.ui = (uri, options, PARENT) => {\n        options = options || {};\n        let SCRIPT;\n        if (typeof PARENT === 'undefined') {\n            const tag = options.tag || DEFAULT_TAG;\n            PARENT = document.createElement(tag);\n            SCRIPT = document.currentScript;\n        }\n        if (options.id) {\n            PARENT.id = options.id;\n        }\n        if (options.class) {\n            PARENT.class = options.class || '';\n        }\n        if (SCRIPT) {\n            SCRIPT.parentNode.insertBefore(PARENT, SCRIPT);\n            SCRIPT.parentNode.removeChild(SCRIPT);\n        }\n        if (options.display === 'create') {\n            renderUiCreate(uri, options, PARENT);\n        } else {\n            renderUiElement(uri, options, PARENT);\n        }\n        return PARENT;\n    };\n\n\n    this.on = (uri, eventName, callback) => {\n        //TODO check type, callback and uri\n        const entityClassNames = uriTools.getEntityClassNames(uri, entityClasses);\n        const subPath = uriTools.pathFromUri(uri).slice(1);\n        for (let entityClassName of entityClassNames) {\n            if (entityClasses.hasOwnProperty(entityClassName)) {\n                entityClasses[entityClassName].addListener(subPath, eventName, callback);\n            } else {\n                // TODO callback 404 on listener\n                callback(entityClassName);\n            }\n        }\n    };\n\n    //TODO move to display/list\n    function flatten2(source, target, prefix) {\n        for (let key in source) {\n            const value = source[key];\n            if (!(value instanceof response.Node)) {\n                flatten2(value, target, prefix + key + '.');\n            } else {\n                target[prefix + key] = value;\n            }\n        }\n    }\n\n    //TODO move to display/list\n    function flatten(source) {\n        const target = {};\n        flatten2(source, target, '');\n        return target;\n    }\n\n    //TODO move to display/list\n    const list = {\n        waiting: WRAPPER => {\n            WRAPPER.innerHTML = 'Waiting for items...';\n        },\n        empty: WRAPPER => {\n            WRAPPER.innerHTML = 'No items to display';\n        },\n        first: WRAPPER => {\n            WRAPPER.innerHTML = ''; //TODO\n        },\n        //TODO uri\n        entity: (WRAPPER, entityId, content) => {\n            //response.on('/abs')\n            //response.on('./relative')\n            //response.on('eventName')\n            console.log('entity', flatten(content));\n            const DIV_entity = document.createElement('DIV');\n            DIV_entity.innerText = entityId;\n            WRAPPER.appendChild(DIV_entity);\n        }\n    };\n\n    const displays2 = {\n        list: list      //TODO require\n        //TODO item\n    };\n\n\n    const renderDisplay2 = (uri, options, WRAPPER) => (entityId, node) => {\n        const displayName = options.display;\n        const display = displays2[displayName];\n        if (WRAPPER.classList.contains('xyz-empty') || WRAPPER.classList.contains('xyz-waiting')) {\n            WRAPPER.classList.remove('xyz-empty');\n            WRAPPER.classList.remove('xyz-waiting');\n            if (display && display.hasOwnProperty('first')) {\n                display.first(WRAPPER);\n            } else {\n                WRAPPER.innerHTML = ''; //TODO\n            }\n        }\n        const action = options.action || DEFAULT_ACTION;\n        const path = uriTools.pathFromUri(uri).slice(2);\n        response.filter(node, path); // filter the content that was not requested\n        if (display && display.hasOwnProperty('entity')) {\n            //TODO filter response using the uri\n            display.entity(WRAPPER, entityId, node);\n        } else {\n            //TODO a default way of handeling stuff\n        }\n    };\n\n    const renderUiElement2 = (uri, options, WRAPPER) => { //TODO rename\n        const displayName = options.display;\n        const display = displays2[displayName];\n        this.get(uri, () => {\n            if (WRAPPER.classList.contains('xyz-waiting')) {\n                WRAPPER.classList.remove('xyz-waiting');\n                WRAPPER.classList.add('xyz-empty');\n                if (display && display.hasOwnProperty('empty')) {\n                    display.empty(WRAPPER);\n                } else {\n                    WRAPPER.innerHTML = 'Empty';\n                }\n            }\n        }, () => {\n            WRAPPER.classList.add('xyz-waiting');\n            if (display && display.hasOwnProperty('waiting')) {\n                display.waiting(WRAPPER);\n            } else {\n                WRAPPER.innerHTML = 'Waiting...';\n            }\n            const baseUri = uriTools.getBaseUri(uri);\n            this.on(baseUri, 'created', renderDisplay2(uri, options, WRAPPER));\n        });\n    };\n\n    this.ui2 = (uri, options, WRAPPER) => {//TODO rename\n        options = options || {};\n        let SCRIPT;\n        if (typeof WRAPPER === 'undefined') {\n            const tag = options.tag || DEFAULT_TAG;\n            WRAPPER = document.createElement(tag);\n            SCRIPT = document.currentScript;\n        }\n        if (options.id) {\n            WRAPPER.id = options.id;\n        }\n        if (options.class) {\n            WRAPPER.class = options.class || '';\n        }\n        if (SCRIPT) {\n            SCRIPT.parentNode.insertBefore(WRAPPER, SCRIPT);\n            SCRIPT.parentNode.removeChild(SCRIPT);\n        }\n        if (options.display === 'create') {\n            renderUiCreate(uri, options, WRAPPER);\n        } else {\n            renderUiElement2(uri, options, WRAPPER);//TODO rename\n        }\n        return WRAPPER;\n    };\n}\n\nconst xyz = new XYZ();\nexports.ui = xyz.ui;\nexports.ui2 = xyz.ui2;\nexports.on = xyz.on;\n//TODO get(Variable)\n//TODO set(Variable(s))\n//TODO globals()\n\n\n\n//# sourceURL=webpack://xyz/./source/main.js?");

/***/ }),

/***/ "./source/render/render.js":
/*!*********************************!*\
  !*** ./source/render/render.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const types = __webpack_require__(/*! ../../build/types.js */ \"./build/types.js\");\nconst uriTools = __webpack_require__(/*! ../uri/uri.js */ \"./source/uri/uri.js\");\n\nconst DEFAULT_TYPE = 'string';\n\nfunction renderElement(xyz, action, uri, status, content, settings, options) {\n    const type = settings.type || DEFAULT_TYPE;\n    if (!types.hasOwnProperty(type)) {\n        console.error('problem1');\n        return;\n    }\n    if (types[type].hasOwnProperty(action)) {\n        let onChange;\n        if (action === 'edit') {\n            onChange = content => {\n                xyz.patch(uri, uriTools.wrapContent(uri, content));\n            }\n        }\n        const TAG = types[type][action](xyz, uri, status, content, settings, options, onChange);\n        TAG.className = `xyz-status-${status}`;\n        return TAG;\n    } else if (settings.hasOwnProperty('signature')) { // create editor from signature view\n        //TODO check if content if object\n        //TODO check if settings.signature is object\n        const DIV = document.createElement('DIV');\n        DIV.className = `xyz-status-${status}`;\n        for (let subPropertyName in settings.signature) {\n            const subSettings = settings.signature[subPropertyName];\n            const subContent = content[subPropertyName];\n            const subType = subSettings.type;\n            const subUri = uri + '/' + subPropertyName;\n            const TAG = renderElement(xyz, subType, action, subUri, status, subContent, subSettings, options);\n            TAG.className = `xyz-status-${status}`;\n            DIV.appendChild(TAG);\n        }\n        return DIV;\n    } else {\n        console.error('problem1');\n        //TODO something default and/or error\n    }\n}\n\nexports.element = renderElement;\n\n//# sourceURL=webpack://xyz/./source/render/render.js?");

/***/ }),

/***/ "./source/response/response.js":
/*!*************************************!*\
  !*** ./source/response/response.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const uriTools = __webpack_require__(/*! ../uri/uri.js */ \"./source/uri/uri.js\");\n\nfunction Response() {\n    let primitive;\n    const subResponses = {};\n    let status;\n    let content;\n    this.getStatus = () => status;\n    this.getContent = () => {\n        //TODO if not primitive => throw\n        return content;\n    };\n    this.setContent = (status_, content_) => {\n        if (typeof status_ !== 'number') throw new TypeError('status is not a number.');\n        primitive = true;\n        status = status_;\n        content = content_;\n    };\n    this.set = (key, subResponse) => {\n        if (typeof key !== 'string') throw new TypeError('key is not a string.');\n        if (!subResponse instanceof Response) throw new TypeError('subResponse in not a Reponse.');\n\n        primitive = false;\n        const subStatus = subResponse.getStatus();\n        subResponses[key] = subResponse;\n        if (Object.keys(subResponses).length === 0) {\n            status = subStatus;\n        } else if (status !== subStatus) {\n            status = 207;\n        }\n    };\n    this.isPrimitive = () => primitive;\n\n    // func = (subResponse, propertyName, response) => {}\n    this.forEach = func => {\n        if (primitive === true) {\n            //TODO throw error\n        } else {\n            for (let propertyName in subResponses) {\n                const subResponse = subResponses[propertyName];\n                func(subResponse, propertyName, this);\n            }\n        }\n    };\n    this.toObject = () => {\n        if (primitive === true) {\n            return content;\n        } else if (primitive === false) {\n            const object = {};\n            for (let propertyName in subResponses) {\n                object[propertyName] = subResponses[propertyName].toObject();\n            }\n            return object;\n        } else {\n            return undefined;\n        }\n\n    };\n    // transformation = (content,  uri, status, depth) => {...}\n    this.transform = (transformation, uri, depth) => {\n        uri = typeof uri === 'undefined' ? '' : uri;\n        depth = typeof depth === 'undefined' ? 0 : depth;\n        const node = new Response();\n        if (primitive) {\n            const transformedContent = transformation(content, uri, status, depth);\n            node.setContent(status, transformedContent);\n        } else {\n            this.forEach((subResponse, key) => {\n                const transformedSubResponse = subResponse.transform(transformation, uri + '/' + key, depth + 1);\n                node.set(key, transformedSubResponse);\n            })\n        }\n        return node;\n    };\n\n    // mapping = ( accumulator, content, key, uri, status, depth, primitive, fullUri) => {...}\n    this.map = (mapping, fullUri, parent, key, uri, depth) => {\n        uri = typeof uri === 'undefined' ? '' : uri;\n        depth = typeof depth === 'undefined' ? 0 : depth;\n        key = typeof key === 'undefined' ? '' : key;\n        if (primitive) {\n            mapping(parent, content, key, uri, status, depth, true);\n            return null;\n        } else {\n            const node = mapping(parent, content, key, uri, status, depth, false, fullUri);\n            for (let propertyName in subResponses) {\n                const subResponse = subResponses[propertyName];\n                subResponse.map(mapping, fullUri, node, propertyName, uri + '/' + propertyName, depth + 1);\n            }\n            return node;\n        }\n    };\n    this.filter_ = path => {\n        if (path.length === 0 && primitive) {\n            const response = new Response();\n            response.setContent(status, this.toObject());\n            return response;\n        }\n        const response = new Response();\n        let propertyNames;\n        if (path[0] === '*' || path.length === 0) {\n            propertyNames = Object.keys(subResponses);\n        } else {\n            propertyNames = path[0].split(',');\n        }\n        for (let propertyName of propertyNames) {\n            const subResponse = subResponses[propertyName].filter_(path.slice(1));\n            response.set(propertyName, subResponse);\n        }\n        return response;\n    };\n\n    this.filter = uri => {\n        return this.filter_(uriTools.pathFromUri(uri));\n    };\n    this.keys = () => Object.keys(subResponses);\n    this.has = key => subResponses.hasOwnProperty(key);\n    this.get = key => subResponses[key];\n}\n\n\nconst create = (uri, status, content, entityClasses) => {\n    //TODO check status\n    content = JSON.parse(content);//TODO check\n\n    const response = new Response();\n    const path = uriTools.pathFromUri(uri);\n    const entityClassNameList = path[0]; // TODO error if no entityClass\n    const entityIdList = path[1] || '*';\n    const entityClassNames = entityClassNameList.split(',');\n    if (status === 207) {\n        for (let entityClassName of entityClassNames) {\n            const entityClass207Wrapper = content[entityClassName];\n            if (entityClass207Wrapper === null || typeof entityClass207Wrapper !== 'object'\n                || !entityClass207Wrapper.hasOwnProperty('status')\n                || !entityClass207Wrapper.hasOwnProperty('content')\n            ) {\n                console.error('error response in wrong format');//TODO\n            } else {\n                const entityClassStatus = entityClass207Wrapper.status;\n                const entityClassContent = entityClass207Wrapper.content;\n                const entityClass = entityClasses[entityClassName];\n                let entityIds;\n                if (entityIdList === '*') {\n                    entityIds = Object.keys(entityClassContent);\n                } else {\n                    entityIds = entityIdList.split(',');\n                }\n                const entityClassResponse = entityClass.createEntityClassResponse(entityClassStatus, entityClassContent, entityIds);\n                response.set(entityClassName, entityClassResponse);\n            }\n        }\n    } else {\n        for (let entityClassName of entityClassNames) {\n            //TODO check if content of right form otherwise null\n            const entityClassContent = content[entityClassName];\n            const entityClass = entityClasses[entityClassName];\n            let entityIds;\n            if (entityIdList === '*') {\n                entityIds = Object.keys(entityClassContent);\n            } else {\n                entityIds = entityIdList.split(',');\n            }\n            const entityClassResponse = entityClass.createEntityClassResponse(status, entityClassContent, entityIds);\n            response.set(entityClassName, entityClassResponse);\n        }\n    }\n    return response;\n};\n\nconst transform = (source, transformation, entityClasses) => {\n    const target = new Response();\n    for (let entityClassName of source.keys()) {\n        if (entityClasses.hasOwnProperty(entityClassName)) {\n            const entityClass = entityClasses[entityClassName];// TODO check if exists\n            const entityClassSource = source.get(entityClassName);\n            const entityClassTarget = entityClass.transform(entityClassSource, transformation);\n            target.set(entityClassName, entityClassTarget);\n        } else {\n            console.error('entityClassName ' + entityClassName + ' not available.');\n        }\n    }\n    return target;\n};\n\nexports.create = create;\nexports.constructor = Response;\nexports.transform = transform;\n\n//# sourceURL=webpack://xyz/./source/response/response.js?");

/***/ }),

/***/ "./source/uri/uri.js":
/*!***************************!*\
  !*** ./source/uri/uri.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const pathFromUri = uri => {\n    if (uri.startsWith('/')) {\n        uri = uri.substr(1);\n    }\n    if (uri.endsWith('/')) {\n        uri = uri.slice(0, -1);\n    }\n    return uri.split('/');\n};\n\nconst wrapContent = (uri, content) => {\n    const wrapper = {};\n    const path = pathFromUri(uri);\n    let wrapperIterator = wrapper;\n    for (let depth = 0; depth < path.length; ++depth) {\n        const key = path[depth];\n        wrapperIterator = wrapperIterator[key] = (depth === path.length - 1) ? content : {};\n    }\n    return wrapper;\n};\n\nconst getEntityClassNames = (uri, entityClasses) => {\n    const path = pathFromUri(uri);\n    const entityClassNameList = path[0] || '*';\n    if (entityClassNameList === '*') {\n        return Object.keys(entityClasses);\n    } else {\n        return entityClassNameList.split(','); //TODO check if exist\n    }\n};\n\nconst getBaseUri = uri => {\n    const path0 = pathFromUri(uri)[0];\n    return '/' + (typeof path0 === 'string' ? path0 : '*');\n};\n\nexports.getBaseUri = getBaseUri;\nexports.getEntityClassNames = getEntityClassNames;\nexports.pathFromUri = pathFromUri;\nexports.wrapContent = wrapContent;\n\n//# sourceURL=webpack://xyz/./source/uri/uri.js?");

/***/ })

/******/ });