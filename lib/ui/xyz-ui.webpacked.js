var xyz =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./source/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../types/array.js":
/*!*******************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/lib/types/array.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (xyz, uri, status, content, settings, options, onChange) {\n        // TODO create ui for adding/removing elements\n        // TODO create drop ui to drag elements to\n        const SPAN = document.createElement('SPAN');\n        //TODO check if content is array\n        const subSettings = settings.subType;\n        const subOptions = options; //TODO\n        for (let key in content) {\n            const subUri = uri + '/' + key;\n            const subContent = content[key];\n            const TAG = xyz.renderElement('view', subUri, status, subContent, subSettings, subOptions);\n            const DIV_sub = document.createElement('DIV');\n\n            const INPUT_remove = document.createElement('INPUT');\n            INPUT_remove.type = 'submit';\n            INPUT_remove.value = 'x';\n\n            DIV_sub.appendChild(INPUT_remove);\n            DIV_sub.appendChild(TAG);\n            SPAN.appendChild(DIV_sub);\n        }\n        const subUri = uri; //TODO add something\n        const newContent = null;//TODO default value\n        const DIV_CREATE = document.createElement('DIV');\n        const INPUT_create = document.createElement('INPUT');\n        INPUT_create.type = \"submit\";\n        INPUT_create.value = \"Add\";\n        const TAG_create = xyz.renderElement('edit', subUri, status, newContent, subSettings, subOptions);\n        DIV_CREATE.appendChild(TAG_create);\n        DIV_CREATE.appendChild(INPUT_create);\n\n        SPAN.appendChild(DIV_CREATE);\n        return SPAN;\n    },\n    view: function (xyz, uri, status, content, settings, options) {\n        const SPAN = document.createElement('SPAN');\n        //TODO check if content is array\n        const subSettings = settings.subType;\n        const subOptions = options; //TODO\n        for (let key in content) {\n            const subUri = uri + '/' + key;\n            const subContent = content[key];\n            const TAG = xyz.renderElement('view', subUri, status, subContent, subSettings, subOptions);\n            SPAN.appendChild(TAG);\n        }\n        return SPAN;\n    },\n    validate: function (xyz, uri, status, content, settings, options) {\n        if (content === null || typeof content !== 'object') {\n            return false;\n        }\n        const subSettings = settings.subType;\n        const subOptions = options; //TODO\n        for (let key in content) {\n            const subUri = uri + '/' + key;\n            const subContent = content[key];\n            xyz.validate(subUri, subStatus, content, subSettings, subOptions)\n        }\n        return true;//TODO\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/lib/types/array.js?");

/***/ }),

/***/ "../../types/file.js":
/*!******************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/lib/types/file.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (xyz, uri, status, content, settings, options, onChange) {\n        const prepareContent = (files) => {\n            //TODO add filetype validation (using accept to catch client side injections)\n            const data = {};\n            if (settings.multiple) {\n                //TODO content = '[' + files.map(file => file.text()).join(',') + ']';\n            } else if (files.length === 0) {\n                //TODO\n            } else {\n                const reader = new FileReader();\n                reader.onload = evt => {\n                    data['content'] = evt.target.result;\n                    const extension = settings.signature['id'].storage.extension;\n                    let key;\n                    //TODO or extension is mixed extensions for example \"json|xml\"\n                    if (extension && extension !== '*') {\n                        key = files[0].name.split('.').splice('.').slice(0, -1).join('.');\n                    } else {\n                        key = files[0].name;\n                    }\n                    data['id'] = key;\n                    onChange(data);\n                };\n                reader.onerror = evt => {\n                    //TODO\n                };\n                reader.readAsText(files[0], \"UTF-8\");\n            }\n        };\n\n        // TODO add id from options (for label for)\n        const INPUT = document.createElement('INPUT');\n        INPUT.type = 'file';\n        if (content) {\n            INPUT.value = content;\n        }\n        if (onChange) {\n            INPUT.addEventListener('change', event => {\n                prepareContent(event.target.files, onChange);\n            });\n        }\n        if (settings.multiple) {\n            INPUT.multiple = true;\n        }\n        if (settings.accept) {\n            INPUT.accept = settings.accept;\n        }\n        return INPUT;\n    },\n    /*view: function (xyz, uri, status, content, settings, options) {\n        //TODO use a file viewer:   https://viewerjs.org/\n        return content;\n    },*/\n    validate: function (xyz, uri, status, content, settings, options) {\n        //TODO implement client side validation\n        //todo mime/accept\n        //todo max size\n        return true;\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/lib/types/file.js?");

/***/ }),

/***/ "../../types/id.js":
/*!****************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/lib/types/id.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (xyz, uri, status, content, settings, options, onChange) {\n        //TODO make visible with options.something\n        const SPAN = document.createElement('SPAN');\n        SPAN.innerText = 'auto increment';\n        return SPAN;\n    },\n    view: function (xyz, uri, status, content, settings, options) {\n        //TODO make visible with options.something\n        const SPAN = document.createElement('SPAN');\n        SPAN.innerText = content;\n        return SPAN;\n    },\n    validate: function (xyz, uri, status, content, settings, options) {\n        //TODO should be 0 or null always?\n        return true;//TODO\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/lib/types/id.js?");

/***/ }),

/***/ "../../types/reference.js":
/*!***********************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/lib/types/reference.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (xyz, uri, status, content, settings, options, onChange) {\n        //TODO use dropdown view\n        //TODO pass onChange\n        const flavor = options.flavor || 'dropdown';\n        //TODO set value\n        const TAG = xyz.ui('/' + settings.class + '/*/id', {\n            display: 'list',\n            flavor,\n            select: onChange,\n            initialValue: content\n        }); // TODO how to determine id or title?\n        return TAG;\n    },\n    view: function (xyz, uri, status, content, settings, options) {\n        const DIV = document.createElement('DIV');\n        xyz.ui('/' + settings.class + '/' + content, {display: 'view'}, DIV);\n        return DIV;\n    },\n    validate: function (xyz, uri, status, content, settings, options) {\n        //TODO implement client side validation\n        return true;//TODO\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/lib/types/reference.js?");

/***/ }),

/***/ "../../types/string.js":
/*!********************************************************************************!*\
  !*** /Users/Rouke/Documents/Mijn projecten/koppelbot/site/lib/types/string.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.actions = {\n    edit: function (xyz, uri, status, content, settings, options, onChange) {\n        const INPUT = document.createElement('INPUT');\n        if (content) {\n            INPUT.value = content;\n        }\n        if (onChange) {\n            INPUT.oninput = event => {\n                onChange(event.target.value)};\n        }\n\n        // TODO add id from options (for label for)\n        //TODO add validation regex\n\n        return INPUT;\n    },\n    view: function (xyz, uri, status, content, settings, options) {\n        const SPAN = document.createElement('SPAN');\n        switch(status) {\n            case 500 : SPAN.innerText = 'Server error'; break;\n            case 400 : SPAN.innerText = 'Bad request'; break;\n            case 403 : SPAN.innerText = 'Forbidden'; break;\n            case 404 : SPAN.innerText = 'Not found'; break;\n            default: SPAN.innerText = content;break;\n        }\n        return SPAN;\n    },\n    validate: function (xyz, uri, status, ontent, settings, options) {\n        //TODO implement client side validation\n        return true;//TODO\n    }\n};\n\n//# sourceURL=webpack://xyz//Users/Rouke/Documents/Mijn_projecten/koppelbot/site/lib/types/string.js?");

/***/ }),

/***/ "./build/types.js":
/*!************************!*\
  !*** ./build/types.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// This file is created by gulpfile.js using the type definitions of lib/types/*.js. \n\nexports.array = __webpack_require__(/*! ../../../types/array.js */ \"../../types/array.js\").actions;\nexports.file = __webpack_require__(/*! ../../../types/file.js */ \"../../types/file.js\").actions;\nexports.id = __webpack_require__(/*! ../../../types/id.js */ \"../../types/id.js\").actions;\nexports.reference = __webpack_require__(/*! ../../../types/reference.js */ \"../../types/reference.js\").actions;\nexports.string = __webpack_require__(/*! ../../../types/string.js */ \"../../types/string.js\").actions;\n\n\n//# sourceURL=webpack://xyz/./build/types.js?");

/***/ }),

/***/ "./source/display/list.js":
/*!********************************!*\
  !*** ./source/display/list.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\noptions\n- select\n- multiSelect\n- flavor\n- default\n */\n\nconst DEFAULT_FLAVORNAME = 'table';\nconst flavors = {};\n\nfunction select(xyz, options, entityId) {\n    if (typeof options.select === 'string') {\n        xyz.setVariable(options.select, entityId);\n    } else if (typeof options.select === 'function') {\n        options.select(entityId);\n    }\n}\n\nflavors.table = (options, xyz) => (PARENT, TAG, key, uri, status, depth, primitive) => {\n    if (depth === 0) {\n        const TABLE = document.createElement('TABLE');\n        TABLE.className = 'xyz-list';\n        const TR_header = document.createElement('TR');\n        TR_header.className = 'xyz-list-header';\n        if (options.multiSelect) {\n            const TD = document.createElement('TD');\n            TR_header.appendChild(TD);\n        }\n        TABLE.appendChild(TR_header);\n        PARENT.appendChild(TABLE);\n        return TABLE;\n    } else if (depth === 2) {\n        const TABLE = PARENT;\n        const entityId = key;\n        const TR = document.createElement('TR');\n        TR.className = 'xyz-list-item';\n        if (options.multiSelect) {\n            const variableName = options.multiSelect;\n            const TD = document.createElement('TD');\n            const INPUT = document.createElement('INPUT');\n            INPUT.type = \"checkbox\";\n            INPUT.onclick = event => {\n                const entityIds = xyz.hasVariable(variableName)\n                    ? xyz.getVariable(variableName).split(',')\n                    : [];\n                if (INPUT.checked) {\n                    if (!entityIds.includes(entityId)) {\n                        entityIds.push(entityId);\n                    }\n                } else {\n                    const index = entityIds.indexOf(entityId);\n                    if (index !== -1) {\n                        entityIds.splice(index, 1);\n                    }\n                }\n                if (entityIds.length === 0) {\n                    xyz.clearVariable(variableName);\n                } else {\n                    xyz.setVariable(variableName, entityIds.join(','));\n                }\n                event.stopPropagation();\n            };\n            TD.appendChild(INPUT);\n            TR.appendChild(TD);\n        }\n        if (options.select) {\n            if (xyz.getVariable(options.select) === entityId || options.default === entityId) {\n                TR.classList.add('xyz-list-selected');\n            }\n            TR.onclick = () => {\n                select(xyz, options, entityId);\n                for (let row of TABLE.childNodes) {\n                    if (row === TR) {\n                        row.classList.add('xyz-list-selected');\n                    } else {\n                        row.classList.remove('xyz-list-selected');\n                    }\n                }\n            };\n        }\n        TABLE.appendChild(TR);\n        return TR;\n    } else if (primitive) {\n        const TR = PARENT;\n        const TABLE = TR.parentNode;\n        const TR_header = TABLE.firstChild;\n        let found = false;\n        for (let TD_header of TR_header.childNodes) {\n            if (TD_header.innerHTML === key) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            const TD_header = document.createElement('TD');\n            TD_header.innerHTML = key;\n            TR_header.appendChild(TD_header);\n        }\n        const TD = document.createElement('TD');\n        TD.appendChild(TAG);\n        TR.appendChild(TD);\n        return null;\n    } else {\n        return PARENT;\n    }\n};\n\nflavors.dropdown = (options, xyz) => (PARENT, TAG, key, uri, status, depth, primitive) => {\n    if (depth === 0) {\n        const SELECT = document.createElement('SELECT');\n        SELECT.onchange = () => {\n            const entityId = SELECT.options[SELECT.selectedIndex].value;\n            select(xyz, options, entityId);\n        };\n        PARENT.appendChild(SELECT);\n        return SELECT;\n    } else if (primitive) {\n        const SELECT = PARENT;\n        const entityId =  TAG.innerHTML;\n        if (SELECT.childElementCount === 0 && !options.initialValue) { // select the first option as default TODO unless other default is defined\n            select(xyz, options, entityId);\n        }\n\n        const OPTION = document.createElement('OPTION');\n        if (options.initialValue === entityId) {\n            select(xyz, options, entityId);\n            OPTION.selected = true;\n        }\n        OPTION.appendChild(TAG);\n        SELECT.appendChild(OPTION);\n        return PARENT;\n    } else {\n        return PARENT;\n    }\n};\n\nexports.render = (options, xyz) => {\n    const flavorName = options.flavor || DEFAULT_FLAVORNAME;\n    //TODO check if flavor exists\n    return flavors[flavorName](options, xyz);\n};\n\n//# sourceURL=webpack://xyz/./source/display/list.js?");

/***/ }),

/***/ "./source/display/view.js":
/*!********************************!*\
  !*** ./source/display/view.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.render = (options, xyz) => (PARENT, TAG, key, uri, status, depth, primitive) => {\n    if (depth === 0) {\n        const TABLE = document.createElement('TABLE');\n        PARENT.appendChild(TABLE);\n        return TABLE;\n    } else if (primitive) {\n        const TR = document.createElement('TR');\n        if (options.showLabel !== false) {\n            const TD_label = document.createElement('TD');\n            TD_label.innerHTML = key;\n            TR.appendChild(TD_label);\n        }\n        const TD_content = document.createElement('TD');\n        TD_content.appendChild(TAG);\n        TR.appendChild(TD_content);\n        PARENT.appendChild(TR);\n        return null;\n    } else {\n        return PARENT;\n    }\n};\n\n//# sourceURL=webpack://xyz/./source/display/view.js?");

/***/ }),

/***/ "./source/entity/entity.js":
/*!*********************************!*\
  !*** ./source/entity/entity.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Property = __webpack_require__(/*! ./property.js */ \"./source/entity/property.js\").constructor;\nconst Response = __webpack_require__(/*! ../response/response.js */ \"./source/response/response.js\").constructor;\n\nexports.constructor = function Entity(entityClassName, settings) {\n    const properties = {};\n\n    for (let propertyName in settings) {\n        properties[propertyName] = new Property(propertyName, settings[propertyName], entityClassName,'');\n    }\n\n    this.getSettings = () => settings;\n\n    this.createEntityIdResponse = (entityStatus, entityContent) => {\n        const entityResponse = new Response();\n        if (entityStatus === 207) {\n            for (let propertyName in properties) {\n                const property207Wrapper = entityContent[propertyName];\n                if (property207Wrapper === null || typeof property207Wrapper !== 'object'\n                    || !property207Wrapper.hasOwnProperty('status')\n                    || !property207Wrapper.hasOwnProperty('content')\n                ) {\n                    //TODO reponse is in error\n                    console.error('error response in wrong format');\n                } else {\n                    const property = properties[propertyName];\n                    const propertyStatus = property207Wrapper.status;\n                    const propertyContent = property207Wrapper.content;\n                    const propertyResponse = property.createResponse(propertyStatus, propertyContent);\n                    entityResponse.set(propertyName, propertyResponse)\n                }\n            }\n        } else {\n            for (let propertyName in properties) {\n                const property = properties[propertyName];\n                const propertyContent = (entityContent === null || typeof entityContent !== 'object')\n                    ? null\n                    : entityContent[propertyName];\n                const propertyResponse = property.createResponse(entityStatus, propertyContent);\n                entityResponse.set(propertyName, propertyResponse)\n            }\n        }\n        return entityResponse;\n    };\n\n    this.createEntityClassResponse = (entityClassStatus, entityClassContent, entityIds) => {\n        const entityClassResponse = new Response();\n\n        if (entityClassStatus === 207) {\n            for (let entityId of entityIds) {\n                const entity207Wrapper = entityClassContent[entityId];\n                if (entity207Wrapper === null || typeof entity207Wrapper !== 'object'\n                    || !entity207Wrapper.hasOwnProperty('status')\n                    || !entity207Wrapper.hasOwnProperty('content')\n                ) {\n                    //TODO reponse is in error\n                    console.error('error response in wrong format');\n                } else {\n                    const entityStatus = entity207Wrapper.status;\n                    const entityContent = entity207Wrapper.content;\n                    const entityResponse = this.createEntityIdResponse(entityStatus, entityContent);\n                    entityClassResponse.set(entityId, entityResponse)\n                }\n            }\n        } else {\n            for (let entityId of entityIds) {\n                const entityContent = (entityClassContent === null || typeof entityClassContent !== 'object')\n                    ? null\n                    : entityClassContent[entityId];\n                const entityResponse = this.createEntityIdResponse(entityClassStatus, entityContent);\n                entityClassResponse.set(entityId, entityResponse)\n            }\n        }\n        return entityClassResponse;\n    };\n\n\n    this.createCreator = (options, data, xyz) => {\n        const TABLE = document.createElement('TABLE');\n        for (let propertyName in properties) {\n            for (let TR of properties[propertyName].createCreator(options, data, xyz)) {\n                TABLE.appendChild(TR);\n            }\n        }\n        return TABLE;\n    };\n\n    this.isAutoIncremented = () => {\n        for (let propertyName in properties) {\n            if (properties[propertyName].isAutoIncremented()) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    this.getIdFromContent = data => {\n        if (typeof data !== 'object' || data === null) {//TODO is_object\n            return null;\n        }\n        for (let propertyName in properties) {\n            if (data.hasOwnProperty(propertyName)) {\n                const id = properties[propertyName].getIdFromContent(data[propertyName]);\n                if (id) {\n                    return id;\n                }\n            }\n        }\n        return null;\n    };\n\n    this.transform = (entityClassSource, transformation) => {\n        const entityClassTarget = new Response();\n        for (let entityId of entityClassSource.keys()) {\n            const entitySource = entityClassSource.get(entityId);\n            const entityTarget = new Response();\n            for (let propertyName of entitySource.keys()) {\n                if (properties.hasOwnProperty(propertyName)) {\n                    const property = properties[propertyName];\n                    const subTarget = property.transform(entitySource.get(propertyName), transformation, entityId);\n                    entityTarget.set(propertyName, subTarget);\n                } else {\n                    console.error('entity transform: property does not exist');\n                    //TODO error\n                }\n            }\n            entityClassTarget.set(entityId, entityTarget);\n        }\n        return entityClassTarget;\n    };\n};\n\n//# sourceURL=webpack://xyz/./source/entity/entity.js?");

/***/ }),

/***/ "./source/entity/property.js":
/*!***********************************!*\
  !*** ./source/entity/property.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Response = __webpack_require__(/*! ../response/response.js */ \"./source/response/response.js\").constructor;\nconst types = __webpack_require__(/*! ../../build/types.js */ \"./build/types.js\");\n\nexports.constructor = function Property(propertyName, meta, entityClass, parentUri) {\n    const uri = parentUri + '/' + propertyName;\n    let isPrimitive = true;\n    let isId = false;\n    const subProperties = {};\n    const type = meta.type;\n    //TODO handle type alliasses?\n    const settings = meta; //TODO check if object\n    if (settings.hasOwnProperty('storage')) {\n        if (settings.storage.key === 'key' || settings.storage.key === 'basename') {\n            isId = true;\n        }\n    }\n    if (settings.hasOwnProperty('signature')) {\n        isPrimitive = false;\n        for (let propertyName in settings.signature) {\n            subProperties[propertyName] = new Property(propertyName, settings.signature[propertyName], entityClass, uri);\n        }\n    }\n    this.getSettings = () => settings;\n    this.getUri = entityId => {\n        return '/' + entityClass + '/' + entityId + uri;\n    };\n\n    this.createResponse = (propertyStatus, propertyContent) => {\n        const propertyResponse = new Response();\n        if (isPrimitive) {\n            propertyResponse.setContent(propertyStatus, propertyContent);\n        } else if (propertyStatus === 207) {\n            for (let subPropertyName in subProperties) {\n                const subProperty207Wrapper = propertyContent[subPropertyName];\n                if (subProperty207Wrapper === null || typeof subProperty207Wrapper !== 'object'\n                    || !subProperty207Wrapper.hasOwnProperty('status')\n                    || !subProperty207Wrapper.hasOwnProperty('content')\n                ) {\n                    //TODO reponse is in error\n                    console.error('error response in wrong format');\n                } else {\n                    const subProperty = subProperties[subPropertyName];\n                    const subStatus = subProperty207Wrapper.status;\n                    const subContent = subProperty207Wrapper.content;\n                    const subResponse = subProperty.createResponse(subStatus, subContent);\n                    propertyResponse.set(subPropertyName, subResponse)\n                }\n            }\n        } else {\n            for (let subPropertyName in subProperties) {\n                const subProperty = subProperties[subPropertyName];\n                const subPropertyContent = (propertyContent === null || typeof propertyContent !== 'object')\n                    ? null\n                    : propertyContent[subPropertyName];\n                const subPropertyResponse = subProperty.createResponse(propertyStatus, subPropertyContent);\n                propertyResponse.set(subPropertyName, subPropertyResponse)\n            }\n        }\n        return propertyResponse;\n    };\n\n    this.createCreator = (options, data, xyz) => {\n        const TRs = [];\n        if (types.hasOwnProperty(type) && types[type].hasOwnProperty('edit')) {\n            if (type === 'id') {\n                return TRs;\n            }\n            const uri = this.getUri('*'); //TODO double check this\n            const content = settings.hasOwnProperty('default') ? settings.default : null;\n            // TODO html label for gebruiken\n            const TR = document.createElement('TR');\n            const TD_label = document.createElement('TD');\n            TD_label.innerText = propertyName;\n            TR.appendChild(TD_label);\n            const onChange = content => {\n                data[propertyName] = content;\n            };\n            const element = types[type].edit(xyz, uri, 200, content, settings, options, onChange);\n            const TD_content = document.createElement('TD');\n            TD_content.appendChild(element);\n            TR.appendChild(TD_content);\n            TRs.push(TR);\n        } else if (!isPrimitive) {\n            for (let propertyName in subProperties) {\n                data[propertyName] = {};\n                TRs.push(...subProperties[propertyName].createCreator(options, data[propertyName], xyz));\n            }\n        }\n        return TRs;\n    };\n\n    this.isAutoIncremented = () => {\n        if (isPrimitive) {\n            return type === 'id';\n        } else {\n            for (let subPropertyName in subProperties) {\n                if (subProperties[subPropertyName].isAutoIncremented()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n\n    this.getIdFromContent = data => {\n        if (isPrimitive) {\n            return isId ? data : null;\n        } else {\n\n            if (typeof data !== 'object' || data === null) { //TODO is_object\n                return null;\n            }\n\n            for (let subPropertyName in subProperties) {\n                if (data.hasOwnProperty(subPropertyName)) {\n                    const id = subProperties[subPropertyName].getIdFromContent(data[subPropertyName]);\n                    if (id) {\n                        return id;\n                    }\n                }\n            }\n            return null;\n        }\n    };\n\n    // transformation =  (Response, Property, entityId) => transformedContent\n    this.transform = (propertySource, transformation, entityId) => {\n        const propertyTarget = new Response();\n        if (isPrimitive) {\n            const transformedContent = transformation(propertySource, this, entityId);\n            propertyTarget.setContent(propertySource.getStatus(), transformedContent);\n        } else {\n            for (let subPropertyName of propertySource.keys()) {\n                if (subProperties.hasOwnProperty(subPropertyName)) {\n                    const subProperty = subProperties[subPropertyName];\n                    const subPropertyTarget = subProperty.transform(propertySource.get(subPropertyName), transformation, entityId);\n                    propertyTarget.set(subPropertyName, subPropertyTarget);\n                } else {\n                    console.error('entity transform: property does not exist');\n                    //TODO error\n                }\n            }\n        }\n        return propertyTarget;\n    };\n};\n\n//# sourceURL=webpack://xyz/./source/entity/property.js?");

/***/ }),

/***/ "./source/main.js":
/*!************************!*\
  !*** ./source/main.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Entity = __webpack_require__(/*! ./entity/entity.js */ \"./source/entity/entity.js\").constructor;\nconst Response = __webpack_require__(/*! ./response/response.js */ \"./source/response/response.js\");\nconst uriTools = __webpack_require__(/*! ./uri/uri.js */ \"./source/uri/uri.js\");\nconst render = __webpack_require__(/*! ./render/render.js */ \"./source/render/render.js\");\n\nconst displays = {\n    list: __webpack_require__(/*! ./display/list.js */ \"./source/display/list.js\").render,\n    view: __webpack_require__(/*! ./display/view.js */ \"./source/display/view.js\").render\n};\n\nconst DEFAULT_ACTION = 'view';\nconst DEFAULT_DISPLAY = 'view';\nconst DEFAULT_TAG = 'DIV';\n\nfunction request(method, uri, data, callback) {\n    //TODO allow for multiple hosts by prepending http(s)://..\n    const location = 'http://localhost:8888/site/'; //TODO determine dynamically\n    const xhr = new XMLHttpRequest();\n    xhr.open(method, location + 'api' + uri, true);\n\n    xhr.onreadystatechange = e => {\n        if (xhr.readyState === 4) {\n            const status = xhr.status;\n            const content = xhr.responseText;\n            callback(status, content);\n        }\n    };\n    xhr.send(data);\n}\n\nfunction XYZ() {\n    const entityClasses = {};\n    const variables = {};\n\n    this.hasVariable = variableName => variables.hasOwnProperty(variableName);\n    this.getVariable = (variableName, fallback) => variables.hasOwnProperty(variableName) ? variables[variableName] : fallback;\n\n    const handleVariableChange = variableName => {\n        for (let uri in uriCallbacks) {\n            if (uri.indexOf('$' + variableName) !== -1) { // TODO find ${variableName} and ignore $variableNameWithPostfix\n                for (let callback of uriCallbacks[uri]) {\n                    handleUri(uri, callback);\n                }\n            }\n        }\n    };\n\n    this.clearVariable = variableName => {\n        delete variables[variableName];\n        handleVariableChange(variableName);\n    };\n\n    this.setVariable = (variableName, value) => {\n        if (value !== variables[variableName]) {\n            variables[variableName] = value;\n            handleVariableChange(variableName);\n        }\n    };\n\n    const uriCallbacks = {};\n\n    function handleUri(uri, callbacks) {\n        let complete = true;\n        //TODO find ${variableName}\n        uri = uri.replace(/\\$(\\w+)/, (_, variableName) => {\n            if (variables.hasOwnProperty(variableName)) {\n                return variables[variableName];\n            } else {\n                complete = false;\n                return '$' + variableName;\n            }\n        });\n        if (complete) {\n            callbacks.ready(uri);\n        } else {\n            callbacks.wait(uri);\n        }\n    }\n\n    /* setInterval(()=>{\n         for(let uri in uriCallbacks){\n             for(let callback of uriCallbacks[uri]){\n                 handleUri(uri,callback);\n             }\n         }\n     },2000)*/\n\n    function registerUri(uri, readyCallback, waitCallback) {\n        const callbacks = {ready: readyCallback, wait: waitCallback};\n        if (!uriCallbacks.hasOwnProperty(uri)) {\n            uriCallbacks[uri] = [callbacks];\n        } else {\n            uriCallbacks[uri].push(callbacks);\n        }\n        handleUri(uri, callbacks);\n    }\n\n    const retrieveMeta = (uri, callback) => {\n        const path = uri.substr(1).split('/');\n        const entityClassNameList = path[0]; // TODO error if no entityClass\n\n        const entityClassNames = entityClassNameList.split(',').filter(entityClass => !entityClasses.hasOwnProperty((entityClass)));\n        if (entityClassNames.length === 0) {\n            callback();\n        } else {\n            request('GET', '/' + entityClassNames.join(',') + '?meta', undefined, (status, content) => {//TODO add querystring better\n                //TODO check status\n                console.log(content)\n                const data = JSON.parse(content); //TODO check\n                for (let entityClassName of entityClassNames) {\n                    entityClasses[entityClassName] = new Entity(entityClassName, data[entityClassName]['*']);\n                }\n                callback();\n            });\n        }\n    };\n\n    this.patch = (uri, content, callback) => {\n        console.log('patch request', uri, content)\n        content = typeof content === 'string' ? content : JSON.stringify(content);\n        request('PATCH', uri, content, (status, response) => {\n            //TODO check for errors\n            console.log('patch response:' + response, uri)\n            //TODO callback\n        });\n    };\n\n    this.put = (uri, content, callback) => {\n        console.log('put request', uri, content)\n        content = typeof content === 'string' ? content : JSON.stringify(content);\n        request('PUT', uri, content, (status, response) => {\n            //TODO check for errors\n            console.log('put response', uri, response)\n            //TODO callback\n        });\n    };\n\n    this.head = (uri, content, callback) => {\n        //TODO\n    };\n    this.post = (uri, content, callback) => {\n        console.log('post request', uri, content);\n        content = typeof content === 'string' ? content : JSON.stringify(content);\n        request('POST', uri, content, (status, response) => {\n            //TODO check for errors\n            console.log('post response:' + response, uri)\n            //TODO callback\n        });\n    };\n\n    // callback = Response =>{}\n    // get the requested uri from cache or request it from server\n    this.get = (uri, callback) => {\n        // get the meta data\n        retrieveMeta(uri, () => {\n            //TODO meta should be good or we have a problem\n            //TODO get the data from cache if already in cache\n            request('GET', uri, undefined, (status, content) => {//TODO add querystring better\n                const response = Response.parse(uri, status, content, entityClasses);\n                callback(response);\n            });\n        });\n    };\n\n\n    //============================================================\n    // RENDERING should be refactored with better naming\n    //============================================================\n\n    this.renderElement = (action, uri, status, content, settings, options) => {\n        return render.element(this, action, uri, status, content, settings, options);\n    };\n\n    const renderNode = (action, options) => (source, property, entityId) => {\n        const uri = property.getUri(entityId);\n        const settings = property.getSettings();\n        const content = source.getContent();\n        const status = source.getStatus();\n        return this.renderElement(action, uri, status, content, settings, options);\n    };\n\n    const renderDisplay = (TAG, options) => (uri) => {\n        this.get(uri, response => {\n            const action = options.action || DEFAULT_ACTION;\n            const display = options.display || DEFAULT_DISPLAY;\n            response = response.filter(uri);\n            const node = Response.transform(response, renderNode(action, options), entityClasses);\n            const mapper = displays[display](options, this); // TODO check if exists,use default or custom otherwise\n            TAG.innerHTML = '';\n            TAG.classList.remove('xyz-waiting');\n            node.map(mapper, TAG);\n        });\n    };\n\n    const renderUiElement = (uri, options, TAG) => {\n        registerUri(uri,\n            renderDisplay(TAG, options),\n            uri => {\n                TAG.classList.add('xyz-waiting');\n                TAG.innerHTML = 'Not ready'\n            }\n        );\n    };\n\n    const renderUiCreate = (uri, options, TAG) => {\n        retrieveMeta(uri, () => {\n            const entityClassName = uriTools.pathFromUri(uri)[0];\n            const entityClass = entityClasses[entityClassName];\n            const data = {};\n            const TABLE = entityClass.createCreator(options, data, this);\n            TAG.appendChild(TABLE);\n            const INPUT = document.createElement('INPUT');\n            INPUT.type = 'submit';\n            INPUT.onclick = () => {\n                if (entityClass.isAutoIncremented()) {\n                    this.post(uri, {[entityClassName]: {'new': data}},);\n                } else {\n                    const entityId = entityClass.getIdFromContent(data);\n                    this.put(uri + '/' + entityId, {[entityClassName]: {[entityId]: data}},);\n                }\n            };\n            TAG.appendChild(INPUT);\n        });\n        return TAG;\n    };\n\n    this.ui = (uri, options, TAG) => {\n        options = options || {};\n        let SCRIPT;\n        if (typeof TAG === 'undefined') {\n            const tag = options.tag || DEFAULT_TAG;\n            TAG = document.createElement(tag);\n            SCRIPT = document.currentScript;\n        }\n        if (options.id) {\n            TAG.id = options.id;\n        }\n        if (options.class) {\n            TAG.class = options.class || '';\n        }\n        if (SCRIPT) {\n            SCRIPT.parentNode.insertBefore(TAG, SCRIPT);\n            SCRIPT.parentNode.removeChild(SCRIPT);\n        }\n        if (options.display === 'create') {\n            renderUiCreate(uri, options, TAG);\n        } else {\n            renderUiElement(uri, options, TAG);\n        }\n        return TAG;\n    };\n\n\n}\n\nconst xyz = new XYZ();\nexports.ui = xyz.ui;\nexports.create = xyz.create;\n\n//# sourceURL=webpack://xyz/./source/main.js?");

/***/ }),

/***/ "./source/render/render.js":
/*!*********************************!*\
  !*** ./source/render/render.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const types = __webpack_require__(/*! ../../build/types.js */ \"./build/types.js\");\nconst uriTools = __webpack_require__(/*! ../uri/uri.js */ \"./source/uri/uri.js\");\n\nconst DEFAULT_TYPE = 'string';\n\nfunction renderElement(xyz, action, uri, status, content, settings, options) {\n    const type = settings.type || DEFAULT_TYPE;\n    if (!types.hasOwnProperty(type)) {\n        console.error('problem1');\n        return;\n    }\n    if (types[type].hasOwnProperty(action)) {\n        let onChange;\n        if (action === 'edit') {\n            onChange = content => {\n                xyz.patch(uri, uriTools.wrapContent(uri, content));\n            }\n        }\n        const TAG = types[type][action](xyz, uri, status, content, settings, options, onChange);\n        TAG.className = `xyz-status-${status}`;\n        return TAG;\n    } else if (settings.hasOwnProperty('signature')) { // create editor from signature view\n        //TODO check if content if object\n        //TODO check if settings.signature is object\n        const DIV = document.createElement('DIV');\n        DIV.className = `xyz-status-${status}`;\n        for (let subPropertyName in settings.signature) {\n            const subSettings = settings.signature[subPropertyName];\n            const subContent = content[subPropertyName];\n            const subType = subSettings.type;\n            const subUri = uri + '/' + subPropertyName;\n            const TAG = renderElement(xyz, subType, action, subUri, status, subContent, subSettings, options);\n            TAG.className = `xyz-status-${status}`;\n            DIV.appendChild(TAG);\n        }\n        return DIV;\n    } else {\n        console.error('problem1');\n        //TODO something default and/or error\n    }\n}\n\nexports.element = renderElement;\n\n//# sourceURL=webpack://xyz/./source/render/render.js?");

/***/ }),

/***/ "./source/response/response.js":
/*!*************************************!*\
  !*** ./source/response/response.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const uriTools = __webpack_require__(/*! ../uri/uri.js */ \"./source/uri/uri.js\");\n\nfunction Response() {\n    let primitive;\n    const subResponses = {};\n    let status;\n    let content;\n    this.getStatus = () => status;\n    this.getContent = () => {\n        //TODO if not primitive => throw\n        return content;\n    };\n    this.setContent = (status_, content_) => {\n        primitive = true;\n        status = status_;\n        content = content_;\n    };\n    this.set = (key, subResponse) => {\n        primitive = false;\n        const subStatus = subResponse.getStatus();\n        subResponses[key] = subResponse;\n        if (Object.keys(subResponses).length === 0) {\n            status = subStatus;\n        } else if (status !== subStatus) {\n            status = 207;\n        }\n    };\n    this.isPrimitive = () => primitive;\n\n    // func = (subResponse, propertyName, response) => {}\n    this.forEach = func => {\n        if (primitive === true) {\n            //TODO throw error\n        } else {\n            for (let propertyName in subResponses) {\n                const subResponse = subResponses[propertyName];\n                func(subResponse, propertyName, this);\n            }\n        }\n    };\n    this.toObject = () => {\n        if (primitive === true) {\n            return content;\n        } else if (primitive === false) {\n            const object = {};\n            for (let propertyName in subResponses) {\n                object[propertyName] = subResponses[propertyName].toObject();\n            }\n            return object;\n        } else {\n            return undefined;\n        }\n\n    };\n    // transformation = (content,  uri, status, depth) => {...}\n    this.transform = (transformation, uri, depth) => {\n        uri = typeof uri === 'undefined' ? '' : uri;\n        depth = typeof depth === 'undefined' ? 0 : depth;\n        const node = new Response();\n        if (primitive) {\n            const transformedContent = transformation(content, uri, status, depth);\n            node.setContent(status, transformedContent);\n        } else {\n            this.forEach((subResponse, key) => {\n                const transformedSubResponse = subResponse.transform(transformation, uri + '/' + key, depth + 1);\n                node.set(key, transformedSubResponse);\n            })\n        }\n        return node;\n    };\n\n    // mapping = ( accumulator, content, key, uri, status, depth, primitive) => {...}\n    this.map = (mapping, parent, key, uri, depth) => {\n        uri = typeof uri === 'undefined' ? '' : uri;\n        depth = typeof depth === 'undefined' ? 0 : depth;\n        key = typeof key === 'undefined' ? '' : key;\n        if (primitive) {\n            mapping(parent, content, key, uri, status, depth, true);\n            return null;\n        } else {\n            const node = mapping(parent, content, key, uri, status, depth, false);\n            for (let propertyName in subResponses) {\n                const subResponse = subResponses[propertyName];\n                subResponse.map(mapping, node, propertyName, uri + '/' + propertyName, depth + 1);\n            }\n            return node;\n        }\n    };\n    this.filter_ = path => {\n        if (path.length === 0 && primitive) {\n            const response = new Response();\n            response.setContent(status, this.toObject());\n            return response;\n        }\n        const response = new Response();\n        let propertyNames;\n        if (path[0] === '*' || path.length === 0) {\n            propertyNames = Object.keys(subResponses);\n        } else {\n            propertyNames = path[0].split(',');\n        }\n        for (let propertyName of propertyNames) {\n            const subResponse = subResponses[propertyName].filter_(path.slice(1));\n            response.set(propertyName, subResponse);\n        }\n        return response;\n    };\n\n    this.filter = uri => {\n        return this.filter_(uriTools.pathFromUri(uri));\n    };\n    this.keys = () => Object.keys(subResponses);\n    this.has = key => subResponses.hasOwnProperty(key);\n    this.get = key => subResponses[key];\n}\n\n\nconst parse = (uri, status, content, entityClasses) => {\n    //TODO check status\n    content = JSON.parse(content);//TODO check\n\n    const response = new Response();\n    const path = uriTools.pathFromUri(uri);\n    const entityClassNameList = path[0]; // TODO error if no entityClass\n    const entityIdList = path[1] || '*';\n    const entityClassNames = entityClassNameList.split(',');\n    if (status === 207) {\n        for (let entityClassName of entityClassNames) {\n            const entityClass207Wrapper = content[entityClassName];\n            if (entityClass207Wrapper === null || typeof entityClass207Wrapper !== 'object'\n                || !entityClass207Wrapper.hasOwnProperty('status')\n                || !entityClass207Wrapper.hasOwnProperty('content')\n            ) {\n                console.error('error response in wrong format');//TODO\n            } else {\n                const entityClassStatus = entityClass207Wrapper.status;\n                const entityClassContent = entityClass207Wrapper.content;\n                const entityClass = entityClasses[entityClassName];\n                let entityIds;\n                if (entityIdList === '*') {\n                    entityIds = Object.keys(entityClassContent);\n                } else {\n                    entityIds = entityIdList.split(',');\n                }\n                const entityClassResponse = entityClass.createEntityClassResponse(entityClassStatus, entityClassContent, entityIds);\n                response.set(entityClassName, entityClassResponse);\n            }\n        }\n    } else {\n        for (let entityClassName of entityClassNames) {\n            //TODO check if content of right form otherwise null\n            const entityClassContent = content[entityClassName];\n            const entityClass = entityClasses[entityClassName];\n            let entityIds;\n            if (entityIdList === '*') {\n                entityIds = Object.keys(entityClassContent);\n            } else {\n                entityIds = entityIdList.split(',');\n            }\n            const entityClassResponse = entityClass.createEntityClassResponse(status, entityClassContent, entityIds);\n            response.set(entityClassName, entityClassResponse);\n        }\n    }\n    return response;\n};\n\nconst transform = (source, transformation, entityClasses) => {\n    const target = new Response();\n    for (let entityClassName of source.keys()) {\n        if (entityClasses.hasOwnProperty(entityClassName)) {\n            const entityClass = entityClasses[entityClassName];// TODO check if exists\n            const entityClassSource = source.get(entityClassName);\n            const entityClassTarget = entityClass.transform(entityClassSource, transformation);\n            target.set(entityClassName, entityClassTarget);\n        } else {\n            console.error('entityClassName ' + entityClassName + ' not available.');\n        }\n    }\n    return target;\n};\n\nexports.parse = parse;\nexports.constructor = Response;\nexports.transform = transform;\n\n//# sourceURL=webpack://xyz/./source/response/response.js?");

/***/ }),

/***/ "./source/uri/uri.js":
/*!***************************!*\
  !*** ./source/uri/uri.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const pathFromUri = uri => {\n    if (uri.startsWith('/')) {\n        uri = uri.substr(1);\n    }\n    if (uri.endsWith('/')) {\n        uri = uri.slice(0, -1);\n    }\n    return uri.split('/');\n};\n\nconst wrapContent = (uri, content) => {\n    const wrapper = {};\n    const path = pathFromUri(uri);\n    let wrapperIterator = wrapper;\n    for (let depth = 0; depth < path.length; ++depth) {\n        const key = path[depth];\n        wrapperIterator = wrapperIterator[key] = (depth === path.length - 1) ? content : {};\n    }\n    return wrapper;\n};\n\nexports.pathFromUri = pathFromUri;\nexports.wrapContent = wrapContent;\n\n//# sourceURL=webpack://xyz/./source/uri/uri.js?");

/***/ })

/******/ });